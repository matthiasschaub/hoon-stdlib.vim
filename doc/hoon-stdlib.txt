*hoon-stdlib.txt*  Documentation for the Hoon standard library

           -------------------------------------------------------
                       HOON STANDARD LIBRARY REFERENCE
           -------------------------------------------------------

Author: ~talfus-laddus
Repository: https://git.sr.ht/~matthias_schaub/hoon-stdlib.vim
License: MIT License
Updated: 2023-02-06


==============================================================================
 3e: AES encryption Removed                                                                         

The standard-library functions in this section have been removed.



==============================================================================
 1a: Basic Arithmetic                                                                         

------------------------------------------------------------------------------
ADD                                                                  *++add*

Add

Produces the sum of `a` and `b`.

Accepts~

`a` is an `atom`.

`b` is an `atom`.

Produces~

An `atom`.

Source~
>
    ++  add
      ~/  %add
      |=  [a=@ b=@]
      ^-  @
      ?:  =(0 a)  b
      $(a (dec a), b +(b))
<

Examples~
>
    > (add 2 2)
    4
<
>
    > (add 1 1.000.000)
    1.000.001
<
>
    > (add 1.333 (mul 2 2))
    1.337
<
>
    > (add 'a' 4)
    101
<
>
    > (add 'a' 'b')
    195
<
>
    > (add 0xc 0xf)
    27
<
>
    > `@ux`(add 0xc 0xf)
    0x1b
<


------------------------------------------------------------------------------
DEC                                                                  *++dec*

Decrement

Decrements `a` by `1`.

Accepts~

`a` is an `atom`.

Produces~

An `atom`.

Source~
>
    ++  dec
      ~/  %dec
      |=  a=@
      ~_  leaf+"decrement-underflow"
      ?<  =(0 a)
      =+  b=0
      |-  ^-  @
      ?:  =(a +(b))  b
      $(b +(b))
<

Examples~
>
    > (dec 7)
    6
<
>
    > (dec 0)
    ! decrement-underflow
    ! exit
<
>
    > (dec 'b')
    97
    > `@t`(dec 'b')
    'a'
<
>
    > (dec 0xc)
    11
    > `@ux`(dec 0xc)
    0xb
<


------------------------------------------------------------------------------
DIV                                                                  *++div*

Divide

Computes `a` divided by `b` without remainder.

Accepts~

`a` is an `atom`.

`b` is an `atom`.

Produces~

An `atom`.

Source~
>
    ++  div
      ~/  %div
      |:  [a=`@`1 b=`@`1]
      ^-  @
      ~_  leaf+"divide-by-zero"
      ?<  =(0 b)
      =+  c=0
      |-
      ?:  (lth a b)  c
      $(a (sub a b), c +(c))
<

Examples~
>
    > (div 4 2)
    2
<
>
    > (div 17 8)
    2
<
>
    > (div 20 30)
    0
<
>
    > (div 'ab' 'a')
    259
    > `@`'ab'
    25.185
    > `@`a
    97
<
>
    > (div 0x9f 0x29)
    6
<


------------------------------------------------------------------------------
DVR                                                                  *++dvr*

Divide with remainder

Computes `a` divided by `b`, producing the quotient and the remainder.

Accepts~

`a` is an `atom`.

`b` is an `atom`.

Produces~

A cell of `atoms`.

Source~
>
    ++  dvr
      ~/  %dvr
      |=  [a=@ b=@]
      ^-  [p=@ q=@]
      [(div a b) (mod a b)]
<

Examples~
>
    > (dvr 17 8)
    [p=2 q=1]
<
>
    > (dvr 17 6)
    [p=2 q=5]
<
>
    > (dvr 18 6)
    [p=3 q=0]
<
>
    > (dvr 4 2)
    [p=2 q=0]
<
>
    > (dvr 'ab 'a')
    [p=259 q=62]
    > `@`'a'
    97
    > `@`'ab'
    25.185
<


------------------------------------------------------------------------------
GTE                                                                  *++gte*

Greater-than/equal

Tests whether `a` is greater than or equal to `b`.

Accepts~

`a` is an `atom`.

`b` is an `atom`.

Produces~

A flag.

Source~
>
    ++  gte
      ~/  %gte
      |=  [a=@ b=@]
      ^-  ?
      !(lth a b)
<

Examples~
>
    > (gte 100 10)
    %.y
<
>
    > (gte 4 4)
    %.y
<
>
    > (gte 3 4)
    %.n
<


------------------------------------------------------------------------------
GTH                                                                  *++gth*

Greater-than

Tests whether `a` is greater than `b`.

Accepts~

`a` is an `atom`.

`b` is an `atom`.

Produces~

A flag.

Source~
>
    ++  gth
      ~/  %gth
      |=  [a=@ b=@]
      ^-  ?
      !(lte a b)
<

Examples~
>
    > (gth 'd' 'c')
    %.y
<
>
    > (gth ~h1 ~m61)
    %.n
<
>
    > (gth 'steak' 'brisket')
    %.n
<


------------------------------------------------------------------------------
LTE                                                                  *++lte*

Less-than/equal

Tests whether `a` is less than or equal to `b`.

Accepts~

`a` is an `atom`.

`b` is an `atom`.

Produces~

A flag.

Source~
>
    ++  lte
      ~/  %lte
      |=  [a=@ b=@]
      |(=(a b) (lth a b))
<

Examples~
>
    > (lte 4 5)
    %.y
<
>
    > (lte 5 4)
    %.n
<
>
    > (lte 5 5)
    %.y
<
>
    > (lte 0 0)
    %.y
<
>
    > (lte 'a' 'b')
    %.y
    > `@`'a'
    97
    > `@`'b'
    98
<
>
    > (lte 'abraham' 'bob')
    %.n
<
>
    > (lte ~m61 ~h1)
    %.n
<


------------------------------------------------------------------------------
LTH                                                                  *++lth*

Less-than

Tests whether `a` is less than `b`.

Accepts~

`a` is an `atom`.

`b` is an `atom`.

Produces~

A flag.

Source~
>
    ++  lth
      ~/  %lth
      |=  [a=@ b=@]
      ^-  ?
      ?&  !=(a b)
          |-
          ?|  =(0 a)
              ?&  !=(0 b)
                  $(a (dec a), b (dec b))
      ==  ==  ==
<

Examples~
>
    > (lth 4 5)
    %.y
<
>
    > (lth 5 4)
    %.n
<
>
    > (lth 5 5)
    %.n
<
>
    > (lth 5 0)
    %.n
<
>
    > (lth 'a' 'b')
    %.y
    > `@`'a'
    97
    > `@`'b'
    98
<
>
    > (lth 'abraham' 'bob')
    %.n
<


------------------------------------------------------------------------------
MAX                                                                  *++max*

Maximum

Computes the greater of `a` and `b`.

Accepts~

`a` is an `atom`.

`b` is an `atom`.

Produces~

An `atom`.

Source~
>
    ++  max
      ~/  %max
      |=  [a=@ b=@]
      ^-  @
      ?:  (gth a b)  a
      b
<

Examples~
>
    > (max 10 100)
    100
<
>
    > (max 10.443 9)
    10.443
<
>
    > (max 1 1)
    1
<
>
    > (max 'abraham' 'bob')
    30.787.873.400.840.801
<
>
    > `@t`(max 'abraham' 'bob')
    'abraham'
<
>
    > `@t`(max 'abraham' 'benjamin')
    'benjamin'
<
>
    > `@dr`(max ~m6 ~h1)
    ~h1
<
>
    >`@ux`(max 0xe1 0x1e)
    0xe1
<


------------------------------------------------------------------------------
MIN                                                                  *++min*

Minimum

Computes the lesser of `a` and `b`.

Accepts~

`a` is an `atom`.

`b` is an `atom`.

Produces~

An `atom`.

Source~
>
    ++  min
      ~/  %min
      |=  [a=@ b=@]
      ^-  @
      ?:  (lth a b)  a
      b
<

Examples~
>
    > (min 10 100)
    10
<
>
    > (min 10.443 9)
    9
<
>
    > (min 1 1)
    1
<
>
    > (min 'abraham' 'bob')
    6.451.042
<
>
    > `@t`(min 'abraham' 'bob')
    'bob'
<
>
    > `@t`(min 'abraham' 'benjamin')
    'abraham'
<
>
    > `@dr`(min ~m6 ~h1)
    ~m6
<


------------------------------------------------------------------------------
MOD                                                                  *++mod*

Modulus

Computes the remainder of dividing `a` by `b`.

Accepts~

`a` is an `atom`.

`b` is an `atom`.

Produces~

An `atom`.

Source~
>
    ++  mod
      ~/  %mod
      |:  [a=`@`1 b=`@`1]
      ^-  @
      ?<  =(0 b)
      (sub a (mul b (div a b)))
<

Examples~
>
    > (mod 5 2)
    1
<
>
    > (mod 5 5)
    0
<
>
    > (mod 2 5)
    2
<
>
    > (mod 40 20)
    0
<
>
    > `@`'c'
    99
    >`@`'a'
    97
    > (mod 'c' 'a')
    2
<


------------------------------------------------------------------------------
MUL                                                                  *++mul*

Multiply

Multiplies `a` by `b`.

Accepts~

`a` is an `atom`.

`b` is an `atom`.

Produces~

An `atom`.

Source~
>
    ++  mul
      ~/  %mul
      |:  [a=`@`1 b=`@`1]
      ^-  @
      =+  c=0
      |-
      ?:  =(0 a)  c
      $(a (dec a), c (add b c))
<

Examples~
>
    > (mul 3 4)
    12
<
>
    > (mul 0 1)
    0
<
>
    > `@`'a'
    97
    > `@`'b'
    98
    > (mul 'a' 'b')
    9.506
<
>
    >`@ux`(mul 0x1f 0xe)
    0x1b2
<


------------------------------------------------------------------------------
SUB                                                                  *++sub*

Subtract

Subtracts `b` from `a`.

Accepts~

`a` is an `atom`.

`b` is an `atom`.

Produces~

An `atom`.

Source~
>
    ++  sub
      ~/  %sub
      |=  [a=@ b=@]
      ~_  leaf+"subtract-underflow"
      ^-  @
      ?:  =(0 b)  a
      $(a (dec a), b (dec b))
<

Examples~
>
    > (sub 10 5)
    5
<
>
    > (sub 243 44)
    199
<
>
    > (sub 5 0)
    5
<
>
    > (sub 0 5)
    ! subtract-underflow
    ! exit
<
>
    > (sub 'c' 'a')
    2
    > `@`'c'
    99
    > `@`'a'
    97
<
>
    > (sub 0x1f 0xe)
    17
    > `@ux`(sub 0x1f 0xe)
    0x11
<


==============================================================================
 1b: Tree Addressing                                                                         

Check out the Nock explanation for more information on the tree-addressing
system.

------------------------------------------------------------------------------
CAP                                                                  *++cap*

Tree head

Tests whether the tree address `a` is in the head or the tail of a `noun`.
Produces the constant `atom` `%2` if it is within the head (subtree `+2`), or
the constant `atom` `%3` if it is within the tail (subtree `+3`).

Accepts~

`a` is an `atom`.

Produces~

A constant `atom`.

Source~
>
    ++  cap
      ~/  %cap
      |=  a=@
      ^-  ?(%2 %3)
      ?-  a
        %2        %2
        %3        %3
        ?(%0 %1)  !!
        *         $(a (div a 2))
      ==
<

Examples~
>
    > (cap 4)
    %2
<
>
    > (cap 6)
    %3
<
>
    > (cap (add 10 9))
    %2
<
>
    > (cap 1)    ::address '1' is in neither the head nor the tail
    ! exit
<
>
    > (cap 0x40))
    %2
    > `@`0x40
    64
<
>
    > (cap 'a')
    %3
    > `@`'a'
    97
<


------------------------------------------------------------------------------
MAS                                                                  *++mas*

Address within head/tail

Computes the tree address of `atom` `a` within either the head (`+2`) or tail
(`+3`) of a `noun`.

Accepts~

`a` is an `atom`.

Produces~

An `atom`.

Source~
>
    ++  mas
      ~/  %mas
      |=  a=@
      ^-  @
      ?-  a
        ?(%2 %3)  1
        ?(%0 %1)  !!
        *         (add (mod a 2) (mul $(a (div a 2)) 2))
      ==
<

Examples~
>
    > (mas 3)
    1
<
>
    > (mas 4)
    2
<
>
    > (mas 5)
    3
    > (cap 5)    ::`(cap a)` computes whether address `a` is in the head or the tail
    %2
<
>
    > (mas 7)
    3
    > (cap 7)
    %3
<
>
    > (mas 11)
    7
<
>
    > (mas (mas 11))
    3
<
>
    > (cap (mas 6))
    %3
<
>
    > (mas 0)    ::address `0` is in neither the head nor the tail
    ! exit
<
>
    > (mas 1)    ::address `1` is in neither the head nor the tail
    ! exit
<

Discussion~
>
                1
              /   \
             /     \
            2       3              <--here are the head (`+2`) and the tail (`+3`)
           / \      /\
          4   5    6  7
         /\   /\  /\  /\
         (continues...)
<

Running `(mas 7)` in the `Dojo` will return `3`, because address `+3` is what
`+7` now occupies. The tree below helps illustrate the relationship. With
parentheses are `a` values (if `a` is in subtree `+3`), and without
parentheses are the values returned with `(mas a)`.
>
                1(3)                       ::new/(old) addresses
               /    \
              2       3
             (6)     (7)
            / \       /\
           /   \     /  \
          4     5   6    7
         (12) (13) (14) (15)
        / \    / \ / \   / \
           (continues...)
<

Notice how the old values in the head (subtree `+2`) were not illustrated in
this case, because `+7` is within the tail (subtree `+3`).


------------------------------------------------------------------------------
PEG                                                                  *++peg*

Address within address

Computes the absolute address of `b`, a relative address within the subtree
`a`.

Accepts~

`a` is an `atom`.

`b` is an `atom`.

Produces~

An `atom`.

Source~
>
    ++  peg
      ~/  %peg
      |=  [a=@ b=@]
      ?<  =(0 a)
      ^-  @
      ?-  b
        %1  a
        %2  (mul a 2)
        %3  +((mul a 2))
        *   (add (mod b 2) (mul $(b (div b 2)) 2))
      ==
<

Examples~
>
    > (peg 4 1)
    4
<
>
    > (peg 1 4)
    4
<
>
    > (peg 4 2)
    8
<
>
    > (peg 4 8)
    32
<
>
    > (peg 4 (4 2))
    32
<
>
    > (peg 8 45)
    269
<
>
    > (cap (peg 4 2))    ::`(cap a)` computes whether address `a` is in the head or the tail
    %2
<

Discussion~

In other words, the subtree at address `a` is treated as a tree in its own
right (starting with root `+1`, head `+2`, and tail `+3`). Relative address
`b` is found with respect to `a`, and then its absolute address, within the
greater tree, is returned.

Running `(peg 3 4)` in the `Dojo`, for example, will return `12`. Looking at a
tree diagram makes it easy to see why.
>
                     1
                  /     \
                 /       \
                /         \
               2           3       <- here is the subtree `+3`. The subtree address is `a` in `(peg a b)`
              / \         / \
             /   \       /   \
            4     5     6     7
           / \   / \   / \   / \
          8  9  10 11 12 13 14  15
         /\  /\ /\ /\ /\ /\ /\  /\
             (continues...)
<

When we consider subtree at address `+3` by itself, it has relative addresses
that are structured in the same way as its parent tree's absolute addresses.
The absolute addresses are given in parentheses in the diagram below. Notice
how relative address `+4` is at the same position as absolute address `+12`.
>
                1(3)                        ::new/(old) addresses
               /    \
              2       3
             (6)     (7)
            / \       /\
           /   \     /  \
          4     5   6    7
        (12) (13) (14)  (15)
        / \    / \ / \   / \
           (continues...)
<



==============================================================================
 1c: Molds and Mold-Builders                                                                         

------------------------------------------------------------------------------
+$BITE                                                                  *+$bite*

Atom slice specifier.

Either a single atom representing block size, or a cell containing a block
size and an atom representing the number of blocks, called `step`. If `step`
is not supplied, it defaults to a value of 1.

Source~
>
        +$  bite  $@(bloq [=bloq =step])
<

Examples~
>
        ::  ++end gets the least significant bits of an atom.
    
        > (end [1 1] 255)
        3
    
        > (end 1 255)
        3
    
        > (end 3 255)
        255
    
        > (end 3 65.535)
        255
    
        > (end [3 2] 65.535)
        65.535
    
        > (end [3 0] 65.535)
        0
<

------------------------------------------------------------------------------
+$BLOQ                                                                  *+$bloq*

Blocksize

`Atom` representing block size. A block of size `a` has a bitwidth of `2^a`.

Source~
>
        ++  bloq  @
<

Examples~
>
        ::  ++met measures how many a-bloqs long an atom is.
    
        > (met 3 256)
        2
    
        > (met 3 255)
        1
    
        > (met 3 65.535)
        2
    
        > (met 2 65.536)
        > 3
    
        > (met 0 4)
        3
    
        > (met 1 4)
        2
    
        > (met 5 9.999.999.999)
        2
    
        > (met 2 0xb5)
        2
<

Discussion~

You can think of `bloq` as a numeral system that can represent values of
`a^2^2`, where `a` is the block size. That's because a block of size `a`
contains `a^2` bits, and a binary number that is `b` bits wide can represent
`b^2` values.

A `bloq` of 0 has a bitwidth of 1. (2^0 bits; can represent 2 values.)

A `bloq` of 1 has a bitwidth of 2. (2^1 bits; can represent 4 values.)

A `bloq` of 2 has a bitwidth of 4. (2^2 bits; can represent 16 values.)

A `bloq` of 3 has a bitwidth of 8. (2^3 bits; can represent 256 values.)

And so on.

See the bit arithmetic section for operations that use `bloq`s.


------------------------------------------------------------------------------
EACH                                                                  *++each*

Mold of fork between two types

A mold generator. Produces a discriminated fork between two types, defaulting
to `this`.

Source~
>
    ++  each
      |$  [this that]
      $%  [%| p=that]
          [%& p=this]
      ==
<

Examples~
>
    > ? *(each cord time)
      ?([%.y p=@t] [%.n p=@da])
    [%.y p='']
<
>
    > ? *(each * tape)
      ?([%.y p=*] [%.n p=""])
    [%.y p=0]
<


------------------------------------------------------------------------------
GATE                                                                  *++gate*

Function

A `core` with one arm, `$`--the empty name--which transforms a sample noun
into a product noun. If used dryly as a type, the subject must have a sample
type of `*`.

Source~
>
        ++  gate
          $-(* *)
<

Examples~
>
    > ? gate
      <1.ddq [* <46.hgz 1.pnw %140>]>
    <1.ddq [* <46.hgz 1.pnw %140>]>
<
>
    > (`gate`|=(a=* [a 'b']) 1)
    [1 98]
<
>
    > (`gate`|=(a=@ [a 'b']) 1)
    mint-nice
    -need.@
    -have.*
    nest-fail
    dojo: hoon expression failed
<

Discussion~

A `gate` is analogous to a function in other programming languages. We created
this new jargon because other constructs in Urbit are "functions" in the
mathematical sense. Any `gate` normalizes to an iron `gate`.

See also: `++lift`, `++cork`


------------------------------------------------------------------------------
LIST                                                                  *++list*

List

A mold generator. Generates a mold of a null-terminated list of a homogenous
type.

Source~
>
    ++  list
      |$  [item]
      $@(~ [i=item t=(list item)])
<

Examples~
>
    > *(list)
    ~
<
>
    > `(list @)`"abc"
    ~[97 98 99]
<
>
    > (snag 0 "abc")
    'a'
<
>
    > `(list @)`[1 2 'j' ~]
    ~[1 2 106]
<

Discussion~

See also: `++turn`, `++snag`


------------------------------------------------------------------------------
LONE                                                                  *++lone*

Face on mold

A mold generator. Puts face of `p` on the passed-in mold.

Source~
>
    ++  lone
      |$  [item]
      p=item
<

Examples~
>
    > ? *cord
    @t
    ''
<
>
    > ? *(lone cord)
      p=@t
    p=''
<
>
    > ? *(lone @)
      p=@
    p=0
<
>
    > ? *@
      @
    0
<


------------------------------------------------------------------------------
PAIR                                                                  *++pair*

Mold of pair of types

A mold generator. Produces a tuple of two of the types passed in.

Source~
>
    ++  pair
      |$  [head tail]
      [p=head q=tail]
<

Examples~
>
    > *(pair ? cord)
    [p=%.y q='']
<
>
    > *(pair tape @)
    [p="" q=0]
<


------------------------------------------------------------------------------
POLE                                                                  *++pole*

Faceless `list`

A mold generator. A `list` without the faces `i` and `t`.

Source~
>
    ++  pole
      |$  [item]
      $@(~ [item (pole item)])
<

Examples~
>
    > =/(a "asdf" ?>(?=(^ a) `(lest @tD)`a))
    [i='a' t=[i='s' t=[i='d' t=[i='f' t=~]]]]
<
>
    > `(pole char)`"asdf"
    ['a' ['s' ['d' ['f' ~]]]]
<


------------------------------------------------------------------------------
QUAL                                                                  *++qual*

Mold of 4-type tuple

A mold generator. Produces a tuple of four of the types passed in.

Source~
>
    ++  qual
      |$  [first second third fourth]
      [p=first q=second r=third s=fourth]
<

Examples~
>
    > *(qual date time tape cord)
    [p=[[a=%.y y=0] m=0 t=[d=0 h=0 m=0 s=0 f=~]] q=~2000.1.1 r="" s='']
<
>
    > *(qual (list @) @u @ud @ux)
    [p=~ q=0 r=0 s=0x0]
<


------------------------------------------------------------------------------
QUIP                                                                  *++quip*

Mold of pair of `list` and type

A mold generator. Produces a tuple of a `list` of `item` and the mold of
`state`.

Source~
>
    ++  quip
      |$  [item state]
      [(list item) state]
<

Examples~
>
    > *(quip @ _'hi')
    [~ 'hi']
<
>
    > `(quip @ @ux)`[[1 2 3 4 ~] 0x10]
    [~[1 2 3 4] 0x10]
<

Discussion~

A common pattern in Hoon code is to return a `list` of changes, along with a
new state. You'll often see `quip` used in Gall apps.


------------------------------------------------------------------------------
STEP                                                                  *++step*

Atom size or offset, in bloqs.

Source~
>
    ++  step
      _`@u`1
<

Examples~
>
    > `step`0
    0
<
>
    > `step`2
    2
<


------------------------------------------------------------------------------
TRAP                                                                  *++trap*

`Core` with one arm `$`

A trap is a `core` with one arm `$`.

Source~
>
    ++  trap
      |$  [product]
      _|?($:product)
<

Examples~
>
    > (*trap)
    <1?ruo 1.mhl [product=<1|xpg [* * *]> <46.hgz 1.pnw %140>]>
<
>
    > *(*trap)
    0
<
>
    > (|.(42))
    42
<


------------------------------------------------------------------------------
TREE                                                                  *++tree*

Tree mold generator

A mold generator. A `tree` can be empty, or contain a node of a type and
left/right sub `tree` of the same type. Pretty-printed with `{}`.

Source~
>
    ++  tree
      |$  [node]
      $@(~ [n=node l=(tree node) r=(tree node)])
<

Examples~
>
    > `(tree [@ tape])`[[1 "hi"] [[2 "bye"] ~ ~] ~]
    {[2 "bye"] [1 "hi"]}
<


------------------------------------------------------------------------------
TREL                                                                  *++trel*

Mold of three types

A mold generator. A mold of the tuple of the three types passed in.

Source~
>
    ++  trel
      |$  [first second third]
      [p=first q=second r=third]
<

Examples~
>
    > *(trel @ud @t @s)
    [p=0 q='' r=--0]
<
>
    > *(trel cord bloq tape)
    [p='' q=0 r=""]
<


------------------------------------------------------------------------------
UNIT                                                                  *++unit*

Maybe

A mold generator. A `unit` is either `~` or `[~ u=item]`, where `item` is the
type that was passed in.

Source~
>
    ++  unit
      |$  [item]
      $@(~ [~ u=item])
<

Examples~
>
    > ? *(unit time)
      u(@da)
    ~
<
>
    > =a |=  a=@
      ^-  (unit @)
      ?~  a  ~
      [~ a]
    > (a 2)
    [~ 2]
<

Discussion~

Using a `unit` allows you to specify something that may not be there.

See also: `++bind`



==============================================================================
 2a: Unit Logic                                                                         

------------------------------------------------------------------------------
BIFF                                                                  *++biff*

`Unit` as argument

Applies a function `b` that produces a `unit` to the unwrapped value of `unit`
`a` (`u.a`). If `a` is empty, `~` is produced.

Accepts~

`a` is a `unit`.

`b` is a function that accepts a `noun` and produces a `unit`.

Produces~

A `unit`.

Source~
>
    ++  biff
      |*  [a=(unit) b=$-(* (unit))]
      ?~  a  ~
      (b u.a)
<

Examples~
>
    > (biff (some 5) |=(a=@ (some (add a 2))))
    [~ u=7]
<
>
    > (biff ~ |=(a=@ (some (add a 2))))
    ~
<


------------------------------------------------------------------------------
BIND                                                                  *++bind*

Non-unit function to `unit`, producing `unit`

Applies a function `b` to the value (`u.a`) of a `unit` `a`, producing a
`unit`. Used when you want a function that does not accept or produce a `unit`
to both accept and produce a `unit`.

Accepts~

`a` is a `unit`.

`b` is a function.

Produces~

A `unit`.

Source~
>
    ++  bind
      |*  [a=(unit) b=gate]
      ?~  a  ~
      [~ u=(b u.a)]
<

Examples~
>
    > (bind ((unit @) [~ 97]) ,@t)
    [~ u='a']
<
>
    > =a |=(a=@ (add a 1))
    > (bind ((unit @) [~ 2]) a)
    [~ u=3]
<


------------------------------------------------------------------------------
BOND                                                                  *++bond*

Replace null

Replaces an empty `unit` `b` with the product of a called `trap` `a`. If the
`unit` is not empty, then the original `unit` is produced.

Accepts~

`a` is a `trap`.

`b` is a `unit`.

Produces~

Either the product of `a` or the value inside of `unit` `b`.

Source~
>
    ++  bond
      |*  a=(trap)
      |*  b=(unit)
      ?~  b  $:a
      u.b
<

Examples~
>
        > (bex 10)
        1.024
        > ((bond |.((bex 10))) ~)
        1.024
<
>
        > ((bond |.((bex 10))) (slaw %ud '123'))
        123
<


------------------------------------------------------------------------------
BOTH                                                                  *++both*

Group `unit` values into pair

Produces `~` if either `a` or `b` are empty. Otherwise, produces a `unit`
whose value is a cell of the values of two input `units` `a` and `b`.

Accepts~

`a` is a `unit`.

`b` is a `unit`.

Produces~

A `unit` of the two initial values.

Source~
>
    ++  both
      |*  [a=(unit) b=(unit)]
      ?~  a  ~
      ?~  b  ~
      [~ u=[u.a u.b]]
<

Examples~
>
    > (both (some 1) (some %b))
    [~ u=[1 %b]]
<
>
    > (both ~ (some %b))
    ~
<


------------------------------------------------------------------------------
CLAP                                                                  *++clap*

Combine two `units` with function

Applies a binary function `c`--which does not usually accept or produce a
`unit`-- to the values of two `units`, `a` and `b`, producing a `unit`.

If `a` is null, produces `b`. If `b` is null, produces `a`. Otherwise,
produces the produce of `c` in a `unit`.

Accepts~

`a` is a `unit`.

`b` is a `unit`.

`c` is a function that performs a binary operation.

Produces~

A `unit`.

Source~
>
    ++  clap
      |*  [a=(unit) b=(unit) c=_=>(~ |=(^ +<-))]
      ?~  a  b
      ?~  b  a
      [~ u=(c u.a u.b)]
<

Examples~
>
    > (clap ~ `'b' |=([a=@tD b=@tD] `tape`[a b ~]))
    [~ u='b']
<
>
    > (clap `'a' ~ |=([a=@tD b=@tD] `tape`[a b ~]))
    [~ u='a']
<
>
    > (clap `'a' `'b' |=([a=@tD b=@tD] `tape`[a b ~]))
    [~ u="ab"]
<


------------------------------------------------------------------------------
CLEF                                                                  *++clef*

Compose two `units` with function

Applies a binary function `c`--which does not usually accept `units`-- to the
values of two `units`, `a` and `b`, producing a `unit`.

If `a` or `b` are null, produces null. Otherwise, produces the produce of `c`.

Accepts~

`a` is a `unit`.

`b` is a `unit`.

`c` is a `gate` that takes a `cell` and produces a `unit`.

Produces~

A `unit`.

Source~
>
    ++  clef
      |*  [a=(unit) b=(unit) c=_=>(~ |=(^ `+<-))]
      ?~  a  ~
      ?~  b  ~
      (c u.a u.b)
<

Examples~
>
    > (clef ~ `'b' |=([a=@tD b=@tD] `(unit tape)`[~ [a b ~]]))
    ~
<
>
    > (clef `'a' ~ |=([a=@tD b=@tD] `(unit tape)`[~ [a b ~]]))
    ~
<
>
    > (clef `'a' `'b' |=([a=@tD b=@tD] `(unit tape)`[~ [a b ~]]))
    [~ "ab"]
<


------------------------------------------------------------------------------
DROP                                                                  *++drop*

`Unit` to list

Makes a `++list` of the unwrapped value (`u.a`) of a `unit` `a`.

Accepts~

`a` is a `unit`.

Produces~

A list.

Source~
>
    ++  drop
      |*  a=(unit)
      ?~  a  ~
      [i=u.a t=~]
<

Examples~
>
    > =a ((unit @) [~ 97])
    > (drop a)
    [i=97 t=~]
<
>
    > =a ((unit @) [~])
    > (drop a)
    ~
<


------------------------------------------------------------------------------
FALL                                                                  *++fall*

Give `unit` a default value

Produces a default value `b` for a `unit` `a` in cases where `a` is null.

Accepts~

`a` is a `unit`.

`b` is a `noun` that's used as the default value.

Produces~

Either a `noun` `b` or the unwrapped value of `unit` `a`.

Source~
>
    ++  fall
      |*  [a=(unit) b=*]
      ?~(a b u.a)
<

Examples~
>
    > (fall ~ 'a')
    'a'
    > (fall [~ u=0] 'a')
    0
<


------------------------------------------------------------------------------
FLIT                                                                  *++flit*

Make filter

Accepts gate `a` which produces a `?`. Applies `a` to `b`, producing `b`
wrapped in a `unit` if true, otherwise produces null.

`+flit` is a wet gate that takes `a` and produces a new wet gate that takes
`b`.

Accepts~

`a` is a `gate` which produces `?`, and is the sample of the outer wet gate.

`b` is any `noun`, and is the sample of the inner wet gate.

Produces~

`(unit [type])`, where `[type]` is the type of `b`.

Source~
>
    ++  flit
      |*  a=$-(* ?)
      |*  b=*
      ?.((a b) ~ [~ u=b])
<

Examples~
>
    > =f (flit |=(=@ud ?:(=(ud 1) %.y %.n)))
    > (f 1)
    [~ 1]
    > (f 2)
    ~
<


------------------------------------------------------------------------------
HUNT                                                                  *++hunt*

First of units

Apply binary gate `ord`, which produces a `?`, to units `a` and `b`. Produce
`a` if true and `b` if false. If `a` is null, produce `b`. If `b` is null,
produce `a`.

This allows selecting between two units by some rule.

Accepts~

`ord` is a `$-(^ ?)` - a binary gate that produces `?`.

`a` is a `unit`.

`b` is a `unit`.

Produces~

A `unit`.

Source~
>
    ++  hunt
      |*  [ord=$-(^ ?) a=(unit) b=(unit)]
      ^-  %-  unit
          $?  _?>(?=(^ a) u.a)
              _?>(?=(^ b) u.b)
          ==
      ?~  a  b
      ?~  b  a
      ?:((ord u.a u.b) a b)
<

Examples~
>
    > (hunt gte ~ `20)
    [~ 20]
<
>
    > (hunt gte `10 ~)
    [~ 10]
<
>
    > (hunt gte `10 `20)
    [~ 20]
<


------------------------------------------------------------------------------
LIFT                                                                  *++lift*

Curried bind

Accepts function `a` and produces a function that accepts `unit` `b` to which
it applies `a`. Used when you want a function that does not accept or produce
a `unit` to both accept and produce a `unit`.

Accepts~

`a` is a `mold`.

`b` is a `unit`.

Produces~

A `unit`.

Source~
>
    ++  lift
      |*  a=mold
      |*  b=(unit)
      (bind b a)
<

Examples~
>
    > ((lift dec) `(unit @)`~)
    ~
<
>
    > ((lift dec) `(unit @)`[~ 20])
    [~ 19]
<


------------------------------------------------------------------------------
MATE                                                                  *++mate*

Choose

Accepts two `units` `a` and `b` whose values are expected to be equivalent. If
either is empty, then the value of the other is produced. If neither are
empty, it asserts that both values are the same and produces that value. If
the assertion fails, `++mate` crashes with `'mate'` in the stack trace.

Accepts~

`a` is a `unit`.

`b` is a `unit`.

Produces~

A `unit` or crash.

Source~
>
    ++  mate
      |*  [a=(unit) b=(unit)]
      ?~  b  a
      ?~  a  b
      ?.(=(u.a u.b) ~>(%mean.'mate' !!) a)
<

Examples~
>
    > =a ((unit @) [~ 97])
    > =b ((unit @) [~ 97])
    > (mate a b)
    [~ 97]
<
>
    > =a ((unit @) [~ 97])
    > =b ((unit @) [~])
    > (mate a b)
    [~ 97]
<
>
    > =a ((unit @) [~ 97])
    > =b ((unit @) [~ 98])
    > (mate a b)
    ! 'mate'
    ! exit
<


------------------------------------------------------------------------------
NEED                                                                  *++need*

Unwrap `unit`

Retrieve the value from a `unit` and crash if the `unit` is null.

Accepts~

`a` is a `unit`.

Produces~

Either the unwrapped value of `a` (`u.a`), or crash.

Source~
>
    ++  need
      ~/  %need
      |*  a=(unit)
      ?~  a  ~>(%mean.'need' !!)
      u.a
<

Examples~
>
    > =a ((unit [@t @t]) [~ ['a' 'b']])
    > (need a)
    ['a' 'b']
<
>
    > =a ((unit @ud) [~ 17])
    > (need a)
    17
<
>
    > =a ((unit @) [~])
    > (need a)
    ! exit
<


------------------------------------------------------------------------------
SOME                                                                  *++some*

Wrap value in a `unit`

Takes any `noun` `a` and produces a `unit` with the value set to `a`.

Accepts~

`a` is a `noun`.

Produces~

A `unit`.

Source~
>
    ++  some
      |*  a=*
      [~ u=a]
<

Examples~
>
    > (some ['a' 'b'])
    [~ u=['a' 'b']]
<
>
    > (some &)
    [~ u=%.y]
<



==============================================================================
 2b: List Logic                                                                         

------------------------------------------------------------------------------
BAKE                                                                  *++bake*

Note: This function isn't specifically a list function but is included in
section 2b of the standard library so is documented here for completeness.

Convert wet gate `f` to a dry gate by specifying argument mold `a`.

`+bake` is a wet gate that takes a wet gate and produces a dry gate.

Accepts~

`f` is a `gate`.

`a` is a `mold`.

Produces~

A dry `gate` whose sample type is `a`.

Source~
>
    ++  bake
      |*  [f=gate a=mold]
      |=  arg=a
      (f arg)
<

Examples~
>
    > =wet-gate |*(a=* [a a])
    > (wet-gate 42)
    [42 42]
    > (wet-gate ['foo' 'bar'])
    [['foo' 'bar'] 'foo' 'bar']
    > =dry-gate (bake wet-gate @ud)
    > (dry-gate 42)
    [42 42]
    > (dry-gate ['foo' 'bar'])
    -need.@ud
    -have.[@t @t]
    nest-fail
<


------------------------------------------------------------------------------
FAND                                                                  *++fand*

All indices in `list`

Produces the indices of all occurrences of `nedl` in `hstk` as a `list` of
atoms.

Accepts~

`nedl` is a list.

`hstk` is a list.

Produces~

A `list`.

Source~
>
    ++  fand
      ~/  %fand
      |=  [nedl=(list) hstk=(list)]
      =|  i=@ud
      =|  fnd=(list @ud)
      |-  ^+  fnd
      =+  [n=nedl h=hstk]
      |-
      ?:  |(?=(~ n) ?=(~ h))
        (flop fnd)
      ?:  =(i.n i.h)
        ?~  t.n
          ^$(i +(i), hstk +.hstk, fnd [i fnd])
        $(n t.n, h t.h)
      ^$(i +(i), hstk +.hstk)
<

Examples~
>
    > (fand ~[3] ~[1 2 3])
    ~[2]
<
>
    > (fand ~[4] ~[1 2 3])
    ~
<
>
    > (fand ~['a'] "cbabab")
    ~[2 4]
<
>
    > (fand "ba" "cbabab")
    ~[1 3]
<


------------------------------------------------------------------------------
FIND                                                                  *++find*

First index in `list`

Produces the index of the first occurrence of `nedl` in `hstk` as the `unit`
of an atom.

Accepts~

`nedl` is a list.

`hstk` is a list.

Produces~

The `unit` of an atom.

Source~
>
    ++  find
      ~/  %find
      |=  [nedl=(list) hstk=(list)]
      =|  i=@ud
      |-   ^-  (unit @ud)
      =+  [n=nedl h=hstk]
      |-
      ?:  |(?=(~ n) ?=(~ h))
         ~
      ?:  =(i.n i.h)
        ?~  t.n
          `i
        $(n t.n, h t.h)
      ^$(i +(i), hstk +.hstk)
<

Examples~
>
    > (find [3]~ ~[1 2 3])
    [~ u=2]
<
>
    > (find [4]~ ~[1 2 3])
    ~
<
>
    > (find ['c']~ "cbabab")
    [~ u=0]
<
>
    > (find "ab" "cbabab")
    [~ u=2]
<
>
    > (find "bab" "cbabab")
    [~ u=1]
<


------------------------------------------------------------------------------
FLOP                                                                  *++flop*

Reverse

Produces the `list` `a` in reverse order.

Accepts~

`a` is a `list`.

Produces~

A `list`.

Source~
>
    ++  flop
      ~/  %flop
      |*  a=(list)
      =>  .(a (homo a))
      ^+  a
      =+  b=`_a`~
      |-
      ?~  a  b
      $(a t.a, b [i.a b])
<

Examples~
>
    > =a [1 2 3 ~]
    > (flop a)
    ~[3 2 1]
<
>
    > (flop (flop a))
    ~[1 2 3]
<


------------------------------------------------------------------------------
GULF                                                                  *++gulf*

List from range

Produces a `list` composed of each consecutive integer starting from `a` and
ending with `b`. `a` and `b` are themselves included.

Accepts~

`a` is an atom.

`b` is an atom.

Produces~

a `list`.

Source~
>
    ++  gulf
      |=  [a=@ b=@]
      ?>  (lte a b)
      |-  ^-  (list @)
      ?:(=(a +(b)) ~ [a $(a +(a))])
<

Examples~
>
    > (gulf 1 6)
    ~[1 2 3 4 5 6]
<
>
    > `(list @t)`(gulf 99 106)
    <|c d e f g h i j|>
<


------------------------------------------------------------------------------
HOMO                                                                  *++homo*

Homogenize

Produces a `list` whose type is a fork of all the contained types in the list
`a`. Used when you want to make all the types of the elements of a list the
same.

Accepts~

`a` is a `list`.

Produces~

a `list`.

Source~
>
    ++  homo
      |*  a=(list)
      ^+  =<  $
        |@  ++  $  ?:(*? ~ [i=(snag 0 a) t=$])
        --
      a
<

Examples~
>
    > lyst
    [i=1 t=[i=97 t=[i=2 t=[i=98 t=[i=[~ u=10] t=~]]]]]
    > (homo lyst)
    ~[1 97 2 98 [~ u=10]]
<
>
    > =a (limo [1 2 3 ~])
    > a
    [i=1 t=[i=2 t=[i=3 t=~]]]
    > (homo a)
    ~[1 2 3]
<


------------------------------------------------------------------------------
INTO                                                                  *++into*

Insert item at index

Accepts a `list` `a`, an atom `b`, and a noun `c`, producing the list of `a`
with the item `c` inserted at index `b`.

Accepts~

`a` is a list.

`b` is a atom.

`c` is a noun.

Produces~

the list of `a` with the item `c` inserted at index `b`.

Source~
>
    ++  into
      ~/  %into
      |*  [a=(list) b=@ c=*]
      ^+  a
      (weld (scag b a) [c (slag b a)])
<

Examples~
>
    > (into (limo ~[2 3 4]) 1 11)
    ~[2 11 3 4]
<


------------------------------------------------------------------------------
JOIN                                                                  *++join*

Constructs a new `list`, placing `sep` between every element of `lit`.

Accepts~

`sep` is a `noun`.

`lit` is a `list`.

Produces~

a `list`.

Source~
>
    ++  join
      |*  [sep=* lit=(list)]
      =.  sep  `_?>(?=(^ lit) i.lit)`sep
      ?~  lit  ~
      =|  out=(list _?>(?=(^ lit) i.lit))
      |-  ^+  out
      ?~  t.lit
        (flop [i.lit out])
      $(out [sep i.lit out], lit t.lit)
<

Examples~
>
    > (join ' ' "hoon")
    "h o o n"
<
>
    > (join 0 `(list @)`~[1 2 3])
    ~[1 0 2 0 3]
<


------------------------------------------------------------------------------
LENT                                                                  *++lent*

List length

Produces the length of any `list` `a` as an atom.

Accepts~

`a` is a `list`.

Produces~

an atom.

Source~
>
    ++  lent
      ~/  %lent
      |=  a=(list)
      ^-  @
      =+  b=0
      |-
      ?~  a  b
      $(a t.a, b +(b))
<

Examples~
>
    > (lent [1 2 3 4 ~]))
    4
<
>
    > (lent [1 'a' 2 'b' (some 10) ~])
    5
<


------------------------------------------------------------------------------
LEVY                                                                  *++levy*

Logical "and" on list

Computes the Boolean logical "and" on the results of gate `b` applied to each
individual element in `list` `a`.

Accepts~

`a` is a list.

`b` is a gate.

Produces~

A boolean.

Source~
>
    ++  levy
      ~/  %levy
      |*  [a=(list) b=$-(* ?)]
      |-  ^-  ?
      ?~  a  &
      ?.  (b i.a)  |
      $(a t.a)
<

Examples~
>
    > =a |=(a=@ (lte a 1))
    > (levy `(list @)`[0 1 2 1 ~] a)
    %.n
<
>
    > =a |=(a=@ (lte a 3))
    > (levy `(list @)`[0 1 2 1 ~] a)
    %.y
<


------------------------------------------------------------------------------
LIEN                                                                  *++lien*

Logical "or" on list

Computes the Boolean logical "or" on the results of applying `gate` `b` to
every element of `++list` `a`.

Accepts~

`a` is a list.

`b` is a gate.

Source~
>
    ++  lien
      ~/  %lien
      |*  [a=(list) b=$-(* ?)]
      |-  ^-  ?
      ?~  a  |
      ?:  (b i.a)  &
      $(a t.a)
<

Examples~
>
    > =a |=(a=@ (gte a 1))
    > (lien `(list @)`[0 1 2 1 ~] a)
    %.y
<
>
    > =a |=(a=@ (gte a 3))
    > (lien `(list @)`[0 1 2 1 ~]) a)
    %.n
<


------------------------------------------------------------------------------
LIMO                                                                  *++limo*

List Constructor

Turns a null-terminated tuple into a `list`.

Accepts~

`a` is a null-terminated tuple.

Produces~

A `++list`.

Source~
>
    ++  limo
      |*  a=*
      ^+  =<  $
        |@  ++  $  ?~(a ~ ?:(*? [i=-.a t=$] $(a +.a)))
        --
      a
<

Examples~
>
    > (limo [1 2 3 ~])
    [i=1 t=[i=2 t=[i=3 t=~]]]
<


------------------------------------------------------------------------------
MURN                                                                  *++murn*

Maybe transform

Passes each member of `list` `a` to gate `b`, which must produce a `unit`.
Produces a new list with all the results that do not produce `~`.

Accepts~

`a` is a list.

`b` is a gate that produces a unit.

Produces~

A list.

Source~
>
    ++  murn
      ~/  %murn
      |*  [a=(list) b=$-(* (unit))]
      =>  .(a (homo a))
      |-  ^-  (list _?>(?=(^ a) (need (b i.a))))
      ?~  a  ~
      =/  c  (b i.a)
      ?~  c  $(a t.a)
      [+.c $(a t.a)]
<

Examples~
>
    > =a |=(a=@ ?.((gte a 2) ~ (some (add a 10))))
    > (murn `(list @)`[0 1 2 3 ~] a)
    [i=12 t=[i=13 t=~]]
<


------------------------------------------------------------------------------
OUST                                                                  *++oust*

Remove

Removes elements from list `c` beginning at inclusive index `a`, removing `b`
number of elements.

Accepts~

`c` is a list.

Produces~

A `++list`.

Source~
>
    ++  oust
      ~/  %oust
      |*  [[a=@ b=@] c=(list)]
      (weld (scag +<-< c) (slag (add +<-< +<->) c))
<

Examples~
>
    > (oust [4 5] "good day, urbit!")
    "good urbit!"
<
>
    > (oust [2 2] `(list @)`[1 2 3 4 ~])
    ~[1 2]
<


------------------------------------------------------------------------------
REAP                                                                  *++reap*

Replicate

Replicate: produces a `list` containing `a` copies of `b`.

Accepts~

`a` is an atom.

`b` is a noun.

Produces~

A list.

Source~
>
    ++  reap
      ~/  %reap
      |*  [a=@ b=*]
      |-  ^-  (list _b)
      ?~  a  ~
      [b $(a (dec a))]
<

Examples~
>
    > (reap 20 %a)
    ~[%a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a %a]
<
>
    > (reap 5 ~s1)
    ~[~s1 ~s1 ~s1 ~s1 ~s1]
    > `@dr`(roll (reap 5 ~s1) add)
    ~s5
<


------------------------------------------------------------------------------
REAR                                                                  *++rear*

Last item of list

Produces the last item in list `a`, crashing if `a` is null.

Accepts~

`a` is a `list`.

Produces~

The type of the last element in `a`.

Source~
>
    ++  rear
      ~/  %rear
      |*  a=(list)
      ^-  _?>(?=(^ a) i.a)
      ?>  ?=(^ a)
      ?:  =(~ t.a)  i.a
      $(a t.a)
<

Examples~
>
    > (rear ~[1 2 3])
    3
<
>
    > (rear ~)
    dojo: hoon expression failed
<


------------------------------------------------------------------------------
REEL                                                                  *++reel*

Right fold

Right fold: moves right to left across a `list` `a`, recursively slamming a
binary gate `b` with an element from `a` and an accumulator, producing the
final value of the accumulator.

(To "slam" means to call a gate and give it a sample/samples. In this
instance, `a` is the list of samples that are given to the gate b.)

The initial value of the accumulator is the bunt of `b`'s second argument
(`+<+`). This can occasionally produce undesired behavior (see examples). If
you need more control over the initial value, try making use of `$_` and `|:`,
or perhaps `+spin` or `+spun`.

Accepts~

`a` is a list.

`b` is a binary gate.

Produces~

The accumulator, which is a noun.

Source~
>
    ++  reel
      ~/  %reel
      |*  [a=(list) b=_=>(~ |=([* *] +<+))]
      |-  ^+  ,.+<+.b
      ?~  a
        +<+.b
      (b i.a $(a t.a))
<

Examples~
>
    > (reel `(list @)`[1 2 3 4 5 ~] add)
    15
    
    > (reel `(list @)`[6 3 1 ~] sub)
    4
    
    > (reel `(list @)`[3 6 1 ~] sub)
    ! subtract-underflow
    ! exit
<

`+mul`'s default sample is 1, so calling `+reel` with `+mul` yields the
expected behavior:
>
    > *mul
    1
    
    > (reel `(list @)`~[1 2 3 4] mul)
    24
<

However, if you build a gate that uses `+mul` like so, the sample defaults to
0 since that is the bunt of `@`:
>
    > (reel `(list @)`~[1 2 3 4] |=([a=@ b=@] (mul a b)))
    0
<

We can fix this with `|:`:
>
    > (reel `(list @)`~[1 2 3 4] |:([a=1 b=1] (mul a b)))
    24
<

If you check the definition of `+mul`, you'll see that it also utilizes this
pattern.

We can check explicitly what sequence of operations `+reel` performs like
this:
>
    > =f |:  [l='e_l' r='e_r']
          ^-  @t
          :((cury cat 3) '(' l '*' r ')')
    > (reel "abcde" f)
    '(a*(b*(c*(d*(e*e_r)))))'
<


------------------------------------------------------------------------------
ROLL                                                                  *++roll*

Left fold

Left fold: moves left to right across a list `a`, recursively slamming a
binary gate `b` with an element from the `list` and an accumulator, producing
the final value of the accumulator.

(To "slam" means to call a gate and give it a sample/samples. In this
instance, `a` is the list of samples that are given to the gate b.)

The initial value of the accumulator is `b`'s second argument (`+<+`). This
can occasionally produce undesired behavior (see examples). If you need more
control over the initial value, try making use of `$_` and `|:`, or perhaps
`+spin` or `+spun`.

Accepts~

`a` is a list.

`b` is a binary gate.

Produces~

The accumulator, which is a noun.

Source~
>
    ++  roll
      ~/  %roll
      |*  [a=(list) b=_=>(~ |=([* *] +<+))]
      |-  ^+  ,.+<+.b
      ?~  a
        +<+.b
      $(a t.a, b b(+<+ (b i.a +<+.b)))
<

Examples~
>
    > (roll `(list @)`[1 2 3 4 5 ~] add)
    q=15
    
    > (roll `(list @)`[6 3 1 ~] sub)
    ! subtract-underflow
    ! exit
    
    > (roll `(list @)`[1 3 6 ~] sub)
    q=4
<

`+mul`'s default sample is 1, so calling `+roll` with `+mul` yields the
expected behavior:
>
    > *mul
    1
    
    > (roll `(list @)`~[1 2 3 4] mul)
    24
<

However, if you build a gate that uses `+mul` like so, the sample defaults to
0 since that is the bunt of `@`:
>
    > (roll `(list @)`~[1 2 3 4] |=([a=@ b=@] (mul a b)))
    0
<

We can fix this with `|:`:
>
    > (roll `(list @)`~[1 2 3 4] |:([a=1 b=1] (mul a b)))
    24
<

If you check the definition of `+mul`, you'll see that it also utilizes this
pattern.

We can check explicitly what sequence of operations `+roll` performs like
this:
>
    > =f |:  [l='e_l' r='e_r']
          ^-  @t
          :((cury cat 3) '(' l '*' r ')')
    > (roll "abcde" f)
    '(e*(d*(c*(b*(a*e_r)))))
<

This is in contrast to what one might expect:
>
    > =foldl
        |*  [l=(list) f=$-([* *] *)]
        ^-  f
        ?~  l  +<-.f
        %=  $
          +<-.f  (f +<-.f i.l)
          l      t.l
          ==
    > (foldl "abcde" f)
    '(((((e_l*a)*b)*c)*d)*e)'
<


------------------------------------------------------------------------------
SCAG                                                                  *++scag*

Prefix

Accepts an atom `a` and `list` `b`, producing the first `a` elements of the
front of the list.

Accepts~

`a` is an atom.

`b` is a list.

Produces~

A list of the same type as `b`.

Source~
>
    ++  scag
      ~/  %scag
      |*  [a=@ b=(list)]
      |-  ^+  b
      ?:  |(?=(~ b) =(0 a))  ~
      [i.b $(b t.b, a (dec a))]
<

Examples~
>
    > (scag 2 `(list @)`[1 2 3 4 ~])
    [i=1 t=~[2]]
<
>
    > (scag 10 `(list @)`[1 2 3 4 ~])
    [i=1 t=~[2 3 4]]
<


------------------------------------------------------------------------------
SKID                                                                  *++skid*

Separate

Separates a `list` `a` into two lists - Those elements of `a` who produce true
when slammed to gate `b` and those who produce `%.n`.

(To "slam" means to call a gate and give it a sample/samples. In this
instance, `a` is the list of samples that are given to the gate `b`.)

Accepts~

`a` is a list.

`b` is a gate that accepts one argument and produces a flag.

Produces~

A cell of two lists.

Source~
>
    ++  skid
      ~/  %skid
      |*  [a=(list) b=$-(* ?)]
      |-  ^+  [p=a q=a]
      ?~  a  [~ ~]
      =+  c=$(a t.a)
      ?:((b i.a) [[i.a p.c] q.c] [p.c [i.a q.c]])
<

Examples~
>
    > =a |=(a=@ (gth a 1))
    > (skid `(list @)`[0 1 2 3 ~] a)
    [p=[i=2 t=~[3]] q=[i=0 t=~[1]]]
<


------------------------------------------------------------------------------
SKIM                                                                  *++skim*

Filter

Cycles through the members of a list `a`, passing them to a gate `b` and
producing a list of all of the members that produce `%.y`. Inverse of `skip`.

Accepts~

`a` is a list.

`b` is a gate that accepts one argument and produces a boolean.

Produces~

A list.

Source~
>
    ++  skim
      ~/  %skim
      |*  [a=(list) b=$-(* ?)]
      |-
      ^+  a
      ?~  a  ~
      ?:((b i.a) [i.a $(a t.a)] $(a t.a))
<

Examples~
>
    > =a |=(a=@ (gth a 1))
    > (skim `(list @)`[0 1 2 3 ~] a)
    [i=2 t=~[3]]
<


------------------------------------------------------------------------------
SKIP                                                                  *++skip*

Except

Cycles through the members of `list` `a`, passing them to a gate `b`. Produces
a list of all of the members that produce `%.n`. Inverse of `skim`.

Accepts~

`a` is a list.

`b` is a gate that accepts one argument and produces a flag.

Produces~

A list of the same type as `a`.

Source~
>
    ++  skip
      ~/  %skip
      |*  [a=(list) b=$-(* ?)]
      |-
      ^+  a
      ?~  a  ~
      ?:((b i.a) $(a t.a) [i.a $(a t.a)])
<

Examples~
>
    > =a |=(a=@ (gth a 1))
    > (skip `(l)`[0 1 2 3 ~]) a)
    [i=0 t=[i=1 t=~]]
<


------------------------------------------------------------------------------
SLAG                                                                  *++slag*

Suffix

Accepts an atom `a` and list `b`, producing the remaining elements from `b`
starting at `a`.

Accepts~

`a` is an atom.

`b` is a list.

Produces~

A list of the same type as `b`.

Source~
>
    ++  slag
      ~/  %slag
      |*  [a=@ b=(list)]
      |-  ^+  b
      ?:  =(0 a)  b
      ?~  b  ~
      $(b t.b, a (dec a))
<

Examples~
>
    > (slag 2 (limo [1 2 3 4 ~]))
    [i=3 t=[i=4 t=~]]
    > (slag 1 (limo [1 2 3 4 ~]))
    [i=2 t=[i=3 t=[i=4 t=~]]]
<


------------------------------------------------------------------------------
SNAG                                                                  *++snag*

Index

Accepts an atom `a` and a `++list` `b`, producing the element at the index of
`a`and failing if the list is null. Lists are 0-indexed.

Accepts~

`a` is an atom.

`b` is a list.

Produces~

Produces an element of `b`, or crashes if no element exists at that index.

Source~
>
    ++  snag
      ~/  %snag
      |*  [a=@ b=(list)]
      |-  ^+  ?>(?=(^ b) i.b)
      ?~  b
        ~_  leaf+"snag-fail"
        !!
      ?:  =(0 a)  i.b
      $(b t.b, a (dec a))
<

Examples~
>
    > (snag 2 "asdf")
    'd'
<
>
    > (snag 0 `(list @ud)`~[1 2 3 4])
    1
<


------------------------------------------------------------------------------
SNAP                                                                  *++snap*

Replace item at index

Accepts a `list` `a`, an atom `b`, and a noun `c`, producing the list of `a`
with the item at index `b` replaced with `c`.

Accepts~

`a` is a list.

`b` is a atom.

`c` is a noun.

Produces~

the list of `a` with the item at index `b` replaced with `c`.

Source~
>
    ++  snap
      ~/  %snap
      |*  [a=(list) b=@ c=*]
      ^+  a
      (weld (scag b a) [c (slag +(b) a)])
<

Examples~
>
    > (snap (limo ~[2 3 4]) 1 11)
    ~[2 11 4]
<


------------------------------------------------------------------------------
SNIP                                                                  *++snip*

Drop tail off list

Removes the last element from list `a`.

Accepts~

`a` is a `list`.

Produces~

A `list`.

Source~
>
    ++  snip
      ~/  %snip
      |*  a=(list)
      ^+  a
      ?~  a  ~
      ?:  =(~ t.a)  ~
      [i.a $(a t.a)]
<

Examples~
>
    > `tape`(snip "foobar")
    "fooba"
<
>
    > (snip ~)
    ~
<


------------------------------------------------------------------------------
SNOC                                                                  *++snoc*

Append

Accepts a `++list` `a` and a noun `b`, producing the list of `b` appended to
`a`.

Accepts~

`a` is a list.

`b` is a noun.

Produces~

Produces a list of `b` appended to `a`.

Source~
>
    ++  snoc
      |*  [a=(list) b=*]
      (weld a ^+(a [b]~))
<

Examples~
>
    > `tape`(zing (snoc `(list tape)`~["a" "bc" "def"] "g"))
    "abcdefg"
    > (snoc `(list @ud)`~[1 2 3] 4)
    ~[1 2 3 4]
<


------------------------------------------------------------------------------
SORT                                                                  *++sort*

Quicksort

Quicksort: accepts a `++list` `a` and a gate `b` which accepts two nouns and
produces a flag. `++sort` then produces a list of the elements of `a`, sorted
according to `b`.

Accepts~

`a` is a list.

`b` is a gate that accepts two nouns and produces a boolean.

Produces~

A list

Source~
>
    ++  sort  !.
      ~/  %sort
      |*  [a=(list) b=$-([* *] ?)]
      =>  .(a ^.(homo a))
      |-  ^+  a
      ?~  a  ~
      =+  s=(skid t.a |:(c=i.a (b c i.a)))
      %+  weld
        $(a p.s)
      ^+  t.a
      [i.a $(a q.s)]
<

Examples~
>
    > (sort `(list @)`[0 1 2 3 ~] gth)
    ~[3 2 1 0]
<


------------------------------------------------------------------------------
SPIN {% #SPIN %}                                                                  *++spin {% #spin %}*

Gate to list, with state

Accepts a `++list` `a`, some state `b`, and a gate `c`. `c` is called with a
tuple -- the head is an element of `a` and the tail is the state `b`, and
should produce a tuple of the transformed element and the (potentially
modified) state `b`. Produces a pair where the first element is a list of the
transformed elements of `a`, and the second element is the final value of `b`.

Accepts~

`a` is a `++list`.

`b` is a noun.

`c` is a gate.

Produces~

A pair of a list and a noun.

Source~
>
    ++  spin
      ~/  %spin
      |*  [a=(list) b=* c=_|=(^ [** +<+])]
      =>  .(c `$-([_?>(?=(^ a) i.a) _b] [_-:(c) _b])`c)
      =/  acc=(list _-:(c))  ~
      |-  ^-  (pair _acc _b)
      ?~  a
        [(flop acc) b]
      =^  res  b  (c i.a b)
      $(acc [res acc], a t.a)
<

Examples~
>
    > %^  spin  (limo ~[4 5 6])     ::  Trivial example -- does nothing with the state
        0
      |=([n=@ a=@] [n a])
    [p=~[4 5 6] q=0]
<
>
    > %^  spin  (limo ~[4 5 6])     ::  Form a pair with `p` as the index and `q` as the list element
        0
      |=([n=@ a=@] [`(pair)`[a n] +(a)])
    [p=~[[p=0 q=4] [p=1 q=5] [p=2 q=6]] q=3]
<
>
    > %^  spin  (reap 10 0)     :: Create 10 random numbers less than `10`
        ~(. og eny)
      |=([n=@ rng=_og] (rads:rng 10))
    [p=~[7 8 6 0 1 5 4 7 9 3] q=<4.rvi {a/@uvJ <51.qyl 129.pdd 41.mac 1.ane $141>}>]
<

Discussion~

`(~(rads og eny) 2)` creates a random number less than `2`, seeding the RNG
with entropy (`eny`). The head of the product is the random number, the tail
is the continuation of the RNG.


------------------------------------------------------------------------------
SPUN {% #SPUN %}                                                                  *++spun {% #spun %}*

Gate to list, with state

Accepts a `list` `a` and a gate `b`. `c` is internal state, initially derived
by bunting the tail of the sample of gate `b`, instead of being passed in
explicitly as in `++spin`. Produces a list with the gate applied to each
element of the original list. `b` is called with a tuple -- the head is an
element of `a` and the tail is the state `c`, and should produce a tuple of
the transformed element and the (potentially modified) state `c`.

Accepts~

`a` is a `++list`.

`b` is a gate.

Produces~

A list.

Source~
>
    ++  spun
      ~/  %spun
      |*  [a=(list) b=_|=(^ [** +<+])]
      p:(spin a +<+.b b)
<

Examples~
>
    > %+  spun  (limo ~[4 5 6])            ::  `p` as the index and `q` as the list element
      |=([n=@ a=@] [`(pair)`[a n] +(a)])
    ~[[p=0 q=4] [p=1 q=5] [p=2 q=6]]
<
>
    > =l (limo ~[7 8 9])
    > %+  spun  (limo ~[4 5 6])            ::  joins two lists into a list of pairs
      |=([n=@ a=@] [`(pair)`[(snag a l) n] +(a)])
    ~[[p=7 q=4] [p=8 q=5] [p=9 q=6]]
<


------------------------------------------------------------------------------
SWAG                                                                  *++swag*

Infix

Similar to `substr` in Javascript: extracts a string infix, beginning at
inclusive index `a`, producing `b` number of characters.

Accepts~

`a` is an atom.

`b` is an atom.

`c` is a list.

Produces~

A list of the same type as `c`.

Source~
>
    ++  swag
      |*  [[a=@ b=@] c=(list)]
      (scag +<-> (slag +<-< c))
<

Examples~
>
    > (swag [2 5] "roly poly")
    "ly po"
<
>
    > (swag [2 2] (limo [1 2 3 4 ~]))
    [i=3 t=[i=4 t=~]]
<


------------------------------------------------------------------------------
TURN                                                                  *++turn*

Gate to list

Accepts a `++list` `a` and a gate `b`. Produces a list with the gate applied
to each element of the original list.

Accepts~

`a` is a list.

`b` is a gate.

Produces~

A list.

Source~
>
    ++  turn
      ~/  %turn
      |*  [a=(list) b=gate]
      =>  .(a (homo a))
      ^-  (list _?>(?=(^ a) (b i.a)))
      |-
      ?~  a  ~
      [i=(b i.a) t=$(a t.a)]
<

Examples~
>
    > (turn (limo [104 111 111 110 ~]) @t)
    <|h o o n|>
<
>
    > =a |=(a=@ (add a 4))
    > (turn (limo [1 2 3 4 ~]) a)
    ~[5 6 7 8]
<

Discussion~

`turn` is Hoon's version of 'map' in Haskell.


------------------------------------------------------------------------------
WELD                                                                  *++weld*

Concatenate

Concatenate two `++list`s `a` and `b`.

Accepts~

`a` and `b` are lists.

Source~
>
    ++  weld
      ~/  %weld
      |*  [a=(list) b=(list)]
      =>  .(a ^.(homo a), b ^.(homo b))
      |-  ^+  b
      ?~  a  b
      [i.a $(a t.a)]
<

Examples~
>
    > (weld "urb" "it")
    "urbit"
<
>
    > (weld (limo [1 2 ~]) (limo [3 4 ~]))
    ~[1 2 3 4]
<


------------------------------------------------------------------------------
WELP                                                                  *++welp*

Perfect weld

Concatenate two `++list`s `a` and `b` without losing their type information to
homogenization.

Accepts~

`a` is a list.

`b` is a list.

Produces~

A list.

Source~
>
    ++  welp
      ~/  %welp
      =|  [* *]
      |@
      ++  $
        ?~  +<-
          +<-(. +<+)
        +<-(+ $(+<- +<->))
      --
<

Examples~
>
    > (welp "foo" "bar")
    "foobar"
<
>
    > (welp ~[60 61 62] ~[%a %b %c])
    [60 61 62 %a %b %c ~]
    
    > ? (welp ~[60 61 62] ~[%a %b %c])
      [@ud @ud @ud %a %b %c %~]
    [60 61 62 %a %b %c ~]
<
>
    > (welp [sa+1 so+2 ~] si=3)
    [[%sa 1] [%so 2] si=3]
<


------------------------------------------------------------------------------
ZING                                                                  *++zing*

Turns a `++list` of lists into a single list by promoting the elements of each
sublist into the higher.

Accepts~

A list of lists.

Produces~

A list.

Source~
>
    ++  zing
      ~/  %zing
      =|  *
      |@
      ++  $
        ?~  +<
          +<
        (welp +<- $(+< +<+))
      --
<

Examples~
>
    > (zing (limo [(limo ['a' 'b' 'c' ~]) (limo ['e' 'f' 'g' ~]) (limo ['h' 'i' 'j' ~]) ~]))
    ~['a' 'b' 'c' 'e' 'f' 'g' 'h' 'i' 'j']
<
>
    > (zing (limo [(limo [1 'a' 2 'b' ~]) (limo [3 'c' 4 'd' ~]) ~]))
    ~[1 97 2 98 3 99 4 100]
<



==============================================================================
 2c: Bit Arithmetic                                                                         

------------------------------------------------------------------------------
BEX                                                                  *++bex*

Binary exponent

Computes the result of `2^a`, where `a` is a block size (see $bloq), producing
an atom.

Accepts~

`a` is an `bloq`.

Produces~

An atom.

Source~
>
    ++  bex
      ~/  %bex
      |=  a=bloq
      ^-  @
      ?:  =(0 a)  1
      (mul 2 $(a (dec a)))
<

Examples~
>
    > (bex 4)
    16
<
>
    > (bex (add 19 1))
    1.048.576
<
>
    > (bex 0)
    1
<


------------------------------------------------------------------------------
CAN                                                                  *++can*

Assemble

Produces an atom from a list `b` of length-value pairs `p` and `q`, where `p`
is the length in blocks of size `a`, and `q` is an atomic value.

Accepts~

`a` is a block size (see `$bloq`).

`b` is a `list` of length-value pairs, `p` and `q`:

- `p` is a step.
- `q` is a `@`.


Produces~

An atom.

Source~
>
    ++  can
      ~/  %can
      |=  [a=bloq b=(list [p=step q=@])]
      ^-  @
      ?~  b  0
      (add (end [a p.i.b] q.i.b) (lsh [a p.i.b] $(b t.b)))
<

Examples~
>
    > `@ub`21    ::  @ub is the binary aura
    0b1.0101
<
>
    > `@ub`(can 3 ~[[1 21]])
    0b1.0101
<
>
    > `@ub`(can 3 ~[[1 1]])
    0b1
<
>
    > `@ub`(can 0 ~[[1 255]])
    0b1
<
>
    > `@ux`(can 3 [3 0xc1] [1 0xa] ~)    ::  @ux is the hexadecimal aura
    0xa00.00c1
<
>
    > `@ux`(can 3 [3 0xc1] [1 0xa] [1 0x23] ~)
    0x23.0a00.00c1
<
>
    > `@ux`(can 4 [3 0xc1] [1 0xa] [1 0x23] ~)
    0x23.000a.0000.0000.00c1
<
>
    > `@ux`(can 3 ~[[1 'a'] [2 'bc']])
    0x63.6261
<


------------------------------------------------------------------------------
CAT                                                                  *++cat*

Concatenate

Concatenates two atoms, `b` and `c`, according to block size `a`, producing an
atom.

Accepts~

`a` is a block size (see `$bloq`).

`b` is an atom.

`c` is an atom.

Produces~

An atom.

Source~
>
    ++  cat
      ~/  %cat
      |=  [a=bloq b=@ c=@]
      (add (lsh [a (met a b)] c) b)
<

Examples~
>
    > `@ub`(cat 3 1 0)    ::  @ub is the binary aura
    0b1
    > `@ub`(cat 0 1 1)
    0b11
    > `@ub`(cat 0 2 1)
    0b110
    > `@ub`(cat 2 1 1)
    0b1.0001
<
>
    > `@ub`256
    0b1.0000.0000
    > `@ub`255
    0b1111.1111
    > `@ub`(cat 3 256 255)
    0b1111.1111.0000.0001.0000.0000
    > `@ub`(cat 2 256 255)
    0b1111.1111.0001.0000.0000
    > (cat 3 256 255)
    16.711.936
    > (cat 2 256 255)
    1.044.736
<


------------------------------------------------------------------------------
CUT                                                                  *++cut*

Slice

Slices `c` blocks of size `a` that are positioned `b` blocks from the end of
`d`. That slice is produced as an atom.

Accepts~

`a` is a block size (see `$bloq`).

`[b c]` where:

- `b` is a step.
- `c` is a step.


`d` is an atom.

Produces~

An atom.

Source~
>
    ++  cut
      ~/  %cut
      |=  [a=bloq [b=step c=step] d=@]
      (end [a c] (rsh [a b] d))
<

Examples~
>
    > (cut 0 [1 1] 2)
    1
    > (cut 0 [2 1] 4)
    1
<
>
    > `@t`(cut 3 [0 3] 'abcdefgh')           ::  @t is the cord aura
    'abc'
    > `@t`(cut 3 [1 3] 'abcdefgh')
    'bcd'
<
>
    > `@ub`(cut 0 [0 3] 0b1111.0000.1101)    ::  @ub is the binary aura
    0b101
    > `@ub`(cut 0 [0 6] 0b1111.0000.1101)
    0b1101
    > `@ub`(cut 0 [4 6] 0b1111.0000.1101)
    0b11.0000
    > `@ub`(cut 0 [3 6] 0b1111.0000.1101)
    0b10.0001
<


------------------------------------------------------------------------------
END                                                                  *++end*

Tail

Produces an atom by taking the last `step` blocks of size `bloq` from `b`.

Accepts~

`a` is an atom slice specifier (see `$bite`), which is a block size (see
`$bloq`) with optional block count.

`b` is an atom.

Produces~

An atom.

Source~
>
    ++  end
      ~/  %end
      |=  [a=bite b=@]
      =/  [=bloq =step]  ?^(a a [a *step])
      (mod b (bex (mul (bex bloq) step)))
<

Examples~
>
    > (end [2 2] 255)
    255
    > (end [3 1] 255)
    255
    > (end 3 255)
    255
    > (end 3 256)
    0
<
>
    > `@ub`12                  ::  @ub is the binary aura
    0b1100
    > `@ub`(end [0 3] 12)
    0b100
    > (end [0 3] 12)
    4
    > `@ub`(end [1 3] 12)
    0b1100
    > (end [1 3] 12)
    12
<
>
    > `@ux`'abc'               ::  @ux is the hexademical aura
    0x63.6261
    > `@ux`(end [3 2] 'abc')
    0x6261
    > `@t`(end [3 2] 'abc')    ::  @t is the cord aura
    'ab'
<


------------------------------------------------------------------------------
FIL                                                                  *++fil*

Fill bloqstream

Produces an atom by repeating `c` for `b` blocks of size `a`.

Accepts~

`a` is a block size (see `$bloq`).

`b` is a step.

`c` is an atom.

Produces~

An atom.

Source~
>
    ++  fil
      ~/  %fil
      |=  [a=bloq b=step c=@]
      =|  n=@ud
      =.  c  (end a c)
      =/  d  c
      |-  ^-  @
      ?:  =(n b)
        (rsh a d)
      $(d (add c (lsh a d)), n +(n))
<

Examples~
>
    > `@t`(fil 3 5 %a)                                ::  @t is the cord (string) aura
    'aaaaa'
<
>
    > `@t`(fil 5 10 %ceeb)
    'ceebceebceebceebceebceebceebceebceebceeb'
<
>
    > `@t`(fil 4 10 'eced')
    'ecececececececececec'
<
>
    > `@tas`(fil 4 10 %bf)                            ::  @tas is the term aura
    %bfbfbfbfbfbfbfbfbfbf
<
>
    > `@ub`(fil 2 6 1)                                ::  @ub is the binary aura
    0b1.0001.0001.0001.0001.0001
<


------------------------------------------------------------------------------
LSH                                                                  *++lsh*

Left-shift

Produces an atom by left-shifting `b` by `step` blocks of size `bloq`.

Accepts~

`a` is an atom slice specifier (see `$bite`), which is a block size (see
`$bloq`) with optional block count.

`b` is an atom.

Produces~

An atom.

Source~
>
    ++  lsh
      ~/  %lsh
      |=  [a=bite b=@]
      =/  [=bloq =step]  ?^(a a [a *step])
      (mul b (bex (mul (bex bloq) step)))
<

Examples~
>
    > `@ub`1                 ::  @ub is the binary aura
    0b1
    > `@ub`(lsh [0 1] 1)
    0b10
    > (lsh [0 1] 1)
    2
    > (lsh 0 1)
    2
<
>
    > `@ub`255
    0b1111.1111
    > `@ub`(lsh [3 1] 255)
    0b1111.1111.0000.0000
    > (lsh [3 1] 255)
    65.280
<


------------------------------------------------------------------------------
MET                                                                  *++met*

Measure

Computes the number of blocks of size `a` in `b`, producing an atom.

Accepts~

`a` is a block size (see `$bloq`).

`b` is an atom.

Source~
>
    ++  met
      ~/  %met
      |=  [a=bloq b=@]
      ^-  @
      =+  c=0
      |-
      ?:  =(0 b)  c
      $(b (rsh a b), c +(c))
<

Examples~
>
    > (met 0 1)
    1
    > (met 0 2)
    2
<
>
    > (met 3 255)
    1
    > (met 3 256)
    2
<
>
    > (met 3 'abcde')
    5
<


------------------------------------------------------------------------------
RAP                                                                  *++rap*

Assemble non-zero

Concatenates a list of atoms `b` using block size `a`, producing an atom.

Accepts~

`a` is a block size (see `++bloq`).

`b` is a `list` of atoms.

Produces~

An atom.

Source~
>
    ++  rap
      ~/  %rap
      |=  [a=bloq b=(list @)]
      ^-  @
      ?~  b  0
      (cat a i.b $(b t.b))
<

Examples~
>
    > `@ub`(rap 2 [1 2 3 4 ~])                   ::  @ub is the binary aura
    0b100.0011.0010.0001
    > `@ub`(rap 1 [1 2 3 4 ~])
    0b1.0011.1001
<
>
    > (rap 0 [0 0 0 ~])
    0
    > (rap 0 [1 0 1 ~])
    3
<
>
    > `@ub`3
    0b11
    > (rap 0 [0 1 0 0 1 2 ~])
    11
    > (rap 0 [1 1 2 ~])
    11
    > `@ub`11
    0b1011
<

Discussion~

Any element of the value `0` is not included in concatenation.


------------------------------------------------------------------------------
REP                                                                  *++rep*

Assemble single

Produces an atom by assembling a list of atoms `b` using block size `a`.

Accepts~

`a` is an atom slice specifier (see `$bite`), which is a block size (see
`$bloq`) with optional block count.

`b` is a list of atoms.

Produces~

An atom.

Source~
>
    ++  rep
      ~/  %rep
      |=  [a=bite b=(list @)]
      =/  [=bloq =step]  ?^(a a [a *step])
      =|  i=@ud
      |-  ^-  @
      ?~  b   0
      %+  add  $(i +(i), b t.b)
      (lsh [bloq (mul step i)] (end [bloq step] i.b))
<

Examples~
>
    > `@ub`(rep 2 [1 2 3 4 ~])                   ::  @ub is the binary aura
    0b100.0011.0010.0001
<
>
    > (rep 0 [0 0 1 ~])
    4
    > (rep 0 [0 0 0 1 ~])
    8
<
>
    > `@ub`(rep 0 [0 0 0 1 ~])
    0b1000
    > `@ub`8
    0b1000
<
>
    > `@ub`(rep 0 [1 0 1 0 ~])
    0b101
    > `@ub`(rep 0 [1 2 3 4 ~])
    0b101
<
>
    > (rep 0 [0 1 0 1 ~])
    10
    > (rep 0 [1 0 1 0 1 ~])
    21
    > `@ub`21
    0b10.1010
<
>
    > `@ub`(rep 3 [12 166 8 34 ~])
    0b10.0010.0000.1000.1010.0110.0000.1100
<
>
    > `*`"abcd"
    [97 98 99 100 0]
    > `@t`(rep 3 "abcd")                         :: @t is the text aura
    'abcd'
<


------------------------------------------------------------------------------
REV                                                                  *++rev*

Reverses block order, accounting for leading zeroes.

Produces an atom from the bits of `dat` in reverse order according to a block
size `boz` and a size `len`.

If the total size is less than the length of `dat`, then only the first bits
of `dat` up to the total size will be taken and reversed. If the total size is
longer, trailing zeroes will be added.

Accepts~

`boz` is a block size with optional block count (see `$bloq`).

`len` is a `@ud` of the number of blocks of size `boz` to be reversed.

`dat` is an atom.

Produces~

An atom.

Source~
>
    ++  rev
      ~/  %rev
      |=  [boz=bloq len=@ud dat=@]
      ^-  @
      =.  dat  (end [boz len] dat)
      %+  lsh
        [boz (sub len (met boz dat))]
      (swp boz dat)
<

Examples~
>
    > =a 0b1111.0000.1111.1010.0011
    > `@ub`(rev 0 20 a)
    0b1100.0101.1111.0000.1111
    > `@ub`(rev 0 12 a)
    0b1100.0101.1111
    > `@ub`(rev 2 5 a)
    0b11.1010.1111.0000.1111
    > `@ub`(rev 2 4 a)
    0b11.1010.1111.0000
    > `@ub`(rev 2 6 a)
    0b11.1010.1111.0000.1111.0000
<
>
    > (rev 1 10 1.000)
    179.200
    > (rev 2 5 1.000)
    582.400
    > (rev 1 5 1.000)
    175
<


------------------------------------------------------------------------------
RIP                                                                  *++rip*

Disassemble

Produces a list of atoms from the bits of `b` using block size `a`.

Accepts~

`a` is an atom slice specifier (see `$bite`), which is a block size (see
`$bloq`) with optional block count.

`b` is an atom.

Produces~

A list of atoms.

Source~
>
    ++  rip
      ~/  %rip
      |=  [a=bite b=@]
      ^-  (list @)
      ?:  =(0 b)  ~
      [(end a b) $(b (rsh a b))]
<

Examples~
>
    > `@ub`155                      ::  @ub is the binary aura
    0b1001.1011
    > (rip 0 155)
    ~[1 1 0 1 1 0 0 1]
    > (rip 2 155)
    ~[11 9]
<
>
    > (rip 0 11)
    ~[1 1 0 1]
    > (rip 1 155)
    ~[3 2 1 2]
<
>
    > `@ub`256
    0b1.0000.0000
    > (rip 0 256)
    ~[0 0 0 0 0 0 0 0 1]
    > (rip 2 256)
    ~[0 0 1]
    > (rip 3 256)
    ~[0 1]
<
>
    > `tape`(rip 3 'abcd')
    "abcd"
<


------------------------------------------------------------------------------
RSH                                                                  *++rsh*

Right-shift

Right-shifts `b` by `step` blocks of size `bloq`, producing an atom.

Accepts~

`a` is an atom slice specifier (see `$bite`), which is a block size (see
`$bloq`) with optional block count.

`b` is an atom.

Produces~

An atom.

Source~
>
    ++  rsh
      ~/  %rsh
      |=  [a=bite b=@]
      =/  [=bloq =step]  ?^(a a [a *step])
      (div b (bex (mul (bex bloq) step)))
<

Examples~
>
    > `@ub`145                       ::  @ub is the binary aura
    0b1001.0001
    > `@ub`(rsh [1 1] 145)
    0b10.0100
    > (rsh [1 1] 145)
    36
    > (rsh 1 145)
    36
    > `@ub`(rsh [2 1] 145)
    0b1001
    > (rsh [2 1] 145)
    9
<
>
    > `@ub`10
    0b1010
    > `@ub`(rsh [0 1] 10)
    0b101
    > (rsh [0 1] 10)
    5
<
>
    > `@ux`'abc'
    0x63.6261
    > `@t`(rsh [3 1] 'abc')
    'bc'
    > `@ux`(rsh [3 1] 'abc')
    0x6362
<


------------------------------------------------------------------------------
RUN                                                                  *++run*

`++turn` into atom.

Disassembles atom `b` into slices specified by `a`, applies `c` to each slice,
and reassembles the results back into an atom.

Accepts~

`a` is an atom slice specifier (see `$bite`), which is a block size (see
`$bloq`) with optional block count.

`b` is an atom.

`c` is a gate that accepts an atom and produces an atom.

Produces~

An atom.

Source~
>
    ++  run
      ~/  %run
      |=  [a=bite b=@ c=$-(@ @)]
      (rep a (turn (rip a b) c))
<

Examples~
>
        > `@ux`65.535                     :: @ux is the hexadecimal aura
        0xffff
        > `@ux`(run 2 65.535 dec)         :: dec is the decrement gate
        0xeeee
<


------------------------------------------------------------------------------
RUT                                                                  *++rut*

`++turn` into list.

Disassembles atom `b` into slices specified by `a`, applies `c` to each slice,
and assembles the results back into a.

Accepts~

`a` is an atom slice specifier (see `$bite`), which is a block size (see
`$bloq`) with optional block count.

`b` is an atom.

`c` is a gate that accepts an atom.

Produces~

A list.

Source~
>
    ++  rut
      ~/  %rut
      |*  [a=bite b=@ c=$-(@ *)]
      (turn (rip a b) c)
<

Examples~
>
    > `@ux`65.535                             :: @ux is the hexadecimal aura
    0xffff
    > `(list @ux)`(rut 2 65.535 dec)          :: dec is the decrement gate
    ~[0xe 0xe 0xe 0xe]
<


------------------------------------------------------------------------------
SEW                                                                  *++sew*

Stitch one atom into another

Replace `c` blocks of size `a` at offset `b` of atom `e` with `c` blocks of
size `a` from atom `d`.

That is, take `(end [a c] d)` from `d` and overwrite the `(cut a [b c] e)`
part of `e`.

Or in simpler terms, take from the start of `d` and replace some part of `e`
with it.

Accepts~

`a` is a $bloq (block size).

`[b c d]` where:

- `b` is a step specifying the number of `bloq`s to offset.
- `b` is a step specifying the number of `bloq`s to replace.
- `d` is the donor atom.


`e` is the recipient atom.

Produces~

An atom.

Source~
>
    ++  sew
      ~/  %sew
      |=  [a=bloq [b=step c=step d=@] e=@]
      ^-  @
      %+  add
        (can a b^e c^d ~)
      =/  f  [a (add b c)]
      (lsh f (rsh f e))
<

Examples~
>
    > `@t`(sew 3 [0 0 'XXXX'] 'OOOO')
    'OOOO'
    > `@t`(sew 3 [0 1 'XXXX'] 'OOOO')
    'XOOO'
    > `@t`(sew 3 [2 1 'XXXX'] 'OOOO')
    'OOXO'
    > `@t`(sew 3 [2 2 'XXXX'] 'OOOO')
    'OOXX'
    > `@t`(sew 3 [0 4 'XXXX'] 'OOOO')
    'XXXX'
<


------------------------------------------------------------------------------
SWP                                                                  *++swp*

Reverse block order

Switches little-endian to big-endian and vice versa: produces an atom by
reversing the block order of `b` using block size `a`.

Accepts~

`a` is a block size (see `$bloq`).

`b` is an atom.

Produces~

An atom

Source~
>
    ++  swp
      ~/  %swp
      |=  [a=bloq b=@]
      (rep a (flop (rip a b)))
<

Examples~
>
    > `@ub`24             ::  @ub is the binary aura
    0b1.1000
    > (swp 0 24)
    3
    > `@ub`3
    0b11
<
>
    > (swp 0 0)
    0
    > (swp 0 128)
    1
<


------------------------------------------------------------------------------
XEB                                                                  *++xeb*

Binary logarithm

Computes the base-2 logarithm of `a`, producing an atom.

Accepts~

`a` is an atom.

Produces~

An atom.

Source~
>
    ++  xeb
      ~/  %xeb
      |=  a=@
      ^-  @
      (met 0 a)
<

Examples~
>
    > (xeb 31)
    5
<
>
    > (xeb 32)
    6
<
>
    > (xeb 49)
    6
<
>
    > (xeb 0)
    0
<
>
    > (xeb 1)
    1
<
>
    > (xeb 2)
    2
<


------------------------------------------------------------------------------
FE                                                                  *++fe*

Modulo bloq

Core that contains arms for `bloq` and modular integer operations.

Accepts~

`a` is a `bloq`.

Source~
>
        |_  a=bloq
<


`++dif:fe`~

Produces the difference between two atoms in the modular basis representation.

Accepts~

`a` is a `bloq` (and is the sample of the parent core).

`b` is an atom.

`c` is an atom.

Produces~

A `@s`.

Source~
>
      ++  dif
        |=([b=@ c=@] (sit (sub (add out (sit b)) (sit c))))
<

Examples~
>
    > (~(dif fe 3) 63 64)
    255
    > (~(dif fe 3) 5 10)
    251
    > (~(dif fe 3) 0 1)
    255
<
>
    > (~(dif fe 0) 9 10)
    1
    > (~(dif fe 0) 9 11)
    0
    > (~(dif fe 0) 9 12)
    1
<
>
    > (~(dif fe 2) 9 12)
    13
    > (~(dif fe 2) 63 64)
    15
<


`++inv:fe`~

Inverse

Inverts the order of the modular field.

Accepts~

`a` is a `bloq` (and is the sample of the parent core).

`b` is a `bloq`. (see `$bloq`)

Produces~

An atom.

Source~
>
    ++  inv  |=(b=@ (sub (dec out) (sit b)))
<

Examples~
>
    > (~(inv fe 3) 255)
    0
    > (~(inv fe 3) 256)
    255
<
>
    > (~(inv fe 3) 0)
    255
    > (~(inv fe 3) 1)
    254
    > (~(inv fe 3) 2)
    253
<
>
    > (~(inv fe 3) 55)
    200
<


`++net:fe`~

Flip endianness

Reverses bytes within a block.

Accepts~

`a` is a `bloq` (and the sample of the parent core).

`b` is a `bloq`. (see `$bloq`)

Produces~

An atom.

Source~
>
    ++  net  |=  b=@  ^-  @
             =>  .(b (sit b))
             ?:  (lte a 3)
               b
             =+  c=(dec a)
             %+  con
               (lsh c $(a c, b (cut c [0 1] b)))
             $(a c, b (cut c [1 1] b))
<

Examples~
>
    > (~(net fe 3) 64)
    64
    > (~(net fe 3) 128)
    128
    > (~(net fe 3) 255)
    255
    > (~(net fe 3) 256)
    0
    > (~(net fe 3) 257)
    1
<
>
    > (~(net fe 3) 500)
    244
    > (~(net fe 3) 511)
    255
    > (~(net fe 3) 512)
    0
    > (~(net fe 3) 513)
    1
<
>
    > (~(net fe 3) 0)
    0
    > (~(net fe 3) 1)
    1
    > (~(net fe 0) 1)
    1
    > (~(net fe 0) 2)
    0
    > (~(net fe 0) 3)
    1
<
>
    > (~(net fe 6) 1)
    72.057.594.037.927.936
    > (~(net fe 6) 2)
    144.115.188.075.855.872
    > (~(net fe 6) 3)
    216.172.782.113.783.808
    > (~(net fe 6) 4)
    288.230.376.151.711.744
    > (~(net fe 6) 5)
    360.287.970.189.639.680
<


`++out:fe`~

Max integer value

Produces the maximum integer value that the current block can store; `2^a^a`.

Accepts~

`a` is a `bloq` (and is the sample of the parent core).

Produces~

An atom.

Source~
>
    ++  out  (bex (bex a))
<

Examples~
>
    > ~(out fe 0)
    2
    > ~(out fe 1)
    4
    > ~(out fe 2)
    16
    > ~(out fe 3)
    256
    > ~(out fe 4)
    65.536
<
>
    > ~(out fe 10)
    \/179.769.313.486.231.590.772.930.519.078.902.473.361.797.697.894.230.657.273\/
      .430.081.157.732.675.805.500.963.132.708.477.322.407.536.021.120.113.879.87
      1.393.357.658.789.768.814.416.622.492.847.430.639.474.124.377.767.893.424.8
      65.485.276.302.219.601.246.094.119.453.082.952.085.005.768.838.150.682.342.
      462.881.473.913.110.540.827.237.163.350.510.684.586.298.239.947.245.938.479
      .716.304.835.356.329.624.224.137.216
    \/                                                                           \/
<


`++rol:fe`~

Roll left

Rolls `d` to the left by `c` `b`-sized blocks.

Accepts~

`a` is a `bloq` (and is the sample of the parent core).

`b` is a `bloq`.

`c` is an atom.

`d` is an atom.

Produces~

An atom.

Source~
>
    ++  rol  |=  [b=bloq c=@ d=@]  ^-  @
             =+  e=(sit d)
             =+  f=(bex (sub a b))
             =+  g=(mod c f)
             (sit (con (lsh [b g] e) (rsh [b (sub f g)] e)))
<

Examples~
>
    > `@ux`(~(rol fe 6) 4 3 0xabac.dedf.1213)
    0x1213.0000.abac.dedf
    
    > `@ux`(~(rol fe 6) 4 2 0xabac.dedf.1213)
    0xdedf.1213.0000.abac
<
>
    > `@t`(~(rol fe 5) 3 1 'dfgh')
    'hdfg'
    
    > `@t`(~(rol fe 5) 3 2 'dfgh')
    'ghdf'
    
    > `@t`(~(rol fe 5) 3 0 'dfgh')
    'dfgh'
<


`++ror:fe`~

Roll right

Rolls `d` to the right by `c` `b`-sized blocks.

Accepts~

`a` is a `bloq` (and is the sample of the parent core).

`b` is a `bloq`.

`c` is an atom.

`d` is an atom.

Produces~

An atom.

Source~
>
    ++  ror  |=  [b=bloq c=@ d=@]  ^-  @
             =+  e=(sit d)
             =+  f=(bex (sub a b))
             =+  g=(mod c f)
             (sit (con (rsh [b g] e) (lsh [b (sub f g)] e)))
<

Examples~
>
    > `@ux`(~(ror fe 6) 4 1 0xabac.dedf.1213)
    0x1213.0000.abac.dedf
    
    > `@ux`(~(ror fe 6) 3 5 0xabac.dedf.1213)
    0xacde.df12.1300.00ab
    
    > `@ux`(~(ror fe 6) 3 3 0xabac.dedf.1213)
    0xdf12.1300.00ab.acde
<
>
    > `@t`(~(rol fe 5) 3 0 'hijk')
    'hijk'
    
    > `@t`(~(rol fe 5) 3 1 'hijk')
    'khij'
    
    > `@t`(~(rol fe 5) 3 2 'hijk')
    'jkhi'
<


`++sum:fe`~

Sum

Sums two numbers in this modular field.

Accepts~

`a` is a `bloq` (and is the sample of the parent core).

`b` is an atom.

`c` is an atom.

Produces~

An atom.

Source~
>
    ++  sum  |=([b=@ c=@] (sit (add b c)))
<

Examples~
>
    > (~(sum fe 3) 10 250)
    4
<
>
    > (~(sum fe 0) 0 1)
    1
    > (~(sum fe 0) 0 2)
    0
<
>
    > (~(sum fe 2) 14 2)
    0
    > (~(sum fe 2) 14 3)
    1
<
>
    > (~(sum fe 4) 10.000 256)
    10.256
    > (~(sum fe 4) 10.000 100.000)
    44.464
<


`++sit:fe`~

Enforce modulo

Produces an atom in the current modular block representation.

Accepts~

`a` is a `bloq` (and is the sample of the parent core).

`b` is an atom.

Produces~

An atom.

Source~
>
    ++  sit  |=(b=@ (end a b))
<

Examples~
>
    > (~(sit fe 3) 255)
    255
    > (~(sit fe 3) 256)
    0
    > (~(sit fe 3) 257)
    1
<
>
    > (~(sit fe 2) 257)
    1
    > (~(sit fe 2) 10.000)
    0
    > (~(sit fe 2) 100)
    4
    > (~(sit fe 2) 19)
    3
    > (~(sit fe 2) 17)
    1
<
>
    > (~(sit fe 0) 17)
    1
    > (~(sit fe 0) 0)
    0
    > (~(sit fe 0) 1)
    1
<



==============================================================================
 2d: Bit Logic                                                                         

------------------------------------------------------------------------------
CON                                                                  *++con*

Binary OR

Computes the bitwise logical OR of two atoms, `a` and `b`, producing an atom.

Accepts~

`a` is an atom

`b` is an atom

Produces~

An atom.

Source~
>
    ++  con
      ~/  %con
      |=  [a=@ b=@]
      =+  [c=0 d=0]
      |-  ^-  @
      ?:  ?&(=(0 a) =(0 b))  d
      %=  $
        a   (rsh 0 a)
        b   (rsh 0 b)
        c   +(c)
        d   %+  add  d
              %+  lsh  [0 c]
              ?&  =(0 (end 0 a))
                  =(0 (end 0 b))
              ==
      ==
<

Examples~
>
        > (con 0b0 0b1)
        1
    
        > (con 0 1)
        1
    
        > (con 0 0)
        0
    
        > `@ub`(con 0b1111.0000 0b1.0011)
        0b1111.0011
    
        > (con 4 4)
        4
    
        > (con 10.000 234)
        10.234
    
        > `@ub`534
        0b10.0001.0110
    
        > `@ub`987
        0b11.1101.1011
    
        > `@ub`(con 534 987)
        0b11.1101.1111
    
        > (con 534 987)
        991
<

Discussion~

`con` performs the bitwise operation OR, a concept that's general to
computing. It compares each bit of its first sample to the corresponding bit
of its second sample. If either bit is 1, the corresponding product bit is set
to 1. Otherwise, the corresponding product bit is set to 0.

Take the example of `(con 8 12)`. It's easy to see how this operation works
when its samples and its product are stacked.
>
        0b1000     ::  8  (sample)
        0b1100     ::  12 (sample)
        0b1100     ::  12 (product)
<

Note that the names `con` (conjunction) for OR and `dis` (disjunction) for AND
are given to opposite operators in Hoon when compared to other computing
contexts. That's because `0` is true in Hoon and `1` is false. Outside of
Hoon, where `0` is false and `1` is true, bitwise OR is the logical
disjunction and bitwise AND is the logical conjunction.


------------------------------------------------------------------------------
DIS                                                                  *++dis*

Binary AND

Computes the bitwise logical AND of two atoms, `a` and `b`, producing an atom.

Accepts~

`a` is an atom.

`b` is an atom.

Produces~

An atom.

Source~
>
    ++  dis
      ~/  %dis
      |=  [a=@ b=@]
      =|  [c=@ d=@]
      |-  ^-  @
      ?:  ?|(=(0 a) =(0 b))  d
      %=  $
        a   (rsh 0 a)
        b   (rsh 0 b)
        c   +(c)
        d   %+  add  d
              %+  lsh  [0 c]
              ?|  =(0 (end 0 a))
                  =(0 (end 0 b))
              ==
      ==
<

Examples~
>
        > `@ub`9
        0b1001
    
        > `@ub`5
        0b101
    
        > `@ub`(dis 9 5)
        0b1
    
        > (dis 9 5)
        1
    
        > `@ub`534
        0b10.0001.0110
    
        > `@ub`987
        0b11.1101.1011
    
        > `@ub`(dis 534 987)
        0b10.0001.0010
    
        > (dis 534 987)
        530
<

Discussion~

`dis` performs the bitwise AND, an operation general to computing. It compares
each bit of its first sample to the corresponding bit of its second sample. If
both bits are 1, the corresponding product bit is set to 1. Otherwise, the
corresponding product bit is set to 0.

Take the example of `(dis 8 12)`. It's easy to see how this operation works
when its samples and its product are stacked.
>
        0b1000     ::  8  (sample)
        0b1100     ::  12 (sample)
        0b1000     ::  8  (product)
<

Note that the names `dis` (disjunction) for AND and `con` (conjuction) for OR
are given to opposite operators in Hoon when compared to other computing
contexts. That's because `0` is true in Hoon and `1` is false. Outside of
Hoon, where `0` is false and `1` is true, bitwise OR is the logical
disjunction and bitwise AND is the logical conjunction.


------------------------------------------------------------------------------
MIX                                                                  *++mix*

Binary XOR

Produces the bitwise logical XOR of two atoms, `a` and `b`, producing an atom.

Accepts~

`a` is an atom

`b` is an atom

Produces~

An atom.

Source~
>
    ++  mix
      ~/  %mix
      |=  [a=@ b=@]
      ^-  @
      =+  [c=0 d=0]
      |-
      ?:  ?&(=(0 a) =(0 b))  d
      %=  $
        a   (rsh 0 a)
        b   (rsh 0 b)
        c   +(c)
        d   (add d (lsh [0 c] =((end 0 a) (end 0 b))))
      ==
<

Examples~
>
        > `@ub`2
        0b10
    
        > `@ub`3
        0b11
    
        > `@ub`(mix 2 3)
        0b1
    
        > (mix 2 3)
        1
    
        > `@ub`(mix 2 2)
        0b0
    
        > (mix 2 2)
        0
    
        > `@ub`534
        0b10.0001.0110
    
        > `@ub`987
        0b11.1101.1011
    
        > `@ub`(mix 534 987)
        0b1.1100.1101
    
        > (mix 534 987)
        461
<

Discussion~

`mix` performs the bitwise XOR (exclusive-OR), an operation that's general to
computing. compares each bit of its first sample to the corresponding bit of
its second sample. If one bit is 0 and the other bit is 1, the corresponding
product bit is set to 1. Otherwise, the corresponding product bit is set to 0.

Take the example of `(mix 8 12)`. It's easy to see how this operation works
when its samples and its product are stacked.
>
        0b1000     ::  8  (sample)
        0b1100     ::  12 (sample)
         0b100     ::  4 (product)
<


------------------------------------------------------------------------------
NOT                                                                  *++not*

Binary NOT

Computes the bitwise logical NOT of the bottom `b` blocks of size `a` of `c`.

Accepts~

`a` is a block size (see `bloq`).

`b` is an atom.

`c` is an atom.

Produces~

An atom.

Source~
>
    ++  not  |=  [a=bloq b=@ c=@]
      (mix c (dec (bex (mul b (bex a)))))
<

Examples~
>
        > `@ub`24
        0b1.1000
    
        > (not 0 5 24)
        7
    
        > `@ub`7
        0b111
    
        > (not 2 5 24)
        1.048.551
    
        > (not 2 5 1.048.551)
        24
    
        > (not 1 1 (not 1 1 10))
        10
<

Discussion~

In computing in general, the bitwise operation NOT simply turns a binary
number's `0`s into `1`s, and vice versa.

In Hoon, we ask for a little more information to use `not`, because binary
numbers have a number of implicit leading zeroes differently depending on on
their block size. Decimal `7`, for example, is `0b111` in binary, and has one
implicit zero in the context of a block of size `2`, which has a bitwidth of
4. Let's try `not` on `7` with a single block of size `2`.
>
        > `@ub`(not 2 1 0b111)
        0b1000
    
        > `@u`0b1000
        8
<

This happened because `0b111` is considered as `0b0111` by the `not` operator
when dealing with a single block of size `2`. The NOT of `7`, then, is
`0b1000`, or `8` in decimal.

When we pass `not` a single block of size `3`, there is a bitwidth of 8 to
fill with binary information. So the remaining leading digits of `0b111` are,
again, treated as `0`.
>
        > `@ub`(not 3 1 0b111)
        0b1111.1000
    
        > `@u`0b1111.1000
        248
<

This works when going to a smaller block size, too.
>
        > `@ub`(not 1 1 0b1011)
        0b100
    
        > `@u`0b100
        4
<

What's happening here may not be readily apparent. But we're only flipping the
last block of size `1` (bitwidth 2) of the binary `0b111`. That is, we leave
the "0b1" piece just the same and manipulate the "11" that the number ends
with.



==============================================================================
 2e: Insecure Hashing                                                                         

------------------------------------------------------------------------------
MUG {% #MUG %}                                                                  *++mug {% #mug %}*

murmur3 scrambler

Hashes `a` with the 31-bit murmur3 non-cryptographic hash algorithm, producing
an atom.

Accepts~

`a` is a noun.

Produces~

An atom.

Source~
>
    ++  mug
      ~/  %mug
      |=  a=*
      |^  ?@  a  (mum 0xcafe.babe 0x7fff a)
          =/  b  (cat 5 $(a -.a) $(a +.a))
          (mum 0xdead.beef 0xfffe b)
      ::
      ++  mum
        |=  [syd=@uxF fal=@F key=@]
        =/  wyd  (met 3 key)
        =|  i=@ud
        |-  ^-  @F
        ?:  =(8 i)  fal
        =/  haz=@F  (muk syd wyd key)
        =/  ham=@F  (mix (rsh [0 31] haz) (end [0 31] haz))
        ?.(=(0 ham) ham $(i +(i), syd +(syd)))
      --
<

Examples~
>
    > (mug 10.000)
    795.713.195
<
>
    > (mug 10.001)
    420.521.697
<
>
    > (mug 1)
    1.901.865.568
<
>
    > (mug (some 10))
    750.200.080
<
>
    > (mug [1 2 3 4 5 ~])
    1.565.443.491
<


------------------------------------------------------------------------------
MUK                                                                  *++muk*

Standard MurmurHash3

Implementation of the 32-bit MurmurHash3 non-cryptographic hash algorithm.
Takes `syd` as the seed, `len` as the key length in blocks of size 3, and
`key` as the key, producing an atom.

Accepts~

`syd` is an atom.

`len` is an atom.

`key` is an atom.

Produces~

An atom.

Source~
>
    ++  muk                                                 ::  standard murmur3
      ~%  %muk  ..muk  ~
      =+  ~(. fe 5)
      |=  [syd=@ len=@ key=@]
      =.  syd      (end 5 syd)
      =/  pad      (sub len (met 3 key))
      =/  data     (weld (rip 3 key) (reap pad 0))
      =/  nblocks  (div len 4)  ::  intentionally off-by-one
      =/  h1  syd
      =+  [c1=0xcc9e.2d51 c2=0x1b87.3593]
      =/  blocks  (rip 5 key)
      =/  i  nblocks
      =.  h1  =/  hi  h1  |-
        ?:  =(0 i)  hi
        =/  k1  (snag (sub nblocks i) blocks)  ::  negative array index
        =.  k1  (sit (mul k1 c1))
        =.  k1  (rol 0 15 k1)
        =.  k1  (sit (mul k1 c2))
        =.  hi  (mix hi k1)
        =.  hi  (rol 0 13 hi)
        =.  hi  (sum (sit (mul hi 5)) 0xe654.6b64)
        $(i (dec i))
      =/  tail  (slag (mul 4 nblocks) data)
      =/  k1    0
      =/  tlen  (dis len 3)
      =.  h1
        ?+  tlen  h1  ::  fallthrough switch
          %3  =.  k1  (mix k1 (lsh [0 16] (snag 2 tail)))
              =.  k1  (mix k1 (lsh [0 8] (snag 1 tail)))
              =.  k1  (mix k1 (snag 0 tail))
              =.  k1  (sit (mul k1 c1))
              =.  k1  (rol 0 15 k1)
              =.  k1  (sit (mul k1 c2))
              (mix h1 k1)
          %2  =.  k1  (mix k1 (lsh [0 8] (snag 1 tail)))
              =.  k1  (mix k1 (snag 0 tail))
              =.  k1  (sit (mul k1 c1))
              =.  k1  (rol 0 15 k1)
              =.  k1  (sit (mul k1 c2))
              (mix h1 k1)
          %1  =.  k1  (mix k1 (snag 0 tail))
              =.  k1  (sit (mul k1 c1))
              =.  k1  (rol 0 15 k1)
              =.  k1  (sit (mul k1 c2))
              (mix h1 k1)
        ==
      =.  h1  (mix h1 len)
      |^  (fmix32 h1)
      ++  fmix32
        |=  h=@
        =.  h  (mix h (rsh [0 16] h))
        =.  h  (sit (mul h 0x85eb.ca6b))
        =.  h  (mix h (rsh [0 13] h))
        =.  h  (sit (mul h 0xc2b2.ae35))
        =.  h  (mix h (rsh [0 16] h))
        h
      --
<

Examples~
>
        > (muk 6 1 3)
        3.427.677.118
    
        > (muk 6 2 'jerry')
        ! exit
    
        > (muk 6 2 'je')
        3.602.081.716
    
        > (met 3 'jerry')
        5
    
        > (met 3 'je')
        2
    
        > (muk 6 5 'jerry')
        1.276.447.489
    
        > (muk 6 15 'jerry')
        2.881.503.571
    
        > =e (cut 3 [0 2] eny)                            :: `eny` is 512 bits of entropy (a random number).
        > e
        44.228
    
        > (muk e 11 10.000)
        246.077.549
<



==============================================================================
 2f: Noun Ordering                                                                         

------------------------------------------------------------------------------
AOR                                                                  *++aor*

Alphabetical order

Computes whether `a` and `b` are in alphabetical order, producing a flag.
Orders atoms before cells, and atoms in ascending LSB order.

Accepts~

`a` is a noun.

`b` is a noun.

Produces~

A flag.

Source~
>
    ++  aor
      ~/  %aor
      |=  [a=* b=*]
      ^-  ?
      ?:  =(a b)  &
      ?.  ?=(@ a)
        ?:  ?=(@ b)  |
        ?:  =(-.a -.b)
          $(a +.a, b +.b)
        $(a -.a, b -.b)
      ?.  ?=(@ b)  &
      |-
      =+  [c=(end 3 a) d=(end 3 b)]
      ?:  =(c d)
        $(a (rsh 3 a), b (rsh 3 b))
      (lth c d)
<

Examples~
>
    > (aor 'a' 'b')
    %.y
    > (aor 'b' 'a')
    %.n
    > (aor 'a' 'a')
    %.y
    
    > (aor 1 2)
    %.y
    > (aor 2 1)
    %.n
    
    > (aor ['a' ~] 'b')
    %.n
    > (aor 'b' ['a' ~])
    %.y
    
    > (aor ['a' ~] ['b' ~])
    %.y
    > (aor ['b' ~] ['a' ~])
    %.n
    
    > (aor "abca" "abcz")
    %.y
    > (aor "abcz" "abca")
    %.n
    
    > (aor 0b1011 0b1010)
    %.n
    > (aor 0b1010 0b1011)
    %.y
    
    > (aor [1 2] [2 1])
    %.y
    > (aor [2 1] [1 2])
    %.n
<

Note the possible differences with `+dor` due to comparing one byte at a time:
>
    > (aor 0b1001.0000.0000 0b1000.1000.0000)
    %.y
    > (dor 0b1001.0000.0000 0b1000.1000.0000)
    %.n
<

Discussion~

This is different than +dor in that it compares atoms one byte at a time,
while `+dor` compares whole atoms at once. Note that because it simply
compares bytes, it doesn't account for multi-byte UTF-8 characters and the
like.


------------------------------------------------------------------------------
DOR                                                                  *++dor*

Depth order

Computes whether `a` and `b` are in ascending tree depth order, producing a
flag. Orders atoms before cells, and atoms in ascending numerical order.

Accepts~

`a` is a noun.

`b` is a noun.

Produces~

A flag.

Source~
>
    ++  dor
      ~/  %dor
      |=  [a=* b=*]
      ^-  ?
      ?:  =(a b)  &
      ?.  ?=(@ a)
        ?:  ?=(@ b)  |
        ?:  =(-.a -.b)
          $(a +.a, b +.b)
        $(a -.a, b -.b)
      ?.  ?=(@ b)  &
      (lth a b)
<

Examples~
>
    > (dor 1 2)
    %.y
    
    > (dor 2 1)
    %.n
    
    > (dor ~[1 2 3] ~[1 2 4])
    %.y
    
    > (dor ~[1 2 4] ~[1 2 3])
    %.n
    
    > (dor `(list @)`~[99 100 10.000] ~[99 101 10.000])
    %.y
    
    > (dor ~[99 101 10.999] `(list @)`~[99 100 10.000])
    %.n
<

Note the possible difference with +aor due to comparing whole atoms rather
than one byte at a time:
>
    > (aor 0b1001.0000.0000 0b1000.1000.0000)
    %.y
    > (dor 0b1001.0000.0000 0b1000.1000.0000)
    %.n
<

Discussion~

If `a` and `b` are both atoms, `dor` is equivalent to `lte`. If they're cells,
`dor` recurses on the heads, and then if the heads are the same it checks the
tails.

If one sample is a cell and the other is an atom, the cell sample is treated
as "greater."


------------------------------------------------------------------------------
GOR                                                                  *++gor*

Mug order

Computes whether of `(mug a)` and `(mug b)` are in ascending numeric order,
producing a flag. If the `mug` hashes are equal, `a` and `b` are compared by
`dor` instead.

`mug` is the the 31-bit nonzero FNV-1a hash algorithm.

Accepts~

`a` is a noun.

`b` is a noun.

Produces~

A flag.

Source~
>
    ++  gor
      ~/  %gor
      |=  [a=* b=*]
      ^-  ?
      =+  [c=(mug a) d=(mug b)]
      ?:  =(c d)
        (dor a b)
      (lth c d)
<

Examples~
>
    > (gor 'd' 'c')
    %.y
    
    > 'd'
    'd'
    > 'c'
    'c'
    
    > `@ud`'d'
    100
    > `@ud`'c'
    99
    
    > (mug 'd')
    1.628.185.714
    > (mug 'c')
    1.712.073.811
    
    > (gor 'd' 'c')
    %.y
    > (gor 'c' 'd')
    %.n
<
>
    > (gor "foo" "bar")
    %.n
<
>
    > (gor (some 10) `(list @)`[1 2 3 ~])
    %.n
<

Discussion~

`map`s use `gor` on the key for horizontal ordering and `mor` for vertical
order. `map`s only look at the keys (the head of the key-value pair elements)
for ordering.


------------------------------------------------------------------------------
MOR                                                                  *++mor*

(more) mug order

Computes whether the double-hashes `(mug (mug a))` and `(mug (mug b))` are in
ascending numeric order, producing a flag. If the double-`mug` hashes are
equal, `a` and `b` are compared by `dor` instead.

`mug` is the the 31-bit nonzero FNV-1a hash algorithm.

Accepts~

`a` is a noun

`b` is a noun

Produces~

A flag.

Source~
>
    ++  mor
      ~/  %mor
      |=  [a=* b=*]
      ^-  ?
      =+  [c=(mug (mug a)) d=(mug (mug b))]
      ?:  =(c d)
        (dor a b)
      (lth c d)
<

Examples~
>
        > (mor 'f' 'g')
        %.y
    
        > [(mug 'f') (mug 'g')]
        [1.661.740.952 1.644.963.335]
    
        > [(mug (mug 'f')) (mug (mug 'g'))]
        [261.421.509 1.861.258.547]
    
        > (mor 'a' 'z')
        %.n
    
        > (mor 43.326 41.106)
        %.n
<

Discussion~

Maps, sets, and queues all use `mor` to check for vertical ordering. Maps and
sets also use `gor` for horizontal order, but queues use vertical ordering
alone.

Since hashing removes correlation, double-`mug`ging with `mor` removes
correlation with single-`mug`ged `gor`. Vertical order becomes uncorrelated
with horizontal order.



==============================================================================
 2g: Unsigned Powers                                                                         

------------------------------------------------------------------------------
POW                                                                  *++pow*

Computes `a` raised to the power of `b`, producing an atom.

Accepts~

`a` is an atom.

`b` is an atom.

Produces~

An atom.

Source~
>
    ++  pow
      ~/  %pow
      |=  [a=@ b=@]
      ?:  =(b 0)  1
      |-  ?:  =(b 1)  a
      =+  c=$(b (div b 2))
      =+  d=(mul c c)
      ?~  (dis b 1)  d  (mul d a)
<

Examples~
>
        > (pow 2 6)
        64
    
        > (pow 6 2)
        36
    
        > (pow 7 (add 2 2))
        2.401
    
        > (pow 2 0)
        1
    
        > `@ux`(pow 0x1b 2)
        0x2d9
<


------------------------------------------------------------------------------
SQT                                                                  *++sqt*

Computes the square root of `a` and its remainder.

Accepts~

`a` is an atom.

Produces~

A cell of atoms.

Source~
>
    ++  sqt
      ~/  %sqt
      |=  a=@  ^-  [p=@ q=@]
      ?~  a  [0 0]
      =+  [q=(div (dec (xeb a)) 2) r=0]
      =-  [-.b (sub a +.b)]
      ^=  b  |-
      =+  s=(add r (bex q))
      =+  t=(mul s s)
      ?:  =(q 0)
        ?:((lte t a) [s t] [r (mul r r)])
      ?:  (lte t a)
        $(r s, q (dec q))
      $(q (dec q))
<

Examples~
>
        > (sqt 4)
        [p=2 q=0]
    
        > (sqt 6)
        [p=2 q=2]
    
        > (sqt 2)
        [p=1 q=1]
    
        > (sqt 0b1101)
        [p=3 q=4]
    
        > `@ux`(sqt 0b1101)
        ! exit
<



==============================================================================
 2h: Set Logic                                                                         

------------------------------------------------------------------------------
IN                                                                  *++in*

Set operations

Core whose arms contain a variety of functions that operate on `set`s. Its
sample accepts the input `set` to be manipulated.

Accepts~

A `set`.

Source~
>
      ~/  %in
      =|  a=(tree)
      |@
<

Examples~
>
    > ~(. in (sy "asd"))
    <16.ufw [a=?(%~ [?(n=@tD n=#1) l=nlr(?(@tD #1)) r=nlr(?(@tD ^#1.?(@tD #1)))]) <123.zao 46.hgz 1.pnw %140>]>
<

`++all:in`~

Logical AND

Computes the logical AND on every element in `a` slammed with `b`, producing a
flag.

Accepts~

`a` is a `set`, and is the sample of `+in`.

`b` is a gate that accepts a noun and produces a flag.

Produces~

A flag.

Source~
>
    ++  all
      ~/  %all
      |*  b=$-(* ?)
      |-  ^-  ?
      ?~  a
        &
      ?&((b n.a) $(a l.a) $(a r.a))
<

Examples~
>
    > (~(all in (silt ~[1 2 3 4])) |=(a=@ (lth a 5)))
    %.y
    
    > (~(all in (silt ~[1 2 3 4 5])) |=(a=@ (lth a 5)))
    %.n
<


`++any:in`~

Logical OR

Computes the logical OR on every element of `a` slammed with `b`, producing a
flag.

Accepts~

`a` is a `set`, and is the sample of `+in`.

`b` is a gate that accepts a noun and produces a flag.

Produces~

A flag.

Source~
>
    ++  any
      ~/  %any
      |*  b=$-(* ?)
      |-  ^-  ?
      ?~  a
        |
      ?|((b n.a) $(a l.a) $(a r.a))
<

Examples~
>
    > (~(any in (silt ~[2 3 4 5])) |=(a=@ (lth a 3)))
    %.y
    
    > (~(any in (silt ~[3 4 5])) |=(a=@ (lth a 3)))
    %.n
<


`++apt:in`~

Check correctness

Computes whether `a` has a correct horizontal order and a correct vertical
order, producing a flag.

Accepts~

`a` is a set.

Produces~

A flag.

Source~
>
    ++  apt
      =<  $
      ~/  %apt
      =|  [l=(unit) r=(unit)]
      |.  ^-  ?
      ?~  a   &
      ?&  ?~(l & (gor n.a u.l))
          ?~(r & (gor u.r n.a))
          ?~(l.a & ?&((mor n.a n.l.a) $(a l.a, l `n.a)))
          ?~(r.a & ?&((mor n.a n.r.a) $(a r.a, r `n.a)))
      ==
<

Examples~
>
    > ~(apt in ~)
    %.y
<
>
    > =a (silt ~[1 2 3])
    > a
    [n=2 l={1} r={3}]
    > ~(apt in a)
    %.y
    
    > =z ?~(a ~ a(n 10))
    > z
    [n=10 l={1} r={3}]
    > ~(apt in z)
    %.n
<

Discussion~

See section `2f` for more information on noun ordering.


`++bif:in`~

Bifurcate

Splits set `a` into sets `l` and `r`, which contain the items either side of
`b` but not including `b`.

Accepts~

`a` is a set, and is the sample of `+in`.

`b` is a noun.

Produces~

A cell of two sets.

Source~
>
    ++  bif
      ~/  %bif
      |*  b=*
      ^+  [l=a r=a]
      =<  +
      |-  ^+  a
      ?~  a
        [b ~ ~]
      ?:  =(b n.a)
        a
      ?:  (gor b n.a)
        =+  c=$(a l.a)
        ?>  ?=(^ c)
        c(r a(l r.c))
      =+  c=$(a r.a)
      ?>  ?=(^ c)
      c(l a(r l.c))
<

Examples~
>
    > =a `(set @)`(silt (gulf 1 20))
    > a
    {17 8 20 13 11 5 19 7 15 10 18 14 6 12 9 1 2 3 16 4}
    
    > (~(bif in a) 10)
    [l=[n=11 l={17 8 20 13} r={5 19 7 15}] r=[n=12 l={18 14 6} r={9 1 2 3 16 4}]]
    
    > `[(set @) (set @)]`(~(bif in a) 10)
    [{17 8 20 13 11 5 19 7 15} {18 14 6 12 9 1 2 3 16 4}]
<

Discussion~

Note that `set`s are horizontally ordered by the mug hash of their items and
vertically ordered by the double-`mug` hash of their items. This means
bifurcating the set of numbers `(silt ~[10 20 30 40 50])` at `30` will not
produce `[{10 20} {40 50}]`, but rather `[{20} {10 40 50}]` due to the tree
structure resulting from their `mug` hashes.


`++del:in`~

Remove noun

Removes `b` from the `set` `a`.

Accepts~

`a` is a set, and is the sample of `+in`.

`b` is a noun.

Produces~

A set.

Source~
>
    ++  del
      ~/  %del
      |*  b=*
      |-  ^+  a
      ?~  a
        ~
      ?.  =(b n.a)
        ?:  (gor b n.a)
          a(l $(a l.a))
        a(r $(a r.a))
      |-  ^-  [$?(~ _a)]
      ?~  l.a  r.a
      ?~  r.a  l.a
      ?:  (mor n.l.a n.r.a)
        l.a(r $(l.a r.l.a))
      r.a(l $(r.a l.r.a))
<

Examples~
>
    > `(set @)`(~(del in (silt ~[1 2 3 4 5])) 3)
    {5 1 2 4}
<
>
    > `(set @t)`(~(del in (silt ~['foo' 'bar' 'baz'])) 'bar')
    {'baz' 'foo'}
<
>
    > `(set @)`(~(del in (silt ~[1 2 3 4 5])) 10)
    {5 1 2 3 4}
<
>
    > `(set @)`(~(del in ~) 10)
    {}
<


`++dif:in`~

Difference

Computes the difference between `a` and `b`, producing the set of items in `a`
that are not in `b`.

Accepts~

`a` is a set, and is the sample of `+in`.

`b` is a set.

Produces~

A set.

Source~
>
    ++  dif
      ~/  %dif
      =+  b=a
      |@
      ++  $
        |-  ^+  a
        ?~  b
          a
        =+  c=(bif n.b)
        ?>  ?=(^ c)
        =+  d=$(a l.c, b l.b)
        =+  e=$(a r.c, b r.b)
        |-  ^-  [$?(~ _a)]
        ?~  d  e
        ?~  e  d
        ?:  (mor n.d n.e)
          d(r $(d r.d))
        e(l $(e l.e))
      --
<

Examples~
>
    > =a (silt ~[1 2 3 4 5])
    > =b (silt ~[3 4])
    
    > `(set @)`(~(dif in a) b)
    {5 1 2}
<


`++dig:in`~

Address b in a

Produce the tree address of `b` within `a`.

Accepts~

`a` is a set, and is the sample of `+in`.

`b` is a noun.

Produces~

The `unit` of an atom.

Source~
>
    ++  dig
      |=  b=*
      =+  c=1
      |-  ^-  (unit @)
      ?~  a  ~
      ?:  =(b n.a)  [~ u=(peg c 2)]
      ?:  (gor b n.a)
        $(a l.a, c (peg c 6))
      $(a r.a, c (peg c 7))
<

Examples~
>
    > =a (silt ~[1 2 3 4 5 6 7])
    
    > -.a
    n=6
    
    > (~(dig in a) 7)
    [~ 12]
    
    > (~(dig in a) 2)
    [~ 60]
    
    > (~(dig in a) 6)
    [~ 2]
    
    > (~(dig in a) 10)
    ~
<

Discussion~

For more on the tree addressing system, see section 1b.


`++gas:in`~

Concatenate

Insert the elements of a `list` `b` into a `set` `a`.

Accepts~

`a` is a set, and is the sample of `+in`.

`b` is a list.

Produces~

A `set`.

Source~
>
    ++  gas
      ~/  %gas
      |=  b=(list _?>(?=(^ a) n.a))
      |-  ^+  a
      ?~  b
        a
      $(b t.b, a (put i.b))
<

Examples~
>
    > =a (silt ~['foo' 'bar' 'baz'])
    > `(set @t)`a
    {'bar' 'baz' 'foo'}
    
    > `(set @t)`(~(gas in a) ~['foo' 'foo' 'foo' 'foo'])
    {'bar' 'baz' 'foo'}
    
    > `(set @t)`(~(gas in a) ~['abc' 'xyz' '123'])
    {'xyz' 'bar' 'baz' 'foo' 'abc' '123'}
<


`++has:in`~

b in a?

Checks if `b` is an element of `a`, producing a flag.

Accepts~

`a` is a set, and is the sample of `+in`.

`b` is a noun.

Produces~

A flag.

Source~
>
    ++  has
      ~/  %has
      |*  b=*
      ^-  ?
      %.  [~ b]
      |=  b=(unit _?>(?=(^ a) n.a))
      =>  .(b ?>(?=(^ b) u.b))
      |-  ^-  ?
      ?~  a
        |
      ?:  =(b n.a)
        &
      ?:  (gor b n.a)
        $(a l.a)
      $(a r.a)
<

Examples~
>
    > =a (silt ~[1 2 3 4 5])
    
    > (~(has in a) 2)
    %.y
    
    > (~(has in a) 6)
    %.n
<


`++int:in`~

Intersection

Produces a set of the intersection between two sets of the same type, `a` and
`b`.

Accepts~

`a` is a set, and is the sample of `+in`.

`b` is a set.

Produces~

A `set`.

Source~
>
    ++  int
      ~/  %int
      =+  b=a
      |@
      ++  $
        |-  ^+  a
        ?~  b
          ~
        ?~  a
          ~
        ?.  (mor n.a n.b)
          $(a b, b a)
        ?:  =(n.b n.a)
          a(l $(a l.a, b l.b), r $(a r.a, b r.b))
        ?:  (gor n.b n.a)
          %-  uni(a $(a l.a, r.b ~))  $(b r.b)
        %-  uni(a $(a r.a, l.b ~))  $(b l.b)
      --
<

Examples~
>
    > `(set @tD)`(~(int in (silt "foobar")) (silt "bar"))
    {'r' 'b' 'a'}
    
    > `(set @tD)`(~(int in (silt "foobar")) ~)
    {}
    
    > `(set @tD)`(~(int in (silt "foobar")) (silt "baz"))
    {'b' 'a'}
<


`++put:in`~

Put b in a

Add an element `b` to the set `a`, producing a set.

Accepts~

`a` is a set, and is the sample of `+in`.

`b` is a noun.

Produces~

A `set`.

Source~
>
    ++  put
      ~/  %put
      |*  b=*
      |-  ^+  a
      ?~  a
        [b ~ ~]
      ?:  =(b n.a)
        a
      ?:  (gor b n.a)
        =+  c=$(a l.a)
        ?>  ?=(^ c)
        ?:  (mor n.a n.c)
          a(l c)
        c(r a(l r.c))
      =+  c=$(a r.a)
      ?>  ?=(^ c)
      ?:  (mor n.a n.c)
        a(r c)
      c(l a(r l.c))
<

Examples~
>
    > `(set @)`(~(put in (silt ~[1 2 3])) 4)
    {1 2 3 4}
    
    > `(set @)`(~(put in `(set @)`~) 42)
    {42}
<


`++rep:in`~

Accumulate

Accumulate the elements of `a` using binary gate `b`.

Accepts~

`a` is a `set`, and is the sample of `+in`.

`b` is a gate.

Produces~

A noun.

Source~
>
    ++  rep
      ~/  %rep
      |*  b=_=>(~ |=([* *] +<+))
      |-
      ?~  a  +<+.b
      $(a r.a, +<+.b $(a l.a, +<+.b (b n.a +<+.b)))
<

Examples~
>
    > (~(rep in (silt ~[1 2 3 4 5])) add)
    b=15
<
>
    > `@t`(~(rep in (silt ~['foo' 'bar' 'baz'])) |=(a=[@ @] (cat 3 a)))
    'foobarbaz'
<


`++run:in`~

Apply gate to set

Produce a `set` containing the products of gate `b` applied to each element in
`a`.

Accepts~

`a` is a `set`.

`b` is a gate.

Produces~

A set.

Source~
>
    ++  run
      ~/  %run
      |*  b=gate
      =+  c=`(set _?>(?=(^ a) (b n.a)))`~
      |-  ?~  a  c
      =.  c  (~(put in c) (b n.a))
      =.  c  $(a l.a, c c)
      $(a r.a, c c)
<

Examples~
>
    > =s (silt ~["a" "A" "b" "c"])
    > `(set tape)`s
    {"A" "a" "c" "b"}
    
    > (~(run in s) cuss)
    {"A" "C" "B"}
<


`++tap:in`~

Set to list

Flattens the `set` `a` into a `list`.

Accepts~

`a` is an set.

Produces~

A list.

Source~
>
    ++  tap
      =<  $
      ~/  %tap
      =+  b=`(list _?>(?=(^ a) n.a))`~
      |.  ^+  b
      ?~  a
        b
      $(a r.a, b [n.a $(a l.a)])
<

Examples~
>
    > ~(tap in (silt "foobar"))
    "oafbr"
<
>
    > ~(tap in (silt ~[1 2 3 4 5]))
    ~[4 3 2 1 5]
<


`++uni:in`~

Union

Produces a set of the union between two sets of the same type, `a` and `b`.

Accepts~

`a` is a set, and is the sample of `+in`.

`b` is a set.

Produces~

A set.

Source~
>
    ++  uni
      ~/  %uni
      =+  b=a
      |@
      ++  $
        ?:  =(a b)  a
        |-  ^+  a
        ?~  b
          a
        ?~  a
          b
        ?:  =(n.b n.a)
          b(l $(a l.a, b l.b), r $(a r.a, b r.b))
        ?:  (mor n.a n.b)
          ?:  (gor n.b n.a)
            $(l.a $(a l.a, r.b ~), b r.b)
          $(r.a $(a r.a, l.b ~), b l.b)
        ?:  (gor n.a n.b)
          $(l.b $(b l.b, r.a ~), a r.a)
        $(r.b $(b r.b, l.a ~), a l.a)
      --
<

Examples~
>
    > =a (silt ~[1 2 3 4 5])
    > =b (silt ~[4 5 6 7 8])
    
    > `(set @)`(~(uni in a) b)
    {8 5 7 6 1 2 3 4}
    
    > `(set @)`(~(uni in a) ~)
    {5 1 2 3 4}
    
    > `(set @)`(~(uni in `(set @)`~) b)
    {8 5 7 6 4}
<


`++wyt:in`~

Set size

Produces the number of elements in set `a` as an atom.

Accepts~

`a` is an set.

Produces~

An atom.

Source~
>
    ++  wyt
      =<  $
      ~%  %wyt  +  ~
      |.  ^-  @
      ?~(a 0 +((add $(a l.a) $(a r.a))))
    --
<

Examples~
>
    > ~(wyt in (silt ~[1 2 3 4]))
    4
<
>
    > ~(wyt in `(set @)`~)
    0
<



==============================================================================
 2i: Map Logic                                                                         

------------------------------------------------------------------------------
BY                                                                  *++by*

Map operations

Container arm for map operation arms. A map is a set of key-value pairs. The
contained arms inherit its sample map, `a`.

Accepts~

`a` is a map.

Source~
>
    ++  by
      ~/  %by
      =|  a=(tree (pair))  ::  (map)
      =*  node  ?>(?=(^ a) n.a)
      |@
<

Examples~
>
    > ~(. by (malt (limo ~[a+1 b+2 c+3])))
    < 27.jus
      [   a
        ?(
          %~
          [ n=[?(p=%a p=%b p=%c) q=@ud]
            l=nlr([p=?(%a %b %c) q=@ud])
            r=nlr([p=?(%a %b %c) q=@ud])
          ]
        )
        <123.zao 46.hgz 1.pnw %140>
      ]
    >
<


`++all:by`~

Logical AND

Computes the logical AND on the results of slamming every element in map `a`
with gate `b`.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a gate.

Produces~

A flag.

Source~
>
    ++  all
      ~/  %all
      |*  b=$-(* ?)
      |-  ^-  ?
      ?~  a
        &
      ?&((b q.n.a) $(a l.a) $(a r.a))
<

Examples~
>
    > =a (malt (limo ~[a+1 b+[2 3]]))
    
    > (~(all by a) |=(a=* ?@(a & |)))
    %.n
<
>
    > =a (malt (limo ~[a+1 b+2 c+3 d+4 e+5]))
    
    > (~(all by a) |=(a=@ (lte a 6)))
    %.y
    
    > (~(all by a) |=(a=@ (lte a 4)))
    %.n
<


`++any:by`~

Logical OR

Computes the logical OR on the results of slamming every element with gate
`b`.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a wet gate.

Produces~

A flag.

Source~
>
    ++  any
      ~/  %any
      |*  b=$-(* ?)
      |-  ^-  ?
      ?~  a
        |
      ?|((b q.n.a) $(a l.a) $(a r.a))
<

Examples~
>
    > =a (malt (limo ~[a+1 b+[2 3]]))
    
    > (~(any by a) |=(a=* ?@(a & |)))
    %.y
<
>
    > =a (malt (limo ~[a+1 b+2 c+3 d+4 e+5]))
    
    > (~(any by a) |=(a=@ (lte a 4)))
    %.y
<


`++apt:by`~

Check correctness

Computes whether `a` has a correct horizontal order and a correct vertical
order, producing a flag.

Accepts~

`a` is a map.

Produces~

A flag.

Source~
>
    ++  apt
      =<  $
      ~/  %apt
      =|  [l=(unit) r=(unit)]
      |.  ^-  ?
      ?~  a   &
      ?&  ?~(l & &((gor p.n.a u.l) !=(p.n.a u.l)))
          ?~(r & &((gor u.r p.n.a) !=(u.r p.n.a)))
          ?~  l.a   &
          &((mor p.n.a p.n.l.a) !=(p.n.a p.n.l.a) $(a l.a, l `p.n.a))
          ?~  r.a   &
          &((mor p.n.a p.n.r.a) !=(p.n.a p.n.r.a) $(a r.a, r `p.n.a))
      ==
<

Examples~
>
    > =a (malt `(list [@tas @])`~[a+1 b+2 c+3 d+4 e+5])
    
    > ~(apt by a)
    %.y
    
    > =z ?~(a ~ a(p.n `@tas`%z))
    
    > z
    [n=[p=%z q=2] l={[p=%e q=5]} r={[p=%d q=4] [p=%a q=1] [p=%c q=3]}]
    
    > ~(apt by z)
    %.n
<

Discussion~

See section `2f` for more information on noun ordering.

`++bif:by`~

Bifurcate

Splits map `a` into two maps `l` and `r`, which contain the items either side
of key `b` with value `c` but not including `b`-`c`.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a noun.

`c` is a noun.

Produces~

A cell of two maps.

Source~
>
    ++  bif
      ~/  %bif
      |*  [b=* c=*]
      ^+  [l=a r=a]
      =<  +
      |-  ^+  a
      ?~  a
        [[b c] ~ ~]
      ?:  =(b p.n.a)
        ?:  =(c q.n.a)
          a
        a(n [b c])
      ?:  (gor b p.n.a)
        =+  d=$(a l.a)
        ?>  ?=(^ d)
        d(r a(l r.d))
      =+  d=$(a r.a)
      ?>  ?=(^ d)
      d(l a(r l.d))
<

Examples~
>
    > =a (malt `(list [@tas @])`~[a+1 b+2 c+3 d+4 e+5])
    
    > (~(bif by a) b+2)
    [l=[n=[p=%e q=5] l=~ r=~] r=[n=[p=%d q=4] l=~ r=[n=[p=%c q=3] l={[p=%a q=1]} r={}]]]
    
    > `[(map @tas @) (map @tas @)]`(~(bif by a) b+2)
    [{[p=%e q=5]} {[p=%d q=4] [p=%a q=1] [p=%c q=3]}]
<

Discussion~

Note that `map`s are horizontally ordered by the mug hash of their keys and
vertically ordered by the double-`mug` hash of their keys. This means
bifurcating the map `(malt ~[10^10 20^20 30^30 40^40 50^50])` at `30^30` will
not produce `[{10^10 20^20} {40^40 50^50}]`, but rather `[{20^20} {10^10 40^40
50^50}]` due to the tree structure resulting from their `mug` hashes.


`++del:by`~

Delete

Produces map `a` with the element located at key `b` removed.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a key as a noun.

Produces~

A map.

Source~
>
    ++  del
      ~/  %del
      |*  b=*
      |-  ^+  a
      ?~  a
        ~
      ?.  =(b p.n.a)
        ?:  (gor b p.n.a)
          a(l $(a l.a))
        a(r $(a r.a))
      |-  ^-  [$?(~ _a)]
      ?~  l.a  r.a
      ?~  r.a  l.a
      ?:  (mor p.n.l.a p.n.r.a)
        l.a(r $(l.a r.l.a))
      r.a(l $(r.a l.r.a))
<

Examples~
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2 c+3 d+4]))
    > a
    {[p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    
    > `(map @tas @)`(~(del by a) %z)
    {[p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    
    > `(map @tas @)`(~(del by a) %b)
    {[p=%d q=4] [p=%a q=1] [p=%c q=3]}
<


`++dif:by`~

Difference

Computes the difference between `a` and `b`, producing the map of key-value
pairs in `a` whose keys are not in `b`.

Accepts~

`a` is a `map`, and is the sample of `+by`.

`b` is a `map`.

Produces~

A `map`.

Source~
>
    ++  dif
      ~/  %dif
      =+  b=a
      |@
      ++  $
        |-  ^+  a
        ?~  b
          a
        =+  c=(bif p.n.b q.n.b)
        ?>  ?=(^ c)
        =+  d=$(a l.c, b l.b)
        =+  e=$(a r.c, b r.b)
        |-  ^-  [$?(~ _a)]
        ?~  d  e
        ?~  e  d
        ?:  (mor p.n.d p.n.e)
          d(r $(d r.d))
        e(l $(e l.e))
      --
<

Examples~
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2 c+3 d+4]))
    > =b `(map @tas @)`(malt (limo ~[c+3 d+4 e+5 f+6]))
    > a
    {[p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    > b
    {[p=%e q=5] [p=%d q=4] [p=%f q=6] [p=%c q=3]}
    
    > `(map @tas @)`(~(dif by a) b)
    {[p=%b q=2] [p=%a q=1]}
<
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2 c+3 d+4]))
    > =b `(map @tas @)`(malt (limo ~[a+2 e+4 f+5]))
    > a
    {[p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    > b
    {[p=%e q=4] [p=%f q=5] [p=%a q=2]}
    
    > `(map @tas @)`(~(dif by a) b)
    {[p=%b q=2] [p=%d q=4] [p=%c q=3]}
<

Discussion~

This only compares keys, so if both maps contain the same key with different
values, that key-value pair is not considered a difference and will not be
included in the resulting map.


`++dig:by`~

Address of key

Produce the address of key `b` within map `a`.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a key as a noun.

Produces~

A unit.

Source~
>
    ++  dig
      |=  b=*
      =+  c=1
      |-  ^-  (unit @)
      ?~  a  ~
      ?:  =(b p.n.a)  [~ u=(peg c 2)]
      ?:  (gor b p.n.a)
        $(a l.a, c (peg c 6))
      $(a r.a, c (peg c 7))
<

Examples~
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2 c+3 d+4]))
    
    > (~(dig by a) %a)
    [~ 252]
    
    > (~(dig by a) %b)
    [~ 2]
    
    > (~(dig by a) %e)
    ~
<


`++gas:by`~

Concatenate

Insert a list of key-value pairs `b` into map `a`. For a key which exists in
both `a` and `b`, the value is replaced with the value in `b`.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a list of cells of key-value nouns `p` and `q`.

Produces~

A map.

Source~
>
    ++  gas
      ~/  %gas
      |*  b=(list [p=* q=*])
      =>  .(b `(list _?>(?=(^ a) n.a))`b)
      |-  ^+  a
      ?~  b
        a
      $(b t.b, a (put p.i.b q.i.b))
<

Examples~
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2 c+3 d+4]))
    > a
    {[p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    
    > `(map @tas @)`(~(gas by a) ~[e+5 f+6 g+7])
    {[p=%e q=5] [p=%b q=2] [p=%d q=4] [p=%f q=6] [p=%g q=7] [p=%a q=1] [p=%c q=3]}
<
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2]))
    > a
    {[p=%b q=2] [p=%a q=1]}
    
    > `(map @tas @)`(~(gas by a) ~[a+100 b+200])
    {[p=%b q=200] [p=%a q=100]}
<
>
    > `(map @tas @)`(~(gas by `(map @tas @)`~) ~[a+100 b+200])
    {[p=%b q=200] [p=%a q=100]}
<


`++get:by`~

Grab unit value

Produce the unit value of the value located at key `b` within map `a`.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a key as a noun.

Produces~

A unit.

Source~
>
    ++  get
      ~/  %get
      |*  b=*
      =>  .(b `_?>(?=(^ a) p.n.a)`b)
      |-  ^-  (unit _?>(?=(^ a) q.n.a))
      ?~  a
        ~
      ?:  =(b p.n.a)
        (some q.n.a)
      ?:  (gor b p.n.a)
        $(a l.a)
      $(a r.a)
<

Examples~
>
    > a
    {[p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    
    > (~(get by a) %a)
    [~ 1]
    
    > (~(get by a) %b)
    [~ 2]
    
    > (~(get by a) %z)
    ~
<


`++got:by`~

Assert

Produce the value located at key `b` within map `a`. Crash if key `b` does not
exist.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a key as a noun.

Produces~

A noun.

Source~
>
    ++  got
      |*  b=*
      (need (get b))
<

Examples~
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2 c+3 d+4]))
    > a
    {[p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    
    > (~(got by a) %a)
    1
    
    > (~(got by a) %b)
    2
    
    > (~(got by a) %z)
    dojo: hoon expression failed
<


`++gut:by`~

Grab value with default

Produce the value located at key `b` within map `a`. Use default value `c` if
key does not exist.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a key as a noun.

`c` is a noun.

Produces~

A noun.

Source~
>
    ++  gut
      |*  [b=* c=*]
      (fall (get b) c)
<

Examples~
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2 c+3 d+4]))
    > a
    {[p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    
    > (~(gut by a) %a 9.999)
    1
    
    > (~(gut by a) %b 9.999)
    2
    
    > (~(gut by a) %z 9.999)
    9.999
<


`++has:by`~

Key existence check

Checks whether map `a` contains an element with key `b`, producing a flag.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a key as a noun.

Produces~

A flag.

Source~
>
    ++  has
      ~/  %has
      |*  b=*
      !=(~ (get b))
<

Examples~
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2 c+3 d+4]))
    > a
    {[p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    
    > (~(has by a) %a)
    %.y
    > (~(has by a) %z)
    %.n
<


`++int:by`~

Intersection

Produces a map of the (key) intersection between two maps of the same type,
`a` and `b`. If both maps have an identical key that point to different
values, the element from map `b` is used.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a map.

Produces~

A map.

Source~
>
    ++  int
      ~/  %int
      =+  b=a
      |@
      ++  $
        |-  ^+  a
        ?~  b
          ~
        ?~  a
          ~
        ?:  (mor p.n.a p.n.b)
          ?:  =(p.n.b p.n.a)
            b(l $(a l.a, b l.b), r $(a r.a, b r.b))
          ?:  (gor p.n.b p.n.a)
            %-  uni(a $(a l.a, r.b ~))  $(b r.b)
          %-  uni(a $(a r.a, l.b ~))  $(b l.b)
        ?:  =(p.n.a p.n.b)
          b(l $(b l.b, a l.a), r $(b r.b, a r.a))
        ?:  (gor p.n.a p.n.b)
          %-  uni(a $(b l.b, r.a ~))  $(a r.a)
        %-  uni(a $(b r.b, l.a ~))  $(a l.a)
      --
<

Examples~
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2 c+3 d+4]))
    > =b `(map @tas @)`(malt (limo ~[c+3 d+4 e+5 f+6]))
    > a
    {[p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    > b
    {[p=%e q=5] [p=%d q=4] [p=%f q=6] [p=%c q=3]}
    
    > `(map @tas @)`(~(int by a) b)
    {[p=%d q=4] [p=%c q=3]}
<
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2]))
    > =b `(map @tas @)`(malt (limo ~[a+100 b+200]))
    > a
    {[p=%b q=2] [p=%a q=1]}
    > b
    {[p=%b q=200] [p=%a q=100]}
    
    > `(map @tas @)`(~(int by a) b)
    {[p=%b q=200] [p=%a q=100]}
<


`++jab:by`~

Transform value

Produce map `a` with the value at key `b` transformed by gate `c`.

Accepts~

`a` is a `map`, and is the sample of `+by`.

`b` is a noun, and a key in `a`.

`c` is a `gate`.

Produces~

A `map`.

Source~
>
    ++  jab
      ~/  %jab
      |*  [key=_?>(?=(^ a) p.n.a) fun=$-(_?>(?=(^ a) q.n.a) _?>(?=(^ a) q.n.a))]
      ^+  a
      ::
      ?~  a  !!
      ::
      ?:  =(key p.n.a)
        a(q.n (fun q.n.a))
      ::
      ?:  (gor key p.n.a)
        a(l $(a l.a))
      ::
      a(r $(a r.a))
<

Examples~
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2 c+3 d+4]))
    > a
    {[p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    
    > `(map @tas @)`(~(jab by a) %d |=(x=@ (pow x 2)))
    {[p=%b q=2] [p=%d q=16] [p=%a q=1] [p=%c q=3]}
    
    > (~(jab by a) %z |=(x=@ (pow x 2)))
    dojo: hoon expression failed
    
    > (~(jab by a) %d |=(a=@ [a a]))
    -need.?(%~ [n=[p=@tas q=@] l=nlr([p=@tas q=@]) r=nlr([p=@tas q=@])])
    -have.[n=[p=@tas q=[@ @]] l=nlr([p=@tas q=@]) r=nlr([p=@tas q=@])]
    nest-fail
    dojo: hoon expression failed
<


`++key:by`~

Set of keys

Produces a set of all keys in map `a`.

Accepts~

`a` is a map, and is the sample of `+by`.

Produces~

A set.

Source~
>
    ++  key
      =<  $
      ~/  %key
      =+  b=`(set _?>(?=(^ a) p.n.a))`~
      |.  ^+  b
      ?~  a   b
      $(a r.a, b $(a l.a, b (~(put in b) p.n.a)))
<

Examples~
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2 c+3 d+4]))
    
    > ~(key by a)
    {%b %d %a %c}
<


`++mar:by`~

Add with validation

Produces map `a` with the addition of key-value pair `b` and `c`, where the
value is a nonempty unit.

Accept a noun and a unit of a noun of the type of the map's keys and values,
respectively. Validate that the value is not null and put the pair in the map.
If the value is null, delete the key.

Accepts~

`a` is a `map`, and is the sample of `+by`.

`b` is a noun.

`c` is a `unit`.

Produces~

A map.

Source~
>
    ++  mar
      |*  [b=* c=(unit *)]
      ?~  c
        (del b)
      (put b u.c)
<

Examples~
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2 c+3 d+4]))
    > a
    {[p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    
    > `(map @tas @)`(~(mar by a) %e (some 5))
    {[p=%e q=5] [p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    
    > `(map @tas @)`(~(mar by a) %a (some 10))
    {[p=%b q=2] [p=%d q=4] [p=%a q=10] [p=%c q=3]}
    
    > `(map @tas @)`(~(mar by a) %a ~)
    {[p=%b q=2] [p=%d q=4] [p=%c q=3]}
<


`++put:by`~

Add key-value pair

Produces `a` with the addition of the key-value pair of `b` and `c`.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a key of the same type as the keys in `a`.

`c` is a value of the same type of the values in `a`.

Produces~

A map.

Source~
>
    ++  put
      ~/  %put
      |*  [b=* c=*]
      |-  ^+  a
      ?~  a
        [[b c] ~ ~]
      ?:  =(b p.n.a)
        ?:  =(c q.n.a)
          a
        a(n [b c])
      ?:  (gor b p.n.a)
        =+  d=$(a l.a)
        ?>  ?=(^ d)
        ?:  (mor p.n.a p.n.d)
          a(l d)
        d(r a(l r.d))
      =+  d=$(a r.a)
      ?>  ?=(^ d)
      ?:  (mor p.n.a p.n.d)
        a(r d)
      d(l a(r l.d))
<

Examples~
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2 c+3]))
    > a
    {[p=%b q=2] [p=%a q=1] [p=%c q=3]}
    
    > `(map @tas @)`(~(put by a) %d 4)
    {[p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    
    > `(map @tas @)`(~(put by a) %a 10)
    {[p=%b q=2] [p=%a q=10] [p=%c q=3]}
    
    > (~(put by a) 42 'foo')
    mull-grow
    mull-nice
    -need.?(%~ [n=[p=@tas q=@] l=nlr([p=@tas q=@]) r=nlr([p=@tas q=@])])
    -have.[[@ud @t] %~ %~]
    nest-fail
    dojo: hoon expression failed
<


`++rep:by`~

Reduce to product

Accumulate elements of map `a` using gate `b`, producing a noun.

Accepts~

`a` is a map.

`b` is a gate.

Produces~

A noun.

Source~
>
    ++  rep
      ~/  %rep
      |*  b=_=>(~ |=([* *] +<+))
      |-
      ?~  a  +<+.b
      $(a r.a, +<+.b $(a l.a, +<+.b (b n.a +<+.b)))
<

Examples~
>
    > =a `(map @tas @)`(malt (limo ~[a+1 b+2 c+3 d+4]))
    > a
    {[p=%b q=2] [p=%d q=4] [p=%a q=1] [p=%c q=3]}
    
    > (~(rep by a) |=([p=[@tas @] q=@] ~&([p q] (add +.p q))))
    [[%b 2] 0]
    [[%d 4] 2]
    [[%c 3] 6]
    [[%a 1] 9]
    q=10
<

Discussion~

The gate will iteratively be fed a cell whose head is a key-value pair from
the map and whose tail is an accumulator, producing the final value of the
accumulator.


`++rib:by`~

Transform + product

`c` is a gate with a sample like `[[key value] accumulator]` and a product
like `[accumulator [key value]]`. Each key-value pair in map `a` is passed to
`c` and replaced with the key-value pair `c` produced. The final value of the
accumulator and the modified map are returned. `b` is the initial value of the
accumulator.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a noun, and is the initial value of the accumulator.

`c` is a gate.

Produces~

A cell of a noun and a map.

Source~
>
    ++  rib
      |*  [b=* c=gate]
      |-  ^+  [b a]
      ?~  a  [b ~]
      =+  d=(c n.a b)
      =.  n.a  +.d
      =+  e=$(a l.a, b -.d)
      =+  f=$(a r.a, b -.e)
      [-.f a(l +.e, r +.f)]
<

Examples~

In this example, all values less than three are changed to zero, and a list of
their keys are produced along with the modified map.
>
    > =a `(map @t @)`(malt ~[['a' 1] ['b' 2] ['c' 3] ['d' 4] ['e' 5]])
    > a
    {[p='e' q=5] [p='b' q=2] [p='d' q=4] [p='a' q=1] [p='c' q=3]}
    
    > =c |=  [[k=@t v=@] acc=(list @t)]
         ?:  (lth v 3)
           [[k acc] [k 0]]
         [acc [k v]]
    
    > `[(list @t) (map @t @)]`(~(rib by a) *(list @t) c)
    [<|a b|> {[p='e' q=5] [p='b' q=0] [p='d' q=4] [p='a' q=0] [p='c' q=3]}]
<

Discussion~

Key-value pairs in the map are transformed in their existing tree location.
This means if you change the key, you'd likely produce a map with an incorrect
order, so typically you should only change the value.


`++run:by`~

Transform values

Iterates over every value in map `a` using gate `b`, producing a map.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a gate.

Produces~

A map.

Source~
>
    ++  run
      ~/  %run
      |*  b=gate
      |-
      ?~  a  a
      [n=[p=p.n.a q=(b q.n.a)] l=$(a l.a) r=$(a r.a)]
<

Examples~
>
    > =a `(map @t @)`(malt ~[['a' 1] ['b' 2] ['c' 3] ['d' 4] ['e' 5]])
    
    > `(map @t @)`(~(run by a) dec)
    {[p='e' q=4] [p='b' q=1] [p='d' q=3] [p='a' q=0] [p='c' q=2]}
<


`++rut:by`~

Transform nodes

Applies a gate `b` to nodes in map `a`. The sample of gate `b` is a key-value
pair, and it produces a new value.

Accepts~

`a` is a map, and is the sample of `+by`.

`b` is a gate.

Produces~

A map.

Source~
>
    ++  rut
      |*  b=gate
      |-
      ?~  a  a
      [n=[p=p.n.a q=(b p.n.a q.n.a)] l=$(a l.a) r=$(a r.a)]
<

Examples~
>
    > =a `(map @ @)`(malt ~[[1 1] [2 2] [3 3] [4 4] [5 5]])
    
    > =b |=  [k=@ v=@]
         ?:  (gth v 2)
           (mul k v)
         v
    
    > `(map @ @)`(~(rut by a) b)
    {[p=5 q=25] [p=1 q=1] [p=2 q=2] [p=3 q=9] [p=4 q=16]}
<


`++tap:by`~

Listify pairs

Produces the list of all elements in map `a`.

Accepts~

`a` is a map, and is the sample of `+by`.

Produces~

A list.

Source~
>
    ++  tap
      =<  $
      ~/  %tap
      =+  b=`(list _?>(?=(^ a) n.a))`~
      |.  ^+  b
      ?~  a
        b
      $(a r.a, b [n.a $(a l.a)])
<

Examples~
>
    > =a `(map @ @)`(malt ~[[1 1] [2 2] [3 3] [4 4] [5 5]])
    
    > ~(tap by a)
    ~[[p=4 q=4] [p=3 q=3] [p=2 q=2] [p=1 q=1] [p=5 q=5]]
<


`++uni:by`~

Union, merge

Produces a map of the union between the keys of `a` and `b`. If `b` shares a
key with `a`, the tuple from `b` is preserved.

Accepts~

`a` is a map, and is the sample `+by`.

`b` is a map.

Produces~

A map.

Source~
>
    ++  uni
      ~/  %uni
      =+  b=a
      |@
      ++  $
        |-  ^+  a
        ?~  b
          a
        ?~  a
          b
        ?:  =(p.n.b p.n.a)
          b(l $(a l.a, b l.b), r $(a r.a, b r.b))
        ?:  (mor p.n.a p.n.b)
          ?:  (gor p.n.b p.n.a)
            $(l.a $(a l.a, r.b ~), b r.b)
          $(r.a $(a r.a, l.b ~), b l.b)
        ?:  (gor p.n.a p.n.b)
          $(l.b $(b l.b, r.a ~), a r.a)
        $(r.b $(b r.b, l.a ~), a l.a)
      --
<

Examples~
>
    > =a `(map @ @)`(malt ~[[1 1] [2 2] [3 3]])
    > =b `(map @ @)`(malt ~[[3 300] [4 400] [5 500]])
    > a
    {[p=1 q=1] [p=2 q=2] [p=3 q=3]}
    > b
    {[p=5 q=500] [p=3 q=300] [p=4 q=400]}
    
    > `(map @ @)`(~(uni by a) b)
    {[p=5 q=500] [p=1 q=1] [p=2 q=2] [p=3 q=300] [p=4 q=400]}
<


`++uno:by`~

General union

Produces a map of the union between the keys of `a` and `b`. If `b` shares a
key with `a`, gate `meg` is applied to both and its product is used as the new
value of the key in question.

Accepts~

`a` is a `map`, and is the sample of `+by`.

`b` is a `map`, and is the sample of `~(uno by a)`.

`meg` is a gate, and is the sample of `(~(uno by a) b)`.

Produces~

A `map`.

Source~
>
    ++  uno
      =+  b=a
      |@
      ++  $
        |=  meg=$-([_p:node _q:node _q:node] _q:node)
        |-  ^+  a
        ?~  b
          a
        ?~  a
          b
        ?:  =(p.n.b p.n.a)
          :+  [p.n.a (meg p.n.a q.n.a q.n.b)]
            $(b l.b, a l.a)
          $(b r.b, a r.a)
        ?:  (mor p.n.a p.n.b)
          ?:  (gor p.n.b p.n.a)
            $(l.a $(a l.a, r.b ~), b r.b)
          $(r.a $(a r.a, l.b ~), b l.b)
        ?:  (gor p.n.a p.n.b)
          $(l.b $(b l.b, r.a ~), a r.a)
        $(r.b $(b r.b, l.a ~), a l.a)
      --
<

Examples~
>
    > =a `(map @ @)`(malt ~[[1 1] [2 2] [3 3]])
    > =b `(map @ @)`(malt ~[[3 3] [4 4] [5 5]])
    > a
    {[p=1 q=1] [p=2 q=2] [p=3 q=3]}
    > b
    {[p=5 q=5] [p=3 q=3] [p=4 q=4]}
    
    > `(map @ @)`((~(uno by a) b) |=([k=@ v=@ w=@] (add v w)))
    {[p=5 q=5] [p=1 q=1] [p=2 q=2] [p=3 q=6] [p=4 q=4]}
<


`++urn:by`~

Turn (with key)

Iterates over every value in map `a` using gate `b`, which accepts both the
key and the value of each element as its sample.

Accepts~

`a` is a map.

`b` is a gate that accepts two nouns.

Produces~

A `map`.

Source~
>
    ++  urn
      ~/  %urn
      |*  b=$-([* *] *)
      |-
      ?~  a  ~
      a(n n.a(q (b p.n.a q.n.a)), l $(a l.a), r $(a r.a))
<

Examples~
>
    > =a `(map @ @)`(malt ~[[1 1] [2 2] [3 3]])
    > a
    {[p=1 q=1] [p=2 q=2] [p=3 q=3]}
    
    > (~(urn by a) |=([k=@ v=@] (pow v 2)))
    {[p=1 q=1] [p=2 q=4] [p=3 q=9]}
<


`++wyt:by`~

Depth

Produce the depth of the tree map `a`.

Accepts~

`a` is a map, and is the sample of `+by`.

Produces~

An atom.

Source~
>
    ++  wyt
      =<  $
      ~%  %wyt  +  ~
      |.  ^-  @
      ?~(a 0 +((add $(a l.a) $(a r.a))))
<

Examples~
>
    > =a `(map @ @)`(malt ~[[1 1] [2 2] [3 3]])
    > =b `(map @ @)`(malt ~[[1 1] [2 2] [3 3] [4 4] [5 5]])
    > a
    {[p=1 q=1] [p=2 q=2] [p=3 q=3]}
    > b
    {[p=5 q=5] [p=1 q=1] [p=2 q=2] [p=3 q=3] [p=4 q=4]}
    
    > ~(wyt by a)
    3
    
    > ~(wyt by b)
    5
<


`++val:by`~

List of values

Produces a list of all values in map `a`.

Accepts~

`a` is a map.

Produces~

A list.

Source~
>
    ++  val
      =+  b=`(list _?>(?=(^ a) q.n.a))`~
      |-  ^+  b
      ?~  a   b
      $(a r.a, b [q.n.a $(a l.a)])
<

Examples~
>
    > =a `(map @t @)`(malt ~[['a' 1] ['b' 2] ['c' 3]])
    > a
    {[p='b' q=2] [p='a' q=1] [p='c' q=3]}
    
    > ~(val by a)
    ~[3 1 2]
<



==============================================================================
 2j: Jar and Jug Logic                                                                         

------------------------------------------------------------------------------
JA                                                                  *++ja*

Jar engine

A container arm for `jar` operation arms. A `jar` is a `map` of `list`s. The
contained arms inherit the sample jar.

Accepts~

`a` is a jar.

Produces~

A core.

Source~
>
    ++  ja
      =|  a=(tree (pair * (list)))  ::  (jar)
      |@
<

Examples~
>
    > ~(. ja (my [a+1 b+2 ~]))
    < 2.ngd
      [   a
        ?(
          %~
          [ n=[?(p=%a p=%b) q=@ud]
            l=nlr([p=?(%a %b) q=@ud])
            r=nlr([p=?(%a %b) q=@ud])
          ]
        )
        <123.zao 46.hgz 1.pnw %140>
      ]
    >
<


`++get:ja`~

Grab value by key

Produces the list at key `b` in jar `a`.

Accepts~

`a` is a `jar`, and is the sample of `+ja`.

`b` is a noun.

Produces~

A `list`.

Source~
>
    ++  get
      |*  b=*
      =+  c=(~(get by a) b)
      ?~(c ~ u.c)
<

Examples~
>
    > =j `(jar @t @ud)`(malt ~[['a' `(list @ud)`~[1 2 3]] ['b' `(list @ud)`~[4 5 6]]])
    > j
    {[p='b' q=~[4 5 6]] [p='a' q=~[1 2 3]]}
    
    > `(list @ud)`(~(get ja j) 'a')
    ~[1 2 3]
    
    > `(list @ud)`(~(get ja j) 'b')
    ~[4 5 6]
    
    > `(list @ud)`(~(get ja j) 'c')
    ~
<


`++add:ja`~

Prepend to list

Adds `c` to the head of the list at key `b` in jar `a`. If `b` does not exist
in `a`, a new key-value pair is added with a list containing `c`.

Accepts~

`a` is a `jar`, and is the sample of `+ja`.

`b` is a noun of the same type as the keys in `a`.

`c` is a noun of the same type the lists in `a` contain.

Produces~

A `jar`.

Source~
>
    ++  add
      |*  [b=* c=*]
      =+  d=(get b)
      (~(put by a) b [c d])
<

Examples~
>
    > =j `(jar @t @ud)`(malt ~[['a' `(list @ud)`~[1 2 3]] ['b' `(list @ud)`~[4 5 6]]])
    > j
    {[p='b' q=~[4 5 6]] [p='a' q=~[1 2 3]]}
    
    > `(jar @t @ud)`(~(add ja j) 'b' 7)
    {[p='b' q=~[7 4 5 6]] [p='a' q=~[1 2 3]]}
    
    > `(jar @t @ud)`(~(add ja j) 'c' 8)
    {[p='b' q=~[4 5 6]] [p='a' q=~[1 2 3]] [p='c' q=~[8]]}
<


------------------------------------------------------------------------------
JU                                                                  *++ju*

Jug operations

Container arm for jug operation arms. A `jug` is a `map` of `set`s. The
contained arms inherit its sample jug, `a`.

Accepts~

`a` is a `jug`.

Produces~

A core.

Source~
>
    ++  ju
      =|  a=(tree (pair * (tree)))  ::  (jug)
      |@
<

Example~
>
    > =j `(jug @t @ud)`(malt ~[['a' (silt ~[1 2 3])] ['b' (silt ~[4 5 6])]])
    > j
    {[p='b' q={5 6 4}] [p='a' q={1 2 3}]}
    
    > ~(. ju j)
    <5.cws [a=nlr([p=@t q=nlr(@ud)]) <123.zao 46.hgz 1.pnw %140>]>
<


`++del:ju`~

Remove

Produces jug `a` with value `c` removed from set located at key `b`.

Accepts~

`a` is a jug, and is the sample of `+ju`.

`b` is a noun of the same type as the keys in `a`.

`c` is a noun of the same type as the sets in `a` contain.

Source~
>
    ++  del
      |*  [b=* c=*]
      ^+  a
      =+  d=(get b)
      =+  e=(~(del in d) c)
      ?~  e
        (~(del by a) b)
      (~(put by a) b e)
<

Examples~
>
    > j
    {[p='b' q={5 6 4}] [p='a' q={1 2 3}]}
    
    > `(jug @t @ud)`(~(del ju j) 'b' 6)
    {[p='b' q={5 4}] [p='a' q={1 2 3}]}
    
    > `(jug @t @ud)`(~(del ju j) 'b' 10)
    {[p='b' q={5 6 4}] [p='a' q={1 2 3}]}
    
    > `(jug @t @ud)`(~(del ju j) 'c' 10)
    {[p='b' q={5 6 4}] [p='a' q={1 2 3}]}
<


`++gas:ju`~

Concatenate

Add each of the key-value pairs in list `b` to jug `a`. The values in `b` are
the type the sets in `a` contain. For keys in `b` that exist in `a`, the
values will be added to their sets. For keys in `b` that don't exist in `a`,
new keys and sets will be added.

Accepts~

`a` is a `jug`, and is the sample of `+ju`.

`b` is a `(list [p q])`, where:

- `p` is a noun, the type of the keys in `a`.
- `q` is a noun, the type the sets in `a` contain.


Produces~

A `jug`.

Source~
>
    ++  gas
      |*  b=(list [p=* q=*])
      =>  .(b `(list _?>(?=([[* ^] ^] a) [p=p q=n.q]:n.a))`b)
      |-  ^+  a
      ?~  b
        a
      $(b t.b, a (put p.i.b q.i.b))
<

Examples~
>
    > =j `(jug @t @ud)`(malt ~[['a' (silt ~[1 2 3])] ['b' (silt ~[4 5 6])]])
    > j
    {[p='b' q={5 6 4}] [p='a' q={1 2 3}]}
    
    > `(jug @t @ud)`(~(gas ju j) ~[['a' 10] ['a' 42] ['b' 999] ['c' 7]])
    {[p='b' q={5 6 4 999}] [p='a' q={10 42 1 2 3}] [p='c' q={7}]}
<


`++get:ju`~

Retrieve set

Produces a set retrieved from jug `a` using key `b`.

Accepts~

`a` is a jug, and the sample of `+ju`.

`b` is key, a noun of the same type as the keys in `a`.

Produces~

A `set`.

Source~
>
    ++  get
      |*  b=*
      =+  c=(~(get by a) b)
      ?~(c ~ u.c)
<

Examples~
>
    > =j `(jug @t @ud)`(malt ~[['a' (silt ~[1 2 3])] ['b' (silt ~[4 5 6])]])
    > j
    {[p='b' q={5 6 4}] [p='a' q={1 2 3}]}
    
    > `(set @ud)`(~(get ju j) 'a')
    {1 2 3}
    
    > `(set @ud)`(~(get ju j) 'b')
    {5 6 4}
    
    > `(set @ud)`(~(get ju j) 'c')
    {}
<


`++has:ju`~

Check contents

Computes whether a value `c` exists within the set located at key `b` with jug
`a`, producing a flag.

Accepts~

`a` is a `jug`, and the sample of `+ju`.

`b` is a noun of the same type as the keys in `a`.

`c` is a noun of the same type as the sets in `a` contain.

Produces~

A `?`.

Source~
>
    ++  has
      |*  [b=* c=*]
      ^-  ?
      (~(has in (get b)) c)
<

Examples~
>
    > =j `(jug @t @ud)`(malt ~[['a' (silt ~[1 2 3])] ['b' (silt ~[4 5 6])]])
    > j
    {[p='b' q={5 6 4}] [p='a' q={1 2 3}]}
    
    > (~(has ju j) 'b' 5)
    %.y
    
    > (~(has ju j) 'b' 10)
    %.n
    
    > (~(has ju j) 'c' 10)
    %.n
<


`++put:ju`~

Add key-set pair

Produces jug `a` with `c` added to the set located at key `b`. If `b` isn't a
key in `a`, it will be added and a new set created containing `c`.

Accepts~

`a` is a `jug`.

`b` is a noun, the type of the keys in `a`.

`c` is a noun, the type the sets in `a` contain.

Produces~

A `jug`.

Source~
>
    ++  put
      |*  [b=* c=*]
      ^+  a
      =+  d=(get b)
      (~(put by a) b (~(put in d) c))
<

Examples~
>
    > j
    {[p='b' q={5 6 4}] [p='a' q={1 2 3}]}
    
    > `(jug @t @ud)`(~(put ju j) 'c' 5)
    {[p='b' q={5 6 4}] [p='a' q={1 2 3}] [p='c' q={5}]}
    
    > `(jug @t @ud)`(~(put ju j) 'a' 4)
    {[p='b' q={5 6 4}] [p='a' q={1 2 3 4}]}
    
    > `(jug @t @ud)`(~(put ju j) 'a' 1)
    {[p='b' q={5 6 4}] [p='a' q={1 2 3}]}
<



==============================================================================
 2k: Queue Logic                                                                         

------------------------------------------------------------------------------
TO                                                                  *++to*

Queue operations

Container arm for queue operation arms. The contained arms inherit `a`, its
sample queue.

Accepts~

`a` is a tree.

Source~
>
    ++  to
      =|  a=(tree)  ::  (qeu)
      |@
<

Discussion~

`tree` is the generic tree-shape mold. Maps, sets, and queues all share that
shape, but they put their elements in different places and have different
interfaces. `to` is the interface core for `qeu`; it's not generic across all
the different containers that use `tree`.


`+apt:to`~

Check correctness

Test whether queue `a` is correctly ordered, producing a flag.

Accepts~

`a` is a `que`.

Produces~

A `?`.

Source~
>
    ++  apt
      |-  ^-  ?
      ?~  a  &
      ?&  ?~(l.a & ?&((mor n.a n.l.a) $(a l.a)))
          ?~(r.a & ?&((mor n.a n.r.a) $(a r.a)))
      ==
<

Examples~
>
    > =bad `(qeu @ud)`[1 ~ 2 ~ 3 ~ ~]
    
    > ~(apt to bad)
    %.n
<
>
    > =good `(qeu @ud)`(~(gas to `(qeu @ud)`~) ~[1 2 3])
    
    > ~(apt to good)
    %.y
<


`++bal:to`~

Balance

Vertically rebalances queue `a`.

Accepts~

`a` is a `qeu`.

Produces~

A `qeu`.

Source~
>
    ++  bal
      |-  ^+  a
      ?~  a  ~
      ?.  |(?=(~ l.a) (mor n.a n.l.a))
        $(a l.a(r $(a a(l r.l.a))))
      ?.  |(?=(~ r.a) (mor n.a n.r.a))
        $(a r.a(l $(a a(r l.r.a))))
      a
<

Examples~
>
    > =a `(qeu @ud)`[1 ~ 2 ~ 3 ~ ~]
    > a
    {1 2 3}
    > `*`a
    [1 0 2 0 3 0 0]
    > ~(apt to a)
    %.n
    
    > =z `(qeu @ud)`~(bal to a)
    > z
    {1 2 3}
    > `*`z
    [2 [1 0 0] 3 0 0]
    > ~(apt to z)
    %.y
<


`++dep:to`~

Maximum Depth

Produces the maximum depth of leaves (`r.a` and `l.a`) in queue `a`.

Accepts~

`a` is a queue.

Produces~

An atom.

Source~
>
    ++  dep
      |-  ^-  @
      ?~  a  0
      +((max $(a l.a) $(a r.a)))
<

Examples~
>
    > =a (~(gas to `(qeu @)`~) `(list @)`[1 2 3 4 5 6 7 ~])
    > ~(dep to a)
    4
    
    > =a (~(gas to `(qeu @)`~) `(list @)`[1 2 3 4 ~])
    > ~(dep to a)
    3
    
    > =a (~(gas to `(qeu @)`~) `(list @)`[1 2 ~])
    > ~(dep to a)
    2
    
    > ~(dep to `(qeu tape)`["a" ~ "b" ~ "c" ~ "d" ~ "e" ~ "f" ~ "g" ~ ~])
    7
    
    > ~(dep to ~(bal to `(qeu tape)`["a" ~ "b" ~ "c" ~ "d" ~ "e" ~ "f" ~ "g" ~ ~]))
    4
<


`++gas:to`~

Push list

Push all elements of list `b` into the queue `a`.

Accepts~

`a` is a queue, and is the sample of `+to`.

`b` is a list.

Produces~

A queue.

Source~
>
    ++  gas
      |=  b=(list _?>(?=(^ a) n.a))
      |-  ^+  a
      ?~(b a $(b t.b, a (put i.b)))
<

Examples~
>
    > `(qeu)`(~(gas to `(qeu @)`~) [1 2 3 ~])
    {3 2 1}
    
    > =a (~(gas to `(qeu @)`~) [1 2 3 ~])
    > =b [4 5 6 ~]
    > `(qeu)`(~(gas to a) b)
    {6 5 4 3 2 1}
<


`++get:to`~

Head-tail pair

Produces the head and tail queue of `a`.

Accepts~

`a` is a queue.

Produces~

A cell of the last element in `a` along with the rest of queue `a`.

Source~
>
    ++  get
      |-  ^+  ?>(?=(^ a) [p=n.a q=*(tree _n.a)])
      ?~  a
        !!
      ?~  r.a
        [n.a l.a]
      =+  b=$(a r.a)
      :-  p.b
      ?:  |(?=(~ q.b) (mor n.a n.q.b))
        a(r q.b)
      a(n n.q.b, l a(r l.q.b), r r.q.b)
<

Examples~
>
    > =s (~(gas to *(tree @)) `(list @)`~[1 2 3])
    > ~(get to s)
    [n=2 l={3} r={1}]
    
    > ~(get to ~)
    ! exit
<


`++nap:to`~

Remove head

Removes the head of queue `a`, producing the resulting queue.

Accepts~

`a` is a queue.

Produces~

A queue.

Source~
>
    ++  nap
      ?>  ?=(^ a)
      ?:  =(~ l.a)  r.a
      =+  b=get(a l.a)
      bal(n.a p.b, l.a q.b)
<

Examples~
>
    > =a (~(gas to `(qeu @)`~) `(list @)`[1 2 3 4 5 6 ~])
    > -.a
    n=6
    
    > =b ~(nap to a)
    > -.b
    n=2
    
    > a
    [n=6 l={} r={5 4 3 2 1}]
    
    > b
    [n=2 l=[n=4 l={5} r={3}] r=[n=1 l={} r={}]]
    
    > `(qeu)`b
    {5 4 3 2 1}
    
    > `(qeu)`a
    {6 5 4 3 2 1}
<


`++nip:to`~

Removes the root of queue `a`, producing the resulting queue.

Accepts~

`a` is a queue.

Produces~

A queue.

Source~
>
    ++  nip
      |-  ^+  a
      ?~  a  ~
      ?~  l.a  r.a
      ?~  r.a  l.a
      ?:  (mor n.l.a n.r.a)
        l.a(r $(l.a r.l.a))
      r.a(l $(r.a l.r.a))
<

Examples~
>
    > =a (~(gas to `(qeu @)`~) `(list @)`[1 2 3 4 5 6 ~])
    > a
    [n=6 l={} r={5 4 3 2 1}]
    
    > ~(nip to a)
    [n=2 l=[n=4 l={5} r={3}] r=[n=1 l={} r={}]]
<


`++put:to`~

Insert

Accept noun `b` and adds to queue `a` as the head, producing the resulting
queue.

Accepts~

`a` is a queue, and is the sample of `+to`.

`b` is a noun.

Produces~

A queue.

Source~
>
    ++  put
      |*  b=*
      |-  ^+  a
      ?~  a
        [b ~ ~]
      bal(l.a $(a l.a))
<

Examples~
>
    > =a (~(gas to `(qeu @)`~) `(list @)`[3 1 2 4 5 6 ~])
    > `(qeu)`(~(put to a) 7)
    {7 6 5 4 2 1 3}
<


`++tap:to`~

Queue to list

Produces queue `a` as a list from front to back.

Accepts~

`a` is a queue.

Produces~

A list.

Source~
>
    ++  tap
      =+  b=`(list _?>(?=(^ a) n.a))`~
      |-  ^+  b
      =+  0                                   ::  hack for jet match
      ?~  a
        b
      $(a r.a, b [n.a $(a l.a)])
<

Examples~
>
    > =a (~(gas to `(qeu @)`~) [3 1 2 4 5 6 ~])
    > `*`a
    [6 0 2 [4 [5 0 0] 0] 1 0 3 0 0]
    
    > ~(tap to a)
    ~[3 1 2 4 5 6]
<


`++top:to`~

Produce head

Produces the head of queue `a` as a `unit`.

Accepts~

`a` is a queue.

Produces~

A unit.

Source~
>
    ++  top
      |-  ^-  (unit _?>(?=(^ a) n.a))
      ?~  a  ~
      ?~(r.a [~ n.a] $(a r.a))
<

Examples~
>
    > =a (~(gas to `(qeu @)`~) `(list @)`[1 2 3 4 5 6 ~])
    > ~(top to a)
    [~ u=1]
<

Discussion~

An empty queue has no head.



==============================================================================
 2l: Container from Container                                                                         

------------------------------------------------------------------------------
MALT                                                                  *++malt*

Map from list

Produces a map from a list `a`.

Accepts~

`a` is a list.

Produces~

A map.

Source~
>
    ++  malt                                                ::  map from list
      |*  a=(list)
      (molt `(list [p=_-<.a q=_->.a])`a)
<

Examples~
>
        > (malt [['ok' 'no'] ['a' 'b'] ['x' 'y'] ~])
        [n=[p='x' q='y'] l={[p='a' q='b'] [p='ok' q='no']} r={}]
    
        > (malt ~[[1 2 3] [4 5 6] [7 8 9]])
        [n=[p=1 q=[2 3]] l={[p=4 q=[5 6]] [p=7 q=[8 9]]} r={}]
<


------------------------------------------------------------------------------
MOLT                                                                  *++molt*

Map from pair list

Produces a map from a list of pairs `a`.

Accepts~

`a` is a list of pairs.

Produces~

A map.

Source~
>
        ++  molt
          |*  a=(list (pair))
          (~(gas by `(tree [p=_p.i.-.a q=_q.i.-.a})`~) a)
<

Examples~
>
        > =a `(list (pair))`[[1 2] [4 3] [11 0] ~]
        > a
        > ~[[p=1 q=2] [p=4 q=3] [p=11 q=0]]
    
        > (molt a)
        [n=[p=11 q=0] l={[p=4 q=3] [p=1 q=2]} r={}]
<

Discussion~

Only used internally as a helper to `malt`.


------------------------------------------------------------------------------
SILT                                                                  *++silt*

Set from list

Produces a set from a list `a`.

Accepts~

`a` is a list.

Produces~

A set.

Source~
>
        ++  silt
          |*  a=(list)
          =+  b=*(tree _?>(?=(^ a) i.a))
          (~(gas in b) a)
<

Examples~
>
        > (silt `(list @t)`['c' 'hoon' 'javascript' 'python' ~])
        [n='javascript' l={} r={'python' 'hoon' 'c'}]
<



==============================================================================
 2m: Container from Noun                                                                         

------------------------------------------------------------------------------
LY                                                                  *++ly*

List from raw noun

Takes a null-terminated noun and produces a `list`.

Accepts~

`a` is a null-terminated noun.

Produces~

A `list`.

Source~
>
        ++  ly
          le:nl
<

Examples~
>
        > (ly [1 2 3 ~])
        ~[1 2 3]
    
        > (ly "abc")
        ~['a' 'b' 'c']
<

Discussion~

`ly` is an alias for `le:nl`.


------------------------------------------------------------------------------
MY                                                                  *++my*

Map from raw noun

Takes a null-terminated noun and produces a `map.`

Accepts~

`a` is a noun composed of ordered pairs and terminated with `~`.

Produces~

A `map`.

Source~
>
        ++  my
          my:nl
<

Examples~
>
        > (my [['a' 1] ['b' 2] ~])
        [n=[p='b' q=2] l={[p='a' q=1]} r={}]
<

Discussion~

`my` is an alias for `my:nl`.


------------------------------------------------------------------------------
SY                                                                  *++sy*

Set from raw noun

Takes a null-terminated noun and produces a `set`.

Accepts~

`a` is a null-terminated noun.

Produces~

A `set`.

Source~
>
        ++  sy
          si:nl
<

Examples~
>
        > (sy [1 2 3 ~])
        [n=2 l={1 3} r={}]
    
        > (sy (ly [1 2 3 ~]))
        [n=2 l={1 3} r={}]
    
        > (sy "abc")
        [n='b' l={'a' 'c'} r={}]
<

Discussion~

`sy` is an alias for `si:nl`.


------------------------------------------------------------------------------
NL                                                                  *++nl*

Noun-to-container operations

Core whose arms contain functions that create various typed nouns from raw
nouns.

Source~
>
        ++  nl
          |%
<


`++le:nl`~

Construct list

Takes a null-terminated noun and produces a `list`.

Accepts~

`a` is a null-terminated noun.

Produces~

A list.

Source~
>
    ++  le
      |*  a=(list)
      ^+  =<  $
        |@  ++  $  ?:(*? ~ [i=(snag 0 a) t=$])
        --
      a
<

Examples~
>
        > (le:nl [1 2 3 ~])
        ~[1 2 3]
    
        > (le:nl "abc")
        ~['a' 'b' 'c']
<


`++my:nl`~

Construct map

Takes a null-terminated noun and produces a `map` of the same type of the `p`
and `q` passed in.

Accepts~

`a` is a noun composed of ordered pairs and terminated with `~`.

Produces~

A map.

Source~
>
    ++  my
      |*  a=(list (pair))
      =>  .(a ^+((le a) a))
      (~(gas by `(map _p.i.-.a _q.i.-.a)`~) a)
<

Examples~
>
        > (my:nl [['a' 1] ['b' 2] ~])
        [n=[p='b' q=2] l={[p='a' q=1]} r={}]
<


`++si:nl`~

Construct set

Takes a null-terminated noun and produces a `set`.

Accepts~

`a` is a null-terminated noun.

Produces~

A set.

Source~
>
    ++  si
      |*  a=(list)
      =>  .(a ^+((le a) a))
      (~(gas in `(set _i.-.a)`~) a)
<

Examples~
>
        > (si:nl `(list [@t *])`[['a' 1] ['b' [2 3]] ~])
        [n=['b' [2 3]] l={['a' 1]} r={}]
<


`++snag:nl`~

Index

Produces the element at the index `a` of null-terminated noun `b` and failing
if the noun is null. Lists are 0-indexed.

Accepts~

`a` is a noun.

`b` is a null-terminated noun.

Produces~

A noun.

Sources~
>
    ++  snag
      |*  [a=@ b=(list)]
      ?~  b
        ~_  leaf+"snag-fail"
        !!
      ?:  =(0 a)  i.b
      $(b t.b, a (dec a))
<

Examples~
>
        > =b [[2 3] [1 4] ~]
        > (snag:nl 0 b)
        [2 3]
    
        > (snag:nl 2 b)
        ! snag-fail
        ! exit
<


`++weld:nl`~

Concatenate

Produces a list that is the concatenation of null-terminated nouns `a` and
`b`.

Accepts~

`a` is a null-terminated noun.

`b` is a null-terminated noun.

Produces~

A list.

Source~
>
    ++  weld
      |*  [a=(list) b=(list)]
      =>  .(a ^+((le a) a), b ^+((le b) b))
      =+  42
      |-
      ?~  a  b
      [i=i.a t=$(a t.a)]
<

Examples~
>
        > =b [[2 3] [1 4] ~]
    
        > (weld:nl b [8 9 ~])
        [i=[2 3] t=[i=[1 4] t=~[8 9]]]
<



==============================================================================
 2n: Functional Hacks                                                                         

------------------------------------------------------------------------------
AFTR                                                                  *++aftr*

Pair after

`+aftr` first takes gate `a`, producing a wet gate. The new wet gate then
takes `b`, producing the inverted pair of `[b a]`. This is the inverted
version of +fore.

Accepts~

`a` is a gate, and the sample of `+aftr`.

`b` is a gate, and the sample of `(aftr a)`.

Produces~

`(pair b a)`.

Source~
>
    ++  aftr  |*(a=$-(* *) |*(b=$-(* *) (pair b a)))
<

Examples~
>
    > =a (aftr @ud)
    > `(a @t)`['foo' 42]
    [p='foo' q=42]
<


------------------------------------------------------------------------------
CORK                                                                  *++cork*

Compose forward

Call gate `a`, then call gate `b` with its product.

This is a wet gate that takes two gates and produces a new gate.

This is the inverse of `++corl`.

Accepts~

`a` is a gate.

`b` is a gate.

Source~
>
    ++  cork  |*([a=$-(* *) b=$-(* *)] (corl b a))
<

Examples~
>
    > ((cork dec |=(a=@ [a a])) 20)
    [19 19]
    
    > ((cork dec some) 20)
    [~ u=19]
<


------------------------------------------------------------------------------
CORL                                                                  *++corl*

Compose backward

Call gate `b`, then call gate `a` with its product.

This is a wet gate that takes two gates and produces a new gate.

This is the inverse of `++cork`.

Accepts~

`a` is a gate.

`b` is a gate.

Source~
>
    ++  corl
      |*  [a=$-(* *) b=$-(* *)]
      =<  +:|.((a (b)))      ::  type check
      =+  c=+<.b
      |@  ++  $  (a (b c))
      --
<

Examples~
>
    > ((corl |=(a=@ [a a]) dec) 20)
    [19 19]
    
    > ((corl some dec) 20)
    [~ u=19]
<


------------------------------------------------------------------------------
CURR {% #CURRY %}                                                                  *++curr {% #curry %}*

Right curry

Right-curry a gate, binding the tail of its sample

Accepts~

`a` is a gate.

`c` is a noun.

Produces~

A gate.

Source~
>
    ++  curr
      |*  [a=$-(^ *) c=*]
      =+  b=+<+.a
      |@  ++  $  (a b c)
      --
<

Examples~
>
        > =tep (curr scan sym)
        > `@t`(tep "asd")
        'asd'
    
        > `@t`(tep "lek-om")
        'lek-om'
<


------------------------------------------------------------------------------
CURY                                                                  *++cury*

Curry left

Curry a gate, binding the head of its sample

Accepts~

`a` is a gate.

`b` is a noun.

Produces~

A gate.

Source~
>
    ++  cury
      |*  [a=$-(^ *) b=*]
      =+  c=+<+.a
      |@  ++  $  (a b c)
      --
<

Examples~
>
        > =mol (cury add 2)
        > (mol 4)
        6
    
        > (mol 7)
        9
<


------------------------------------------------------------------------------
FORE                                                                  *++fore*

Pair before

`+fore` first takes gate `a`, producing a wet gate. The new wet gate then
takes `b`, producing the pair of `[a b]`.

Accepts~

`a` is a gate, and is the sample of `+fore`.

`b` is a gate, and is the sample of `(fore a)`.

Produces~

`(pair a b)`.

Source~
>
    ++  fore  |*(a=$-(* *) |*(b=$-(* *) (pair a b)))
<

Examples~
>
    > =a (fore @ud)
    > `(a @t)`[42 'foo']
    [p=42 q='foo']
<


------------------------------------------------------------------------------
HEAD                                                                  *++head*

Get head

Produces the head of a cell.

Accepts~

A cell.

Produces~

A noun.

Source~
>
    ++  head  |*(^ ,:+<-)
<

Examples~
>
    > (head [1 2])
    1
    
    > (head [[1 1] 2])
    [1 1]
    
    > (head "hello")
    'h'
<


------------------------------------------------------------------------------
SAME                                                                  *++same*

Identity

Produces the same value that it was given.

Accepts~

A noun.

Produces~

A noun.

Source~
>
    ++  same  |*(* +<)
<

Examples~
>
    > (same [1 2])
    [1 2]
    
    > (same [[1 1] 2])
    [[1 1] 2]
    
    > (same "hello")
    "hello"
<


------------------------------------------------------------------------------
SUCC                                                                  *++succ*

Successor

Increment an atom.

Accepts~

An `atom`.

Produces~

An `atom`.

Source~
>
    ++  succ  |=(@ +(+<))
<

Examples~
>
    > (succ 1)
    2
<


------------------------------------------------------------------------------
TAIL                                                                  *++tail*

Get tail

Produces the tail of a cell.

Accepts~

A cell.

Produces~

A noun.

Source~
>
    ++  tail  |*(^ ,:+<+)
<

Examples~
>
        > (tail [1 2])
        2
    
        > (tail [[1 1] 2])
        2
    
        > (tail "hello")
        "ello"
<


------------------------------------------------------------------------------
TEST                                                                  *++test*

Test for equality

Checks if `a` and `b` are equal, producing a flag.

Accepts~

`a` is a noun.

`b` is a noun.

Produces~

A flag.

Source~
>
    ++  test  |=(^ =(+<- +<+))
<

Examples~
>
        > (test 1 1)
        %.y
    
        > (test [2 0] 2)
        %.n
    
        > (test "hello" 'hello')
        %.n
    
        > (test "hello" ['h' 'e' 'l' 'l' 'o' ~])
        %.y
<


------------------------------------------------------------------------------
LEAD                                                                  *++lead*

Put head

`(lead a)` produces a wet gate, then `((lead a) b)` produces `[a b]`.

Accepts~

`a` is a noun, and is the sample of `+lead`.

`b` is a noun, and is the sample of `((lead a) b)`

Produces~

A cell of `[a b]`.

Source~
>
    ++  lead  |*(* |*(* [+>+< +<]))
<

Examples~
>
    > =a (lead 'foo')
    > (a 'bar')
    ['foo' 'bar']
<


------------------------------------------------------------------------------
LATE                                                                  *++late*

Put tail

`(late a)` produces a wet gate, then `((late a) b)` produces the inverted cell
`[b a]`. This is the inverted version of +lead.

Accepts~

`a` is a noun, and is the sample of `+late`.

`b` is a noun, and is the sample of `(late a)`.

Produces~

A cell of `[b a]`.

Source~
>
    ++  late  |*(* |*(* [+< +>+<]))
<

Examples~
>
    > =a (late 'foo')
    > (a 'bar')
    ['bar' 'foo']
<



==============================================================================
 2o: Normalizing Containers                                                                         

------------------------------------------------------------------------------
JAR                                                                  *++jar*

Mold generator. A `jar` is a `map` of `list`.

Produces the mold of a map from `key` to lists of `value`.

Accepts~

`key` is a `mold`, and is the type of the map key

`value` is a `mold`, and is the type of items in the lists. The lists are the
values in the map.

Produces~

A `mold`.

Source~
>
    ++  jar  |$  [key value]  (map key (list value))
<

Examples~
>
    > `(jar @t @ud)`(malt ~[['foo' ~[1 2 3]] ['bar' ~[4 5 6]]])
    {[p='bar' q=~[4 5 6]] [p='foo' q=~[1 2 3]]}
<

Discussion~

See also: `ja`, `by`, `map`, lists


------------------------------------------------------------------------------
JUG                                                                  *++jug*

Mold generator. A `jug` is a `map` of `set`.

Produces the mold of a map from `key` to sets of `value`.

Accepts~

`key` is a `mold`, and is the type of the map key.

`value` is a `mold`, and is the type of items in the sets. The sets are the
values in the map.

Produces~

A `mold`.

Source~
>
    ++  jug  |$  [key value]  (map key (set value))
<

Examples~
>
    > `(jug @t @ud)`(malt ~[['foo' (silt ~[1 2 3])] ['bar' (silt ~[4 5 6])]])
    {[p='bar' q={5 6 4}] [p='foo' q={1 2 3}]}
<

Discussion~

See also: `ju`, `by`, `map`, `set`


------------------------------------------------------------------------------
MAP                                                                  *++map*

Map

Mold generator. A `map` is a treap of key-value pairs.

Produces the mold of a map from `key` to `value`.

Accepts~

`key` is a `mold`.

`value` is a `mold`.

Produces~

A `mold`.

Source~
>
    ++  map
      |$  [key value]
      $|  (tree (pair key value))
      |=(a=(tree (pair)) ?:(=(~ a) & ~(apt by a)))
<

Examples~
>
    > ? *(map @t @ud)
      nlr([p=@t q=@ud])
    {}
<
>
    > `(map @t @ud)`(malt ~[['foo' 1] ['bar' 2] ['baz' 3]])
    {[p='bar' q=2] [p='baz' q=3] [p='foo' q=1]}
<

Discussion~

See also: `by`


------------------------------------------------------------------------------
QEU                                                                  *++qeu*

Queue

Mold generator. An ordered treap of items.

Produces the mold of a queue of `item`.

Accepts~

`item` is a `mold`.

Produces~

A `mold`.

Source~
>
    ++  qeu
      |$  [item]
      $|  (tree item)
      |=(a=(tree) ?:(=(~ a) & ~(apt to a)))
<

Examples~
>
    > `(qeu @ud)`(~(gas to *(qeu @ud)) ~[1 2 3 4 5])
    {5 4 3 2 1}
<

Discussion~

See also: `+to`


------------------------------------------------------------------------------
SET                                                                  *++set*

Set

Mold generator. A `set` is an unordered treap of items.

Produces the mold of a set of `item`.

Accepts~

`item` is a `mold`.

Produces~

A `mold`.

Source~
>
    ++  set
      |$  [item]
      $|  (tree item)
      |=(a=(tree) ?:(=(~ a) & ~(apt in a)))
<

Examples~
>
    > `(set @ud)`(silt ~[1 2 3 4 5])
    {5 1 2 3 4}
<

Discussion~

See also: `+in`



==============================================================================
 2p: Serialization                                                                         

------------------------------------------------------------------------------
CUE {% #CUE %}                                                                  *++cue {% #cue %}*

Unpack atom to noun

Produces a noun unpacked from atom `a`. The inverse of +jam.

Accepts~

`a` is an atom.

Produces~

A noun.

Source~
>
    ++  cue
      ~/  %cue
      |=  a=@
      ^-  *
      =+  b=0
      =+  m=`(map @ *)`~
      =<  q
      |-  ^-  [p=@ q=* r=(map @ *)]
      ?:  =(0 (cut 0 [b 1] a))
        =+  c=(rub +(b) a)
        [+(p.c) q.c (~(put by m) b q.c)]
      =+  c=(add 2 b)
      ?:  =(0 (cut 0 [+(b) 1] a))
        =+  u=$(b c)
        =+  v=$(b (add p.u c), m r.u)
        =+  w=[q.u q.v]
        [(add 2 (add p.u p.v)) w (~(put by r.v) b w)]
      =+  d=(rub c a)
      [(add 2 p.d) (need (~(get by m) q.d)) m]
<

Examples~
>
    > (jam [1 2 3])
    3.426.417
    
    > (cue 3.426.417)
    [1 2 3]
<


------------------------------------------------------------------------------
JAM {% #JAM %}                                                                  *++jam {% #jam %}*

Pack noun to atom

Produces an atom packed from noun `a`. The inverse of +cue.

Accepts~

`a` is a noun.

Produces~

An atom.

Source~
>
    ++  jam
      ~/  %jam
      |=  a=*
      ^-  @
      =+  b=0
      =+  m=`(map * @)`~
      =<  q
      |-  ^-  [p=@ q=@ r=(map * @)]
      =+  c=(~(get by m) a)
      ?~  c
        =>  .(m (~(put by m) a b))
        ?:  ?=(@ a)
          =+  d=(mat a)
          [(add 1 p.d) (lsh 0 q.d) m]
        =>  .(b (add 2 b))
        =+  d=$(a -.a)
        =+  e=$(a +.a, b (add b p.d), m r.d)
        [(add 2 (add p.d p.e)) (mix 1 (lsh [0 2] (cat 0 q.d q.e))) r.e]
      ?:  ?&(?=(@ a) (lte (met 0 a) (met 0 u.c)))
        =+  d=(mat a)
        [(add 1 p.d) (lsh 0 q.d) m]
      =+  d=(mat u.c)
      [(add 2 p.d) (mix 3 (lsh [0 2] q.d)) m]
<

Examples~
>
    > (jam 1)
    12
    
    > (cue 12)
    1
<
>
    > (jam [1 1])
    817
    
    > (cue 817)
    [1 1]
<
>
    > (jam [~ u=19])
    39.689
    
    > (cue 39.689)
    [0 19]
<


------------------------------------------------------------------------------
MAT                                                                  *++mat*

Length-encode

Produces a cell whose tail `q` is atom `a` with a bit representation of its
length prepended to it (as the least significant bits). The head `p` is the
length of `q` in bits.

Accepts~

`a` is an atom.

Produces~

A cell of two atoms, `p` and `q`.

Source~
>
    ++  mat
      ~/  %mat
      |=  a=@
      ^-  [p=@ q=@]
      ?:  =(0 a)
        [1 1]
      =+  b=(met 0 a)
      =+  c=(met 0 b)
      :-  (add (add c c) b)
      (cat 0 (bex c) (mix (end [0 (dec c)] b) (lsh [0 (dec c)] a)))
<

Examples~
>
    > (mat 0xaaa)
    [p=20 q=699.024]
    
    > (met 0 q:(mat 0xaaa))
    20
    
    > `@ub`q:(mat 0xaaa)
    0b1010.1010.1010.1001.0000
    
    > =a =-(~&(- -) `@ub`0xaaa)
    0b1010.1010.1010
    
    > =b =-(~&(- -) `@ub`(xeb a))
    0b1100
    
    > =b =-(~&(- -) `@ub`(met 0 a))
    0b1100
    
    > =c =-(~&(- -) (xeb b))
    4
    
    > [`@ub`a `@ub`(end 0 (dec c) b) `@ub`(bex c)]
    [0b1010.1010.1010 0b100 0b1.0000]
<

Discussion~

`mat` is only used internally as a helper to `jam`.


------------------------------------------------------------------------------
RUB                                                                  *++rub*

Length-decode

The inverse of `mat`. Accepts a cell of index `a` and a bitstring `b` and
produces the cell whose tail `q` is the decoded atom at index `a` and whose
head is the length of the encoded atom `q`, by which the offset `a` is
advanced.

Accepts~

`a` is an atom.

`b` is a bitstring as an atom.

Produces~

A cell of two atoms, `p` and `q`.

Source~
>
    ++  rub
      ~/  %rub
      |=  [a=@ b=@]
      ^-  [p=@ q=@]
      =+  ^=  c
          =+  [c=0 m=(met 0 b)]
          |-  ?<  (gth c m)
          ?.  =(0 (cut 0 [(add a c) 1] b))
            c
          $(c +(c))
      ?:  =(0 c)
        [1 0]
      =+  d=(add a +(c))
      =+  e=(add (bex (dec c)) (cut 0 [d (dec c)] b))
      [(add (add c c) e) (cut 0 [(add d (dec c)) e] b)]
<

Examples~
>
    > `@ub`(jam 0xaaa)
    0b1.0101.0101.0101.0010.0000
    
    > (rub 1 0b1.0101.0101.0101.0010.0000)
    [p=20 q=2.730]
    
    > `@ux`q:(rub 1 0b1.0101.0101.0101.0010.0000)
    0xaaa
<

Discussion~

`rub` is only used internally as a helper to `cue`.



==============================================================================
 2q: Molds and Mold-Builders                                                                         

------------------------------------------------------------------------------
+$AXIS                                                                  *+$axis*

Tree address

A Nock axis inside a noun. After the leading 1, in binary, a `1` signfies
right and `0` left.

Source~
>
    +$  axis  @
<

Examples~
>
    > =axis `axis`7
    > axis
    7
    > `@ub`axis
    0b111
    
    > =noun [[4 5] [6 14 15]]
    
    > .*(noun [0 axis])
    [14 15]
<


------------------------------------------------------------------------------
+$BEAN                                                                  *+$bean*

Boolean

`0`, `&`, or `%.y` are true, and `1`, `|`, and `%.n` are false.

Note 1 is false and 0 is true. This is sometimes referred to as "loobean".

Source~
>
    +$  bean  ?
<

Examples~
>
    > *bean
    %.y
<
>
    > `bean`&
    %.y
<
>
    > `bean`|
    %.n
<


------------------------------------------------------------------------------
+$FLAG                                                                  *+$flag*

Boolean

Same as $bean.

Source~
>
    +$  flag  ?
<


------------------------------------------------------------------------------
+$CHAR                                                                  *+$char*

Character

A single `@t` character.

Source~
>
    +$  char  @t
<

Examples~
>
    > *char
    ''
<
>
    > `char`'a'
    'a'
<


------------------------------------------------------------------------------
+$CORD                                                                  *+$cord*

UTF-8 text

One of Hoon's two string types (the other being `tape`). A cord is an atom of
UTF-8 text.

Source~
>
    +$  cord  @t
<

Examples~
>
    > *cord
    ''
    
    > `@ux`'foobar'
    0x7261.626f.6f66
    
    > `@t`97
    'a'
    
    > `@`'urbit'
    499.984.265.845
    
    > `@t`499.984.265.845
    'urbit'
<

Discussion~

Aura `@t` designates a Unicode atom, little-endian: the first character in the
text is the least-significant byte.

`trip` converts from `cord` to `tape`, and `crip` converts from `tape` to
`cord`.


------------------------------------------------------------------------------
+$BYTS                                                                  *+$byts*

bytes, LSB first

An atom `dat` with its byte-length specified in `wid`. This is to handle
leading zeros that are typically ignored.

Source~
>
    +$  byts  [wid=@ud dat=@]
<

Examples~
>
    > *byts
    [wid=0 dat=0]
<
>
    > =a `byts`[4 2]
    > a
    [wid=4 dat=2]
    
    > `@ux`(rev 3 a)
    0x200.0000
<


------------------------------------------------------------------------------
+$DATE                                                                  *+$date*

Parsed date

A boolean designating AD or BC, a year atom, a month atom, and a `tarp`, which
is a day atom and a time.

Source~
>
    +$  date  [[a=? y=@ud] m=@ud t=tarp]
<

Examples~
>
    > *date
    [[a=%.y y=0] m=0 t=[d=0 h=0 m=0 s=0 f=~]]
    
    > `date`(yore ~2014.6.6..21.09.15..0a16)
    [[a=%.y y=2.014] m=6 t=[d=6 h=21 m=9 s=15 f=~[0xa16]]]
    
    > now
    ~2018.5.25..17.55.15..9ad8
<

Discussion~

See also: `year`, `yore`


------------------------------------------------------------------------------
+$KNOT                                                                  *+$knot*

ASCII text

An atom type that only permits ASCII characters.

Source~
>
    +$  knot  @ta
<

Examples~
>
    > *knot
    ~.
    
    > `@ta`105
    ~.i
<


------------------------------------------------------------------------------
+$NOUN                                                                  *+$noun*

Any noun

Source~
>
    +$  noun  *
<

Examples~
>
    > *noun
    0
<
>
    > `noun`'foo'
    7.303.014
<
>
    > `noun`"foo"
    [102 111 111 0]
<


------------------------------------------------------------------------------
+$PATH                                                                  *+$path*

Like unix path

A path is a list of `$knot`.

Source~
>
    +$  path  (list knot)
<

Examples~
>
    > *path
    /
<
>
    > `path`"foo"
    /f/o/o
<
>
    > `path`[~.foo ~.bar ~.baz ~]
    /foo/bar/baz
<


------------------------------------------------------------------------------
+$STUD                                                                  *+$stud*

Standard name

Source~
>
    +$  stud                    ::  standard name
              $@  mark=@tas     ::  auth=urbit
              $:  auth=@tas     ::  standards authority
                  type=path     ::  standard label
              ==                ::
<


------------------------------------------------------------------------------
+$TANG                                                                  *+$tang*

Bottom-first error

A list of `tank`s. It's for printing types and bottom-up printing of stack
traces.

Source~
>
    +$  tang  (list tank)
<

Examples~
>
    > *tang
    ~
<
>
    > %-  %-  slog
          ^-  tang
          :~  'foo'
              leaf+"bar"
              [%palm ["|" "(" "!" ")"] leaf+"foo" leaf+"bar" leaf+"baz" ~]
              [%rose [" " "[" "]"] leaf+"foo" leaf+"bar" leaf+"baz" ~]
          ==
    foo
    bar
    (!foo|bar|baz)
    [foo bar baz]
      ~
    ~
<


------------------------------------------------------------------------------
+$TANK                                                                  *+$tank*

Formatted print tree

A `tank` is one of four cases:

- just a `cord`.
- `%leaf` is just a `tape`.
- `%palm` is a list of `tank` delimited by the strings in `p`, with back-steps
at new lines.
- `%rose` is a list of `tank` delimited by the strings in `p` without back-steps
at new lines.


Source~
>
    +$  tank
      $~  leaf/~
      $@  cord
      $%  [%leaf p=tape]
          [%palm p=(qual tape tape tape tape) q=(list tank)]
          [%rose p=(trel tape tape tape) q=(list tank)]
      ==
<

Examples~
>
    > *tank
    [%leaf p=""]
<
>
    > ~(ram re 'foobar')
    "foobar"
<
>
    > ~(ram re leaf+"foo")
    "foo"
<
>
    > ~(ram re [%palm ["|" "(" "!" ")"] leaf+"foo" leaf+"bar" leaf+"baz" ~])
    "(!foo|bar|baz)"
<
>
    > ~(ram re [%rose [" " "[" "]"] leaf+"foo" leaf+"bar" leaf+"baz" ~])
    "[foo bar baz]"
<


------------------------------------------------------------------------------
+$TAPE                                                                  *+$tape*

List of characters

One of Hoon's two string types, the other being `+cord`. A tape is a list of
`@tD`.

Source~
>
    +$  tape  (list @tD)
<

Examples~
>
    > *tape
    ""
    
    > `tape`"foobar"
    "foobar"
    
    >`(list @t)`"foobar"
    <|f o o b a r|>
    
    >`(list @tD)`"foobar"
    "foobar"
    
    > `(list @)`"foobar"
    ~[102 111 111 98 97 114]
<


------------------------------------------------------------------------------
+$TOUR                                                                  *+$tour*

UTF-32 clusters

A `tour` is a list of UTF-32 characters.

Source~
>
    +$  tour  (list @c)
<

Examples~
>
    > *tour
    ~
<
>
    > `tour`(tuba "foobar")
    ~[~-f ~-o ~-o ~-b ~-a ~-r]
<


------------------------------------------------------------------------------
+$TARP                                                                  *+$tarp*

Parsed time

The time component of a `date`: day, hour, minute, second and a list of `@ux`
for precision.

Source~
>
    +$  tarp  [d=@ud h=@ud m=@ud s=@ud f=(list @ux)]
<

Examples~
>
    > *tarp
    [d=0 h=0 m=0 s=0 f=~]
    
    > (yell now)
    [d=106.751.991.821.625 h=22 m=58 s=10 f=~[0x44ff]]
    
    > `tarp`(yell ~2014.6.6..21.09.15..0a16)
    [d=106.751.991.820.172 h=21 m=9 s=15 f=~[0xa16]]
    
    > (yell ~d20)
    [d=20 h=0 m=0 s=0 f=~]
<


------------------------------------------------------------------------------
+$TERM                                                                  *+$term*

Hoon constant

A restricted text atom for Hoon constants. The only characters permitted are
lowercase ASCII letters, `-`, and `0-9`, the latter two of which cannot be the
first character. The syntax for `@tas` is the text itself, always preceded by
`%`. The empty `@tas` has a special syntax, `$`.

Source~
>
    +$  term  @tas
<

Examples~
>
    > *term
    %$
    
    > *%term
    %term
    
    > %dead-fish9
    %dead-fish9
    
    > -:!>(%dead-fish9)
    #t/%dead-fish9
    
    > -:!>(`@tas`%dead-fish9)
    #t/@tas
<


------------------------------------------------------------------------------
+$WAIN                                                                  *+$wain*

List of strings

A list of `cord`s. A `wain` is used instead of a single `cord` with `\n`.

Source~
>
    +$  wain  (list cord)
<

Examples~
>
    > *wain
    <||>
    
    > `wain`/som/del/rok
    <|som del rok|>
<


------------------------------------------------------------------------------
+$WALL                                                                  *+$wall*

List of list of characters

A list of `tape`s. `wall` is used instead of a single `tape` with `\n`.

Source~
>
    +$  wall  (list tape)
<

Examples~
>
        > *wall
        <<>>
    
        > `wall`(wash [0 20] leaf+<(bex 256)>)
        <<
          "\\/115.792.089.237.\\/"
          "  316.195.423.570."
          "  985.008.687.907."
          "  853.269.984.665."
          "  640.564.039.457."
          "  584.007.913.129."
          "  639.936"
          "\\/                \\/"
        >>
<



==============================================================================
 3a: Modular and Signed Ints                                                                         

------------------------------------------------------------------------------
EGCD                                                                  *++egcd*

Extended Euclidean algorithm

Produces `d`, the greatest common divisor of `a` and `b`. Also produces `u`
and `v` such that `au + bv = GCD(a, b)`.

Accepts~

`a` is an atom.

`b` is an atom.

Produces~

`d`, the greatest common divisor, is an atom.

`u`, the coefficient of `a`, is a signed integer.

`v`, the coefficient of `b`, is a signed integer.

Source~
>
    ++  egcd
      |=  [a=@ b=@]
      =+  si
      =+  [c=(sun a) d=(sun b)]
      =+  [u=[c=(sun 1) d=--0] v=[c=--0 d=(sun 1)]]
      |-  ^-  [d=@ u=@s v=@s]
      ?:  =(--0 c)
        [(abs d) d.u d.v]
      =+  q=(fra d c)
      %=  $
        c  (dif d (pro q c))
        d  c
        u  [(dif d.u (pro q c.u)) c.u]
        v  [(dif d.v (pro q c.v)) c.v]
      ==
<

Examples~
>
    > (egcd 11 2)
    [d=1 u=--1 v=-5]
<


------------------------------------------------------------------------------
FO                                                                  *++fo*

Modulo prime

Container `door` for modular arithmetic functions.

Accepts~

`a` is an atom

Source~
>
    ++  fo
      ^|
      |_  a=@
<


`++dif:fo`~

Subtraction

Produces the difference between atoms `b` and `c`, with `a` as the modular
base.

Accepts~

`a` is an atom, and is the sample of `+fo`.

`b` is an atom.

`c` is an atom.

Produces~

An atom.

Source~
>
    ++  dif
      |=  [b=@ c=@]
      (sit (sub (add a b) (sit c)))
<

Examples~
>
    > (~(dif fo 6) 1 2)
    5
    
    > (~(dif fo 21) 11 45)
    8
<


`++exp:fo`~

Exponent

Produces the power of `c` raised to the `b`, with `a` as the modular base.

Accepts~

`a` is an atom, and is the sample of `+fo`.

`b` is an atom.

`c` is an atom.

Produces~

An atom.

Source~
>
    ++  exp
      |=  [b=@ c=@]
      ?:  =(0 b)
        1
      =+  d=$(b (rsh 0 b))
      =+  e=(pro d d)
      ?:(=(0 (end 0 b)) e (pro c e))
<

Examples~
>
        > (~(exp fo 5) 8 2)
        1
    
        > (~(exp fo 95) 8 2)
        66
    
        > (~(exp fo 195) 8 2)
        61
    
        > (~(exp fo 995) 8 2)
        256
<


`++fra:fo`~

Divide

Produces the quotient of `b` divided by `c`, with `a` as the modular base.

Accepts~

`a` is an atom, and is the sample of `+fo`.

`b` is an atom.

`c` is an atom.

Produces~

An atom.

Source~
>
    ++  fra
      |=  [b=@ c=@]
      (pro b (inv c))
<

Examples~
>
    > (~(fra fo 2) 8 2)
    0
    
    > (~(fra fo 3) 8 2)
    1
    
    > (~(fra fo 4) 8 2)
    0
    
    > (~(fra fo 5) 8 2)
    4
<


`++inv:fo`~

Inverse

Produces an atom by taking the signed modulus of `a` with the coefficient `u`;
`u` is produced by taking the `+egcd` of `a` and `b`.

Accepts~

`a` is an atom, and is the sample of `+fo`.

`b` is an atom.

Produces~

An atom.

Source~
>
    ++  inv
      |=  b=@
      =+  c=(dul:si u:(egcd b a) a)
      c
<

Examples~
>
    > (~(inv fo 11) 2)
    6
    
    > (~(inv fo 71) 255)
    22
    
    > (~(inv fo 79) 255)
    22
    
    > (~(inv fo 78) 255)
    67
    
    > (~(inv fo 70) 255)
    67
<


`++pro:fo`~

Multiplication

Produces the multiplication of `b` and `c` modulo `a`.

Accepts~

`a` is an atom, and is the sample of `+fo`.

`b` is an atom.

`c` is an atom.

Produces~

An atom.

Source~
>
    ++  pro
      |=  [b=@ c=@]
      (sit (mul b c))
<

Examples~
>
    > (~(pro fo 3) 11 4)
    2
    
    > (mod 44 3)
    2
<


`++sit:fo`~

Modulus

Produces the remainder of `b` modulo `a`.

Accepts~

`a` is an atom, and is the sample of `+fo`.

`b` is an atom.

Produces~

An atom.

Source~
>
    ++  sit
      |=  b=@
      (mod b a)
<

Examples~
>
    > (~(sit fo 3) 14)
    2
<


`++sum:fo`~

Modular sum

Produces the remainder of `(b + c) mod a`.

Accepts~

`a` is an atom, and is the sample of `+fo`.

`b` is an atom.

`c` is an atom.

Produces~

An atom.

Source~
>
    ++  sum
      |=  [b=@ c=@]
      (sit (add b c))
<

Examples~
>
    > (~(sum fo 3) 14 3)
    2
    
    > (mod 17 3)
    2
<


------------------------------------------------------------------------------
SI                                                                  *++si*

Signed integer

Container core for signed integer functions.

Source~
>
    ++  si
      ^?
      |%
<

Discussion~

The signed-integer type is represented by the `@s` aura. Positive integers are
prepended with a `--`, and negative integers are prepended with a `-`. For
example, `--1` represents positive one, and `-1` represents negative one.

ZigZag encoding is used to convert atoms to signed integers. Positive signed
integers correspond to even atoms of twice their absolute value, and negative
signed integers correspond to odd atoms of twice their absolute value minus
one. For example:
>
    > `@`--4
    8
    > `@s`8
    --4
<
>
    > `@`-4
    7
    > `@s`7
    -4
<


`++abs:si`~

Absolute value

Produces the absolute value of signed integer `a`.

Accepts~

`a` is a signed integer.

Produces~

An atom.

Source~
>
    ++  abs  |=(a=@s (add (end 0 a) (rsh 0 a)))
<

Examples~
>
    > (abs:si -11)
    11
    
    > (abs:si --520)
    520
<


`++dif:si`~

Subtraction

Produces the difference of `a` minus `b`.

Accepts~

`a` is a signed integer.

`b` is a signed integer.

Produces~

A signed integer.

Source~
>
    ++  dif  |=  [a=@s b=@s]
             (sum a (new !(syn b) (abs b)))
<

Examples~
>
    > (dif:si --3 -2)
    --5
    
    > (dif:si -3 --2)
    -5
<


`++dul:si`~

Modulus

Produces the remainder of `b` modulo `a`.

Examples~

`a` is a signed integer.

`b` is an atom.

Produces~

An atom.

Source~
>
    ++  dul  |=  [a=@s b=@]
             =+(c=(old a) ?:(-.c (mod +.c b) (sub b +.c)))
<

Examples~
>
    > `@s`(dul:si -1 --5)
    -5
    
    > `@`--5
    10
    > `@s`(dul:si -1 10)
    -5
    
    > `@s`(dul:si -11 -61)
    --55
<


`++fra:si`~

Divide

Produces the quotient of `b` divided by `c`.

Accepts~

`a` is a signed integer.

`b` is a signed integer.

Produces~

A signed atom.

Source~
>
    ++  fra  |=  [a=@s b=@s]
             (new =(0 (mix (syn a) (syn b))) (div (abs a) (abs b)))
<

Examples~
>
    > (fra:si -1 -1)
    --1
    
    > (fra:si -11 --2)
    -5
    
    > (fra:si -0 -1)
    --0
<


`++new:si`~

Atom to `@s`

Produces a signed integer from an atom `b`. The product's sign is determined
by the value of flag `a`: `&` will result in a prepending `--`, and `|` will
result in a prepending `-`.

Accepts~

`a` is a flag.

`b` is an atom.

Produces~

A signed integer.

Source~
>
    ++  new  |=  [a=? b=@]
             `@s`?:(a (mul 2 b) ?:(=(0 b) 0 +((mul 2 (dec b)))))
<

Examples~
>
    > (new:si | 2)
    -2
    
    > (new:si & 2)
    --2
    
    > (new:si & -2)
    --3
    
    > (new:si & --2)
    --4
<


`++old:si`~

Sign and absolute value

Produces a cell composed of a `%.y` or `%.n`, depending on whether `a` is
positive or negative, and the absolute value of `a`.

Accepts~

`a` is a signed integer.

Produces~

A cell composed of a `?` and an atom.

Source~
>
          ++  old  |=(a=@s [(syn a) (abs a)])
<
>
    ++  old  |=(a=@s [(syn a) (abs a)])
<

Examples~
>
    > (old:si -2)
    [%.n 2]
    
    > (old:si --2)
    [%.y 2]
<


`++pro:si`~

Multiplication

Produces a signed integer by multiplying `a` and `b`.

Accepts~

`a` is an unsigned integer.

`b` is an unsigned integer.

Source~
>
    ++  pro  |=  [a=@s b=@s]
             (new =(0 (mix (syn a) (syn b))) (mul (abs a) (abs b)))
<

Examples~
>
    > (pro:si -3 -3)
    --9
    
    > (pro:si -3 --3)
    -9
<


`++rem:si`~

Remainder

Produces a signed integer that is the remainder of `a` divided by `b`.

Accepts~

`a` is a signed integer.

`b` is a signed integer.

Produces~

A signed integer.

Source~
>
    ++  rem  |=([a=@s b=@s] (dif a (pro b (fra a b))))
<

Examples~
>
    > (rem:si -17 -3)
    -2
    
    > (rem:si --17 -3)
    --2
    
    > (rem:si -17 --3)
    -2
    
    > (rem:si --17 --3)
    --2
<


`++sum:si`~

Addition

Produces an atom by adding `a` and `b`.

Accepts~

`a` is a signed integer.

`b` is a signed integer.

Produces~

A signed integer.

Source~
>
    ++  sum  |=  [a=@s b=@s]
             =+  [c=(old a) d=(old b)]
             ?:  -.c
               ?:  -.d
                 (new & (add +.c +.d))
               ?:  (gte +.c +.d)
                 (new & (sub +.c +.d))
               (new | (sub +.d +.c))
             ?:  -.d
               ?:  (gte +.c +.d)
                 (new | (sub +.c +.d))
               (new & (sub +.d +.c))
             (new | (add +.c +.d))
<

Examples~
>
    > (sum:si -11 --2)
    -9
    
    > (sum:si --2 --2)
    --4
<


`++sun:si`~

`@u` to `@s`

Multiplies the unsigned integer `a` by two, producing an atom.

Accepts~

`a` is an unsigned integer.

Produces~

An atom.

Source~
>
    ++  sun  |=(a=@u (mul 2 a))
<

Examples~
>
    > (sun:si 90)
    180
    
    > (sun:si --90)
    360
    > `@u`--90
    180
    
    > (sun:si --89)
    356
    > `@u`--89
    178
    
    > (sun:si -89)
    354
    > `@u`-89
    177
<


`++syn:si`~

Sign test

Tests whether signed atom `a` is positive or negative. `%.y` is produced if
`a` is positive, and `%.n` is produced if `a` is negative.

Accepts~

`a` is a signed integer.

Produces~

A `?`.

Source~
>
    ++  syn  |=(a=@s =(0 (end 0 a)))
<

Examples~
>
    > (syn:si -2)
    %.n
    
    > (syn:si --2)
    %.y
<


`++cmp:si`~

Compare

Compares `a` and `b` to see which is greater. If `a` is greater than `b`,
`--1` is produced. If `b` is greater than `a`, `-1` is produced. If `a` and
`b` are equal, `--0` is produced.

Accepts~

`a` is a signed integer.

`b` is a signed integer.

Produces~

A signed integer.

Source~
>
    ++  cmp  |=  [a=@s b=@s]
             ^-  @s
             ?:  =(a b)
               --0
             ?:  (syn a)
               ?:  (syn b)
                 ?:  (gth a b)
                   --1
                 -1
               --1
            ?:  (syn b)
              -1
            ?:  (gth a b)
              -1
            --1
<

Examples~
>
    > (cmp:si -2 --1)
    -1
    
    > (cmp:si -2 --1)
    -1
    
    > (cmp:si --2 --1)
    --1
    
    > (cmp:si --2 --2)
    --0
    
    > (cmp:si --2 --5)
    -1
<



==============================================================================
 3b: Floating Point                                                                         

------------------------------------------------------------------------------
FN                                                                  *++fn*

Float

A mold for the floating-point arithmetic using the base of two, the formula is
`(-1)^s * a * 2^e`.

Produces either a float (`%f`), an infinity of other sign (`%i`), or not-a-
number (`%n`). `s` refers to sign, the `flag`s `&` or `|`; `e` to exponent, a
signed decimal; and `a` to the significand, an unsigned integer.

Source~
>
    ++  fn
      $%  [%f s=? e=@s a=@u]
          [%i s=?]
          [%n ~]
      ==
<

Examples~
>
    > *fn
    [%n ~]
    
    > (add:fl [%f & --33 2] [%f | --23 2])
    [%f s=%.y e=-79 a=10.374.452.512.267.829.421.849.019.032.797.184]
    
    > (add:fl [%i &] [%i &])
    [%i s=%.y]
    
    > (add:fl [%n ~] [%i |])
    [%n ~]
    
    > (sun:fl 961.193.554.848.514.048.973.893.027.381.506.219.443)
    [%f s=%.y e=--17 a=7.333.324.850.834.000.007.430.214.137.126.970]
<


------------------------------------------------------------------------------
DN                                                                  *++dn*

Decimal float

A mold for the floating-point arithmetic using the base of 10; the formula is
`(-1)^s * a *10^e`.

Valid values are a float (`%d`), an infinity (`%i`), or a not-a-number (`%n`).
`s` refers to sign, the `flag`s `&` or `|`; `e` to exponent, a signed decimal;
and `a` to the significand, an unsigned integer.
>
    ++  dn
      $%  [%d s=? e=@s a=@u]
          [%i s=?]
          [%n ~]
      ==
<

Examples~
>
    > `dn`[%d & --0 17.163.091.968]
    [%d s=%.y e=--0 a=17.163.091.968]
    
    > `dn`[%i s=%.y]
    [%i s=%.y]
    
    > `dn`[%n ~]
    [%n ~]
<


------------------------------------------------------------------------------
RN                                                                  *++rn*

Parsed decimal float

A mold for the floating-point arithmetic using the base of 10; the formula is
`(-1)^s * a *10^e`.

Produces either a parsed float (`%d`), infinity of either sign (`%i`), or not-
a-number (`%n`).

Source~
>
    ++  rn
      $%  [%d a=? b=[c=@ [d=@ e=@] f=? i=@]]
          [%i a=?]
          [%n ~]
      ==
<

Examples~
>
    > `rn`[%d | [2 [3 4] | 17.163]]
    [%d a=%.n b=[c=2 [d=3 e=4] f=%.n i=17.163]]
<


------------------------------------------------------------------------------
FL                                                                  *++fl*

Arbitrary-precision floating-point

Container arm for floating-point arithmetic functions.

- Precision (`p`): number of bits in the significand; must be at least 2.
Default is 113.
- Minimum exponent (`v`): minimum value of e. Default is -16.494.
- Width (`w`): Max value of `e` minus min value of `e`. 0 is for fixed-point.
Default is 32.765.
- Rounding mode (`r`): Possible modes are nearest (`%n`), up (`%u`), down
(`%d`), to zero (`%z`), and away from zero (`%a`). Default value is `%n`.
- Behavior (`d`): return denormals (`%d`), flush denormals to zero (`%z`),
infinite exponent range (`%i`). Default value is `%d`.


Source~
>
    ++  fl
      =/  [[p=@u v=@s w=@u] r=$?(%n %u %d %z %a) d=$?(%d %f %i)]
        [[113 -16.494 32.765] %n %d]
      =>
        ~%  %cofl  +>  ~
        |%
<


`^rou:fl`~

Round

Rounds `a` to a the nearest float that can be represented with a 113-bit
significand. There is no term to sign the significand, meaning that a positive
sign will always be produced.

Accepts~

`a` is a cell of a signed integer and an unsigned integer.

Produces~

An `fn`.

Source~
>
    ++  rou
      |=  [a=[e=@s a=@u]]  ^-  fn  (rau a &)
<

Examples~
>
    > =a 10.161.487.211.429.486.882.397.572.894.294.017.777
    > (^rou:fl [--12 a])
    [%f s=%.y e=--22 a=9.923.327.354.911.608.283.591.379.779.584.002]
    
    > (^rou:fl [--12 (add a 1)])
    [%f s=%.y e=--22 a=9.923.327.354.911.608.283.591.379.779.584.002]
    
    > (^rou:fl [--12 (add a 300)])
    [%f s=%.y e=--22 a=9.923.327.354.911.608.283.591.379.779.584.002]
    
    > (^rou:fl [--12 (add a 1.000)])
    [%f s=%.y e=--22 a=9.923.327.354.911.608.283.591.379.779.584.003]
<


`++rau:fl`~

Various roundings

Rounds `a` based on what the state of of `r` in the core contained in `fl`.
`t` is a sticky bit that represents a value less than ULP(a) = 2^(e.a) when
passed to `lug:fl`.

Accepts~

`a` is a cell of a signed integer and an unsigned integer.

`t` is a `flag`.

Produces~

An `fn`.

Source~
>
    ++  rau
      |=  [a=[e=@s a=@u] t=?]  ^-  fn
      ?-  r
        %z  (lug %fl a t)  %d  (lug %fl a t)
        %a  (lug %ce a t)  %u  (lug %ce a t)
        %n  (lug %ne a t)
      ==
<

Examples~
>
    > (rau:fl [-18 342.602.577] &)
    [%f s=%.y e=-102 a=6.626.897.619.228.945.634.459.505.846.648.832]
<

Discussion~

See `lug:fl` for possible rounding operations.


`^add:fl`~

Add

Produces the sum of `a` and `b`. `e` is used to choose between an exact result
(any-sized significand) or a rounded result (113-bit significand).

There is no term to sign the significands, so a positive sign will always be
produced.

Accepts~

`a` is an `fn`.

`b` is an `fn`

`e` is a `flag`.

Produces~

An `fn`.

Source~
>
    ++  add
      |=  [a=[e=@s a=@u] b=[e=@s a=@u] e=?]  ^-  fn
      =+  q=(dif:si e.a e.b)
      |-  ?.  (syn:si q)  $(b a, a b, q +(q))
      ?:  e
        [%f & e.b (^add (lsh [0 (abs:si q)] a.a) a.b)]
      =+  [ma=(met 0 a.a) mb=(met 0 a.b)]
      =+  ^=  w  %+  dif:si  e.a  %-  sun:si
        ?:  (gth prc ma)  (^sub prc ma)  0
      =+  ^=  x  %+  sum:si  e.b  (sun:si mb)
      ?:  =((cmp:si w x) --1)
        ?-  r
          %z  (lug %fl a &)  %d  (lug %fl a &)
          %a  (lug %lg a &)  %u  (lug %lg a &)
          %n  (lug %na a &)
        ==
      (rou [e.b (^add (lsh [0 (abs:si q)] a.a) a.b)])
<

Examples~
>
    > (^add:fl [--33 2.718] [--23 11] %.y)
    [%f s=%.y e=--23 a=2.783.243]
    
    > (^add:fl [--33 2.718] [--23 11] %.n)
    [%f s=%.y e=-68 a=6.890.975.897.521.519.304.902.126.405.156.864]
<


`^sub:fl`~

Subtract

Produces the difference of `a` minus `b.` `e` is used to choose between an
exact result (any-sized significand) or a rounded result (113-bit
significand).

Accepts~

`a` is a cell of a signed integer and an unsigned integer.

`b` is a cell of a signed integer and an unsigned integer.

`e` is a `flag`.

Produces~

An `fn`.

Source~
>
    ++  sub
      |=  [a=[e=@s a=@u] b=[e=@s a=@u] e=?]  ^-  fn
      =+  q=(dif:si e.a e.b)
      |-  ?.  (syn:si q)
        (fli $(b a, a b, q +(q), r swr))
      =+  [ma=(met 0 a.a) mb=(met 0 a.b)]
      =+  ^=  w  %+  dif:si  e.a  %-  sun:si
        ?:  (gth prc ma)  (^sub prc ma)  0
      =+  ^=  x  %+  sum:si  e.b  (sun:si +(mb))
      ?:  &(!e =((cmp:si w x) --1))
        ?-  r
          %z  (lug %sm a &)  %d  (lug %sm a &)
          %a  (lug %ce a &)  %u  (lug %ce a &)
          %n  (lug %nt a &)
        ==
      =+  j=(lsh [0 (abs:si q)] a.a)
      |-  ?.  (gte j a.b)
        (fli $(a.b j, j a.b, r swr))
      =+  i=(^sub j a.b)
      ?~  i  [%f & zer]
      ?:  e  [%f & e.b i]  (rou [e.b i])
<

Examples~
>
    > (^sub:fl [--33 2.718] [--23 11] %.y)
    [%f s=%.y e=--23 a=2.783.221]
    
    > (^sub:fl [--33 2.718] [--63 11] %.y)
    [%f s=%.n e=--33 a=11.811.157.346]
<


`^mul:fl`~

Multiply

Produces the product of `a` multiplied by `b`. There is no term to sign the
significands, so a positive sign will always be produced.

Accepts~

`a` is a cell of a signed integer and an unsigned integer.

`b` is a cell of a signed integer and an unsigned integer.

Produces~

An `fn`.

Source~
>
    ++  mul
      |=  [a=[e=@s a=@u] b=[e=@s a=@u]]  ^-  fn
      (rou (sum:si e.a e.b) (^mul a.a a.b))
<

Examples~
>
    > (^mul:fl [--3 2.718] [--23 11])
    [%f s=%.y e=-72 a=9.475.054.411.405.900.661.487.108.108.582.912]
<


`^div:fl`~

Divide

Produces the quotient of `a` divided by `b`. There is no term to sign the
significands, so a positive sign will always be produced.

Accepts~

`a` is a cell of a signed integer and an unsigned integer.

`b` is a cell of a signed integer and an unsigned integer.

Produces~

An `fn`.

Source~
>
    ++  div
      |=  [a=[e=@s a=@u] b=[e=@s a=@u]]  ^-  fn
      =+  [ma=(met 0 a.a) mb=(met 0 a.b)]
      =+  v=(dif:si (sun:si ma) (sun:si +((^add mb prc))))
      =.  a  ?:  (syn:si v)  a
      a(e (sum:si v e.a), a (lsh [0 (abs:si v)] a.a))
      =+  [j=(dif:si e.a e.b) q=(dvr a.a a.b)]
      (rau [j p.q] =(q.q 0))
<

Examples~
>
    > (^div:fl [--13 2.718] [--23 11])
    [%f s=%.y e=-115 a=10.023.198.055.040.952.765.870.659.817.343.907]
<


`^sqt:fl`~

Square root

Produces the square root of `a`.

Accepts~

`a` is a cell of a signed integer and an unsigned integer.

Produces~

An `fn`.

Source~
>
    ++  sqt
      |=  [a=[e=@s a=@u]]  ^-  fn
      =.  a
        =+  [w=(met 0 a.a) x=(^mul +(prc) 2)]
        =+  ?:((^lth w x) (^sub x w) 0)
        =+  ?:  =((dis - 1) (dis (abs:si e.a) 1))  -
          (^add - 1)
        a(e (dif:si e.a (sun:si -)), a (lsh [0 -] a.a))
      =+  [y=(^sqt a.a) z=(fra:si e.a --2)]
      (rau [z p.y] =(q.y 0))
<

Examples~
>
    > (^sqt:fl [-18 342.602.577])
    [%f s=%.y e=-107 a=5.865.903.143.604.945.574.132.671.852.050.553]
<


`^lth:fl`~

Less than

Tests if `a` is less than `b`.

Accepts~

`a` is a cell of a signed integer and an unsigned integer.

`b` is a cell of a signed integer and an unsigned integer.

Produces~

An `flag`.

Source~
>
    ++  lth
      |=  [a=[e=@s a=@u] b=[e=@s a=@u]]  ^-  ?
      ?:  =(e.a e.b)  (^lth a.a a.b)
      =+  c=(cmp:si (ibl a) (ibl b))
      ?:  =(c -1)  &  ?:  =(c --1)  |
      ?:  =((cmp:si e.a e.b) -1)
        (^lth (rsh [0 (abs:si (dif:si e.a e.b))] a.a) a.b)
      (^lth (lsh [0 (abs:si (dif:si e.a e.b))] a.a) a.b)
<

Examples~
>
    > (^lth:fl [-4 684] [--0 35])
    %.n
    
    > (^lth:fl [-4 684] [--0 90])
    %.y
<


`^equ:fl`~

Equals

Tests if `a` is equal to `b`.

Accepts~

`a` is a cell of a signed integer and an unsigned integer.

`b` is a cell of a signed integer and an unsigned integer.

Produces~

A `flag`.

Source~
>
    ++  equ
      |=  [a=[e=@s a=@u] b=[e=@s a=@u]]  ^-  ?
      ?.  =((ibl a) (ibl b))  |
      ?:  =((cmp:si e.a e.b) -1)
        =((lsh [0 (abs:si (dif:si e.a e.b))] a.b) a.a)
      =((lsh [0 (abs:si (dif:si e.a e.b))] a.a) a.b)
<

Examples~
>
    > (^equ:fl [-4 480] [-0 50])
    %.n
    
    > (^equ:fl [-4 480] [-0 30])
    %.y
<


`++ibl:fl`~

Integer binary logarithm

Produces the lowest power to which the number 2 must be raised to obtain `a`
or greater.

Accepts~

`a` is a cell of a signed integer and an unsigned integer.

Produces~

A signed integer.

Source~
>
    ++  ibl
      |=  [a=[e=@s a=@u]]  ^-  @s
      (sum:si (sun:si (dec (met 0 a.a))) e.a)
<

Examples~
>
    > (ibl:fl [-18 342.602.577])
    --10
<


`++uni:fl`~

Change representation to odd

Produces another representation of the floating point `a` where the
significand is odd. Every floating-point number has a unique representation of
this kind. If the significand of `a` is already odd, nothing changes.

Accepts~

`a` is a cell of a signed integer and an unsigned integer.

Produces~

A cell of a signed integer and an unsigned integer.

Source~
>
    ++  uni
      |=  [a=[e=@s a=@u]]
      |-  ?:  =((end 0 a.a) 1)  a
      $(a.a (rsh 0 a.a), e.a (sum:si e.a --1))
<

Examples~
>
    > (uni:fl [-8 342.602.578])
    [e=-7 a=171.301.289]
    
    > (uni:fl [-8 342.602.577])
    [e=-8 a=342.602.577]
<


`++xpd:fl`~

Expand

Produces the fully precise form of `a`, or the denormalized form of `a`.

Accepts~

`a` is a cell of a signed integer and an unsigned integer.

Produces~

A cell of a signed integer and an unsigned integer.

Sources~
>
    ++  xpd
      |=  [a=[e=@s a=@u]]
      =+  ma=(met 0 a.a)
      ?:  (gte ma prc)  a
      =+  ?:  =(den %i)  (^sub prc ma)
          =+  ^=  q
            =+  w=(dif:si e.a emn)
            ?:  (syn:si w)  (abs:si w)  0
          (min q (^sub prc ma))
      a(e (dif:si e.a (sun:si -)), a (lsh [0 -] a.a))
<

Examples~
>
    > (xpd:fl [--3 12])
    [e=-106 a=7.788.445.287.802.241.442.795.744.493.830.144]
    
    > (xpd:fl [-8 342.602.577])
    [e=-92 a=6.626.897.619.228.945.634.459.505.846.648.832]
    
    > (xpd:fl [-92 6.626.897.619.228.945.634.459.505.846.648.832])
    [e=-92 a=6.626.897.619.228.945.634.459.505.846.648.832]
<


`++lug:fl`~

Central rounding mechanism

Performs various rounding operations on `a`. An operation is chosen based on
the value selected for `t`. `s` is a sticky bit that represents a value less
than ULP(a) = 2^(e.a)

Possible rounding operations:

- Floor (`%fl`)
- Ceiling (`%ce`)
- Smaller (`%sm`)
- Larger (`%lg`)
- Nearest (`%ne`) -- Rounds ties away from 0 if the number is even, rounds
toward 0 if the number is odd.


Accepts~

`t` is one of the following: `%fl`, `%ce`, `%sm`, `%lg`, `%ne`, `%na`, or
`%nt`.

`a` is a cell of a signed integer and an unsigned integer.

`s` is a flag.

Produces~

An `fn`.

Source~
>
    ++  lug
      ~/  %lug
      |=  [t=$?(%fl %ce %sm %lg %ne %na %nt) a=[e=@s a=@u] s=?]  ^-  fn
      ?<  =(a.a 0)
      =-
        ?.  =(den %f)  -                                ::  flush denormals
        ?.  ?=([%f *] -)  -
        ?:  =((met 0 ->+>) prc)  -  [%f & zer]
      ::
      =+  m=(met 0 a.a)
      ?>  |(s (gth m prc))                              ::  require precision
      =+  ^=  q  %+  max
          ?:  (gth m prc)  (^sub m prc)  0              ::  reduce precision
        %-  abs:si  ?:  =(den %i)  --0                  ::  enforce min. exp
        ?:  =((cmp:si e.a emn) -1)  (dif:si emn e.a)  --0
      =^  b  a  :-  (end [0 q] a.a)
        a(e (sum:si e.a (sun:si q)), a (rsh [0 q] a.a))
      ::
      ?~  a.a
        ?<  =(den %i)
        ?-  t
          %fl  [%f & zer]
          %sm  [%f & zer]
          %ce  [%f & spd]
          %lg  [%f & spd]
          %ne  ?:  s  [%f & ?:((lte b (bex (dec q))) zer spd)]
               [%f & ?:((^lth b (bex (dec q))) zer spd)]
          %nt  ?:  s  [%f & ?:((lte b (bex (dec q))) zer spd)]
               [%f & ?:((^lth b (bex (dec q))) zer spd)]
          %na  [%f & ?:((^lth b (bex (dec q))) zer spd)]
        ==
      ::
      =.  a  (xpd a)
      ::
      =.  a
        ?-  t
          %fl  a
          %lg  a(a +(a.a))
          %sm  ?.  &(=(b 0) s)  a
               ?:  &(=(e.a emn) !=(den %i))  a(a (dec a.a))
               =+  y=(dec (^mul a.a 2))
               ?.  (lte (met 0 y) prc)  a(a (dec a.a))
               [(dif:si e.a --1) y]
          %ce  ?:  &(=(b 0) s)  a  a(a +(a.a))
          %ne  ?~  b  a
               =+  y=(bex (dec q))
               ?:  &(=(b y) s)                          ::  round halfs to even
                 ?~  (dis a.a 1)  a  a(a +(a.a))
               ?:  (^lth b y)  a  a(a +(a.a))
          %na  ?~  b  a
               =+  y=(bex (dec q))
               ?:  (^lth b y)  a  a(a +(a.a))
          %nt  ?~  b  a
               =+  y=(bex (dec q))
               ?:  =(b y)  ?:  s  a  a(a +(a.a))
               ?:  (^lth b y)  a  a(a +(a.a))
        ==
      ::
      =.  a  ?.  =((met 0 a.a) +(prc))  a
        a(a (rsh 0 a.a), e (sum:si e.a --1))
      ?~  a.a  [%f & zer]
      ::
      ?:  =(den %i)  [%f & a]
      ?:  =((cmp:si emx e.a) -1)  [%i &]  [%f & a]      ::  enforce max. exp
<


`^drg:fl`~

Get printable decimal

Produces the decimal form of `a` using the Dragon4 algorithm. Guarantees
accurate results for rounded floats.

Accepts~

`a` is a cell of a signed integer and an unsigned integer.

Produces~

A cell of a signed integer and an unsigned integer.

Source~
>
    ++  drg                                             ::  dragon4; get
      ~/  %drg                                          ::  printable decimal;
      |=  [a=[e=@s a=@u]]  ^-  [@s @u]                  ::  guaranteed accurate
      ?<  =(a.a 0)                                      ::  for rounded floats
      =.  a  (xpd a)
      =+  r=(lsh [0 ?:((syn:si e.a) (abs:si e.a) 0)] a.a)
      =+  s=(lsh [0 ?.((syn:si e.a) (abs:si e.a) 0)] 1)
      =+  mn=(lsh [0 ?:((syn:si e.a) (abs:si e.a) 0)] 1)
      =+  mp=mn
      =>  ?.
            ?&  =(a.a (bex (dec prc)))                  ::  if next smallest
                |(!=(e.a emn) =(den %i))                ::  float is half ULP,
            ==                                          ::  tighten lower bound
          .
        %=  .
          mp  (lsh 0 mp)
          r  (lsh 0 r)
          s  (lsh 0 s)
        ==
      =+  [k=--0 q=(^div (^add s 9) 10)]
      |-  ?:  (^lth r q)
        %=  $
          k  (dif:si k --1)
          r  (^mul r 10)
          mn  (^mul mn 10)
          mp  (^mul mp 10)
        ==
      |-  ?:  (gte (^add (^mul r 2) mp) (^mul s 2))
        $(s (^mul s 10), k (sum:si k --1))
      =+  [u=0 o=0]
      |-                                                ::  r/s+o = a*10^-k
      =+  v=(dvr (^mul r 10) s)
      =>  %=  .
          k  (dif:si k --1)
          u  p.v
          r  q.v
          mn  (^mul mn 10)
          mp  (^mul mp 10)
        ==
      =+  l=(^lth (^mul r 2) mn)                        ::  in lower bound
      =+  ^=  h                                         ::  in upper bound
        ?|  (^lth (^mul s 2) mp)
            (gth (^mul r 2) (^sub (^mul s 2) mp))
        ==
      ?:  &(!l !h)
        $(o (^add (^mul o 10) u))
      =+  q=&(h |(!l (gth (^mul r 2) s)))
      =.  o  (^add (^mul o 10) ?:(q +(u) u))
      [k o]
<

Examples~
>
    > (sun:fl 218.116)
    [%f s=%.y e=-95 a=8.640.464.947.480.640.129.276.716.135.743.488]
    > (^drg:fl [e=-95 a=8.640.464.947.480.640.129.276.716.135.743.488])
    [--0 218.116]
    
    > (sun:fl 102.057.673.128.349)
    [%f s=%.y e=-66 a=7.530.527.107.827.833.883.675.587.233.447.936]
    > (^drg:fl [e=-66 a=7.530.527.107.827.833.883.675.587.233.447.936])
    [--0 102.057.673.128.349]
<


`^toj:fl`~

Round to integer

Rounds float `a` to the nearest decimal float with an exponent of 0.

Accepts~

`a` is a cell of a signed integer and an unsigned integer.

Produces~

An `fn`.

Source~
>
    ++  toj
      |=  [a=[e=@s a=@u]]  ^-  fn
      ?.  =((cmp:si e.a --0) -1)  [%f & a]
      =+  x=(abs:si e.a)
      =+  y=(rsh [0 x] a.a)
      ?:  |(=(r %d) =(r %z))  [%f & --0 y]
      =+  z=(end [0 x] a.a)
      ?:  |(=(r %u) =(r %a))  [%f & --0 ?~(z y +(y))]
      =+  i=(bex (dec x))
      ?:  &(=(z i) =((dis y 1) 0))  [%f & --0 y]
      ?:  (^lth z i)  [%f & --0 y]  [%f & --0 +(y)]
<

Examples~
>
    > (^toj:fl [-11 7.530.107.827.833.587])
    [%f s=%.y e=--0 a=3.676.810.462.809]
    
    > (^toj:fl [-11 7.530.107.827.833.589])
    [%f s=%.y e=--0 a=3.676.810.462.809]
<


`++ned:fl`~

Require float

Produces `a` if `a` is a is of floating-point representation. If `a` is
another case of `fn`, such as infinity or not-a-number, a crash is produced.

Accepts~

`a` is an `fn`.

Produces~

A cell of a signed integer and an unsigned integer.

Source~
>
    ++  ned
      |=  [a=fn]  ^-  [%f s=? e=@s a=@u]
      ?:  ?=([%f *] a)  a
      ~_  leaf+"need-float"
      !!
<

Examples~
>
    > (ned:fl [%f s=%.y e=-11 a=7.530.107.827.833.587])
    [%f s=%.y e=-11 a=7.530.107.827.833.587]
    
    > (ned:fl [%n ~])
    ! need-float
    ! exit
    
    > (ned:fl [%i |])
    ! need-float
    ! exit
<


`++shf:fl`~

Shift power

Multiplies `a` by 2 to the `b` power without rounding. This results in
shifting the exponent term by `b`.

Accepts~

`a` is an `fn`.

`b` is a signed integer.

Produces~

An `fn`.

Source~
>
    ++  shf
      |=  [a=fn b=@s]
      ?:  |(?=([%n *] a) ?=([%i *] a))  a
      a(e (sum:si e.a b))
<

Examples~
>
    > (shf:fl [[%f & -2 7] --2])
    [%f s=%.y e=--0 a=7]
    
    > (shf:fl [[%f & -2 7] -2])
    [%f s=%.y e=-4 a=7]
    
    > (shf:fl [%f & -11 7.530.107.827.833.587] --5)
    [%f s=%.y e=-6 a=7.530.107.827.833.587]
<


`++fli:fl`~

Flip sign

Produces `a` with its signed changed from positive to negative, or vice versa.

Accepts~

`a` is an `fn`.

Produces~

An `fn`.

Source~
>
    ++  fli
      |=  [a=fn]  ^-  fn
      ?-(-.a %f a(s !s.a), %i a(s !s.a), %n a)
<

Examples~
>
    > (fli:fl [%f %.y -2 7])
    [%f s=%.n e=-2 a=7]
    
    > (fli:fl [%f %.n --2 30.617])
    [%f s=%.y e=--2 a=30.617]
    
    > (fli:fl [%f | --2 30.617])
    [%f s=%.y e=--2 a=30.617]
<


`++swr:fl`~

Switch rounding

Switches the rounding mode of `r:fl`.

Source~
>
    ++  swr  ?+(r r %d %u, %u %d)
<

Examples~
>
    > r:fl
    %n
    > swr:fl
    %n
    
    > =new-fl fl                              ::  new fl core with changed state
    > =new-fl new-fl(r %u)
    > swr:new-fl
    %d
<


`++prc:fl`~

Force precision of 2 or greater

Produces `p`, the core's precision, if `p` is greater than or equal to 2.
Otherwise, a crash is produced.

Source~
>
    ++  prc  ?>((gth p 1) p)
<

Examples~
>
    > prc:fl
    113
    
    > =new-fl fl
    > =new-fl new-fl(p 1)
    > prc:new-fl
    ! exit
    
    > =new-fl new-fl(p 2)
    > prc:new-fl
    2
<


`++den:fl`~

Behavior

Produces `d:fl`. Denormalizes if `d:fl` is `%d`. Flushes denormals to zero if
`d:fl` is `%f`.

- Denormalizes if `d:fl` is `%d`.
- Flushes denormals to zero if `d:fl` is `%f`.
- Infinite exponent range if `%d` is `%i`.


The default value of `d` is `%d`.

Source~
>
    ++  den  d
<

Examples~
>
    > den:fl
    %d
    
    > =new-fl fl
    > =new-fl new-fl(d %f)
    > den:new-fl
    %f
<


`++emn:fl`~

Minimum exponent

Produces `v:fl`, the minimum exponent. The default minimum exponent is
-16.494.

Source~
>
    ++  emn  v
<

Examples~
>
    > emn:fl
    -16.494
<


`++emx:fl`~

Maximum exponent

Returns the maximum exponent of `fl`. The default maximum exponent is
--16.271.

Source~
>
    ++  emx  (sum:si emn (sun:si w))
<

Examples~
>
    > emx:fl
    --16.271
    
    > `@u`emx:fl
    32.542
<


`++spd:fl`~

Smallest denormal

Produces the smallest possible denormalized float.

Source~
>
    ++  spd  [e=emn a=1]
<

Examples~
>
    > spd:fl
    [e=-16.494 a=1]
<


`++spn:fl`~

Smallest normal

Produces the smallest representable normal float.

Source~
>
    ++  spn  [e=emn a=(bex (dec prc))]
<

Examples~
>
    > spn:fl
    [e=-16.494 a=5.192.296.858.534.827.628.530.496.329.220.096]
<


`++lfn:fl`~

Largest normal

Produces the largest representable normal float.

Source~
>
    ++  lfn  [e=emx a=(fil 0 prc 1)]
<

Examples~
>
    > lfn:fl
    [e=--16.271 a=10.384.593.717.069.655.257.060.992.658.440.191]
<


`++lfe:fl`~

Maximum

Produces the sum of `emx:fl` plus `prc:fl`.

Source~
>
    ++  lfe  (sum:si emx (sun:si prc))
<

Examples~
>
    > lfe:fl
    --16.384
<


`++zer:fl`~

Zero

Produces zero represented as a float.

Source~
>
    ++  zer  [e=--0 a=0]
<

Examples~
>
    > zer:fl
    [e=--0 a=0]
<


`++rou:fl`~

Round

Rounds `a`. The way in which `a` is rounded depends on the value of `r:fl`.

Accepts~

`a` is an `fn`.

Produes~

An `fn`.

Source~
>
    ++  rou
      |=  [a=fn]  ^-  fn
      ?.  ?=([%f *] a)  a
      ?~  a.a  [%f s.a zer]
      ?:  s.a  (^rou +>.a)
      =.(r swr (fli (^rou +>.a)))
<

Examples~
>
    > =a 10.161.487.211.429.486.882.397.572.894.294.017.777
    > (rou:fl [%f & --12 a])
    [%f s=%.y e=--22 a=9.923.327.354.911.608.283.591.379.779.584.002]
    
    > (rou:fl [%f & --12 (add a 1)])
    [%f s=%.y e=--22 a=9.923.327.354.911.608.283.591.379.779.584.002]
    
    > (rou:fl [%f & --12 (add a 300)])
    [%f s=%.y e=--22 a=9.923.327.354.911.608.283.591.379.779.584.002]
    
    > (rou:fl [%f & --12 (add a 1.000)])
    [%f s=%.y e=--22 a=9.923.327.354.911.608.283.591.379.779.584.003]
<


`++syn:fl`~

Get sign

Produces the sign of `a`.

Accepts~

`a` is an `fn`.

Produes~

An `fn`.

Source~
>
    ++  syn
      |=  [a=fn]  ^-  ?
      ?-(-.a %f s.a, %i s.a, %n &)
<

Examples~
>
    > (syn:fl (sun:fl 106))
    %.y
    
    > (syn:fl [%f | --0 106])
    %.n
<


`++abs:fl`~

Absolute value

Produces the absolute value of `a`.

Accepts~

`a` is an `fn`.

Produes~

An `fn`.

Sources~
>
    ++  abs
      |=  [a=fn]  ^-  fn
      ?:  ?=([%f *] a)  [%f & e.a a.a]
      ?:  ?=([%i *] a)  [%i &]  [%n ~]
<

Examples~
>
    > (abs:fl [%f | --0 106])
    [%f s=%.y e=--0 a=106]
    
    > (abs:fl [%f & --0 106])
    [%f s=%.y e=--0 a=106]
<


`++add:fl`~

Add

Produces the sum of `a` plus `b`.

Accepts~

`a` is an `fn`.

`b` is an `fn`.

Produces~

An `fn`.

Source~
>
    ++  add
      |=  [a=fn b=fn]  ^-  fn
      ?:  |(?=([%n *] a) ?=([%n *] b))  [%n ~]
      ?:  |(?=([%i *] a) ?=([%i *] b))
        ?:  &(?=([%i *] a) ?=([%i *] b))
          ?:  =(a b)  a  [%n ~]
        ?:  ?=([%i *] a)  a  b
      ?:  |(=(a.a 0) =(a.b 0))
        ?.  &(=(a.a 0) =(a.b 0))  %-  rou  ?~(a.a b a)
        [%f ?:(=(r %d) &(s.a s.b) |(s.a s.b)) zer]
      %-  |=  [a=fn]
          ?.  ?=([%f *] a)  a
          ?.  =(a.a 0)  a
          [%f !=(r %d) zer]
      ?:  =(s.a s.b)
        ?:  s.a  (^add +>.a +>.b |)
        =.(r swr (fli (^add +>.a +>.b |)))
      ?:  s.a  (^sub +>.a +>.b |)
      (^sub +>.b +>.a |)
<

Examples~
>
    > (add:fl [%f & --0 106] [%f | --3 55])
    [%f s=%.n e=-104 a=6.774.324.807.619.657.921.598.381.929.529.344]
<


`++ead:fl`~

Exact add

Produces the exact sum of `a` plus `b`.

Accepts~

`a` is an `fn`.

`b` is an `fn`.

Produces~

An `fn`.

Source~
>
    ++  ead
      |=  [a=fn b=fn]  ^-  fn
      ?:  |(?=([%n *] a) ?=([%n *] b))  [%n ~]
      ?:  |(?=([%i *] a) ?=([%i *] b))
        ?:  &(?=([%i *] a) ?=([%i *] b))
          ?:  =(a b)  a  [%n ~]
        ?:  ?=([%i *] a)  a  b
      ?:  |(=(a.a 0) =(a.b 0))
        ?.  &(=(a.a 0) =(a.b 0))  ?~(a.a b a)
        [%f ?:(=(r %d) &(s.a s.b) |(s.a s.b)) zer]
      %-  |=  [a=fn]
          ?.  ?=([%f *] a)  a
          ?.  =(a.a 0)  a
          [%f !=(r %d) zer]
      ?:  =(s.a s.b)
        ?:  s.a  (^add +>.a +>.b &)
        (fli (^add +>.a +>.b &))
      ?:  s.a  (^sub +>.a +>.b &)
      (^sub +>.b +>.a &)
<

Examples~
>
    > (ead:fl [%f & --0 106] [%f | --3 55])
    [%f s=%.n e=--0 a=334]
<


`++sub:fl`~

Subtract

Produces the difference of `a` minus `b`.

Accepts~

`a` is an `fn`.

`b` is an `fn`.

Produces~

An `fn`.

Source~
>
    ++  sub
      |=  [a=fn b=fn]  ^-  fn  (add a (fli b))
<

Examples~
>
    > (sub:fl [%f & --13 2.718] [%f & --23 11])
    [%f s=%.n e=-86 a=5.416.671.014.775.224.232.595.412.796.571.648]
<


`++mul:fl`~

Multiply

Produces the product of `a` multiplied by `b`.

Accepts~

`a` is an `fn`.

`b` is an `fn`.

Produces~

An `fn`.

Source~
>
    ++  mul
      |=  [a=fn b=fn]  ^-  fn
      ?:  |(?=([%n *] a) ?=([%n *] b))  [%n ~]
      ?:  ?=([%i *] a)
        ?:  ?=([%i *] b)
          [%i =(s.a s.b)]
        ?:  =(a.b 0)  [%n ~]  [%i =(s.a s.b)]
      ?:  ?=([%i *] b)
        ?:  =(a.a 0)  [%n ~]  [%i =(s.a s.b)]
      ?:  |(=(a.a 0) =(a.b 0))  [%f =(s.a s.b) zer]
      ?:  =(s.a s.b)  (^mul +>.a +>.b)
      =.(r swr (fli (^mul +>.a +>.b)))
<


`++emu:fl`~

Exact multiply

Produces the exact product of `a` multiplied by `b`.

Accepts~

`a` is an `fn`.

`b` is an `fn`.

Produces~

An `fn`.

Examples~
>
    ++  emu
      |=  [a=fn b=fn]  ^-  fn
      ?:  |(?=([%n *] a) ?=([%n *] b))  [%n ~]
      ?:  ?=([%i *] a)
        ?:  ?=([%i *] b)
          [%i =(s.a s.b)]
        ?:  =(a.b 0)  [%n ~]  [%i =(s.a s.b)]
      ?:  ?=([%i *] b)
        ?:  =(a.a 0)  [%n ~]  [%i =(s.a s.b)]
      ?:  |(=(a.a 0) =(a.b 0))  [%f =(s.a s.b) zer]
      [%f =(s.a s.b) (sum:si e.a e.b) (^^mul a.a a.b)]
<


`++div:fl`~

Divide

Produces the quotient of `a` divided by `b`.

Accepts~

`a` is an `fn`.

`b` is an `fn`.

Produces~

An `fn`.

Source~
>
    ++  div
      |=  [a=fn b=fn]  ^-  fn
      ?:  |(?=([%n *] a) ?=([%n *] b))  [%n ~]
      ?:  ?=([%i *] a)
        ?:  ?=([%i *] b)  [%n ~]  [%i =(s.a s.b)]
      ?:  ?=([%i *] b)  [%f =(s.a s.b) zer]
      ?:  =(a.a 0)  ?:  =(a.b 0)  [%n ~]  [%f =(s.a s.b) zer]
      ?:  =(a.b 0)  [%i =(s.a s.b)]
      ?:  =(s.a s.b)  (^div +>.a +>.b)
      =.(r swr (fli (^div +>.a +>.b)))
<


`++fma:fl`~

Fused multiply-add

Produces the sum of `c` plus the product of `a` multiplied by `b`; `(a * b) +
c`.

Accepts~

`a` is an `fn`.

`b` is an `fn`.

`c` is an `fn`.

Produces~

An `fn`.

Source~
>
    ++  fma
      |=  [a=fn b=fn c=fn]  ^-  fn
      (add (emu a b) c)
<

Examples~
>
    > (fma:fl [%f & --13 2.718] [%f & --23 11] [%f & --13 2.718])
    [%f s=%.y e=-62 a=9.475.054.514.089.037.465.004.673.635.188.736]=
<


`++sqt:fl`~

Square root

Produces the square root of `a`.

Accepts~

`a` is an `fn`.

Produces~

An `fn`.

Source~
>
    ++  sqt
      |=  [a=fn]  ^-  fn
      ?:  ?=([%n *] a)  [%n ~]
      ?:  ?=([%i *] a)  ?:(s.a a [%n ~])
      ?~  a.a  [%f s.a zer]
      ?:  s.a  (^sqt +>.a)  [%n ~]
<

Examples~
>
    > (sqt:fl [%f s=%.y e=-18 a=342.602.577])
    [%f s=%.y e=-107 a=5.865.903.143.604.945.574.132.671.852.050.553]
<


`++inv:fl`~

Inverse

Produces the inverse of `a` by dividing `1` by `a`.

Accepts~

`a` is an `fn`.

Produces~

An `fn`.

Source~
>
    ++  inv
      |=  [a=fn]  ^-  fn
      (div [%f & --0 1] a)
<

Examples~
>
    > (inv:fl [%f s=%.y e=--0 a=10])
    [%f s=%.y e=-116 a=8.307.674.973.655.724.205.648.794.126.752.154]
    > (drg:fl [%f s=%.y e=-116 a=8.307.674.973.655.724.205.648.794.126.752.154])
    [%d s=%.y e=-1 a=1]
    
    > (inv:fl [%f s=%.y e=--1 a=10])
    [%f s=%.y e=-117 a=8.307.674.973.655.724.205.648.794.126.752.154]
    > (drg:fl [%f s=%.y e=-117 a=8.307.674.973.655.724.205.648.794.126.752.154])
    [%d s=%.y e=-2 a=5]
    
    > (inv:fl [%f s=%.y e=--2 a=10])
    [%f s=%.y e=-118 a=8.307.674.973.655.724.205.648.794.126.752.154]
    > (drg:fl [%f s=%.y e=-118 a=8.307.674.973.655.724.205.648.794.126.752.154])
    [%d s=%.y e=-3 a=25]
<


`++sun:fl`~

Signed integer to float

Produces `a` in floating-point representation.

Accepts~

`a` is an unsigned integer.

Produces~

An `fn`.

Source~
>
    ++  sun
      |=  [a=@u]  ^-  fn
      (rou [%f & --0 a])
<

Examples~
>
    > (sun:fl 0)
    [%f s=%.y e=--0 a=0]
    
    > (sun:fl 5.048.729)
    [%f s=%.y e=-90 a=6.250.023.776.601.238.669.911.180.544.311.296]
    
    > (sun:fl -100)
    ! exit
<


`++san:fl`~

Signed integer to float

Produces the floating-point representation of `a`, an unsigned integer.

Accepts~

`a` is an unsigned integer.

Produces~

An `fn`.

Source~
>
    ++  san
      |=  [a=@s]  ^-  fn
      =+  b=(old:si a)
      (rou [%f -.b --0 +.b])
<

Examples~
>
    > (san:fl --100)
    [%f s=%.y e=-106 a=8.112.963.841.460.668.169.578.900.514.406.400]
    
    > (san:fl -100)
    [%f s=%.n e=-106 a=8.112.963.841.460.668.169.578.900.514.406.400]
<


`++lth:fl`~

Less than

Tests if `a` is less than `b`. Returns `~` in the event of `a` or `b` being a
NaN (`[%n ~]`).

Accepts~

`a` is an `fn`.

`b` is an `fn`.

Produces~

A `unit` of `flag`.

Source~
>
    ++  lth
      |=  [a=fn b=fn]  ^-  (unit ?)
      ?:  |(?=([%n *] a) ?=([%n *] b))  ~  :-  ~
      ?:  =(a b)  |
      ?:  ?=([%i *] a)  !s.a  ?:  ?=([%i *] b)  s.b
      ?:  |(=(a.a 0) =(a.b 0))
        ?:  &(=(a.a 0) =(a.b 0))  |
        ?:  =(a.a 0)  s.b  !s.a
      ?:  !=(s.a s.b)  s.b
      ?:  s.a  (^lth +>.a +>.b)  (^lth +>.b +>.a)
<

Examples~
>
    > (lth:fl (sun:fl 116) (sun:fl 4.820))
    [~ u=%.y]
    
    > (lth:fl (sun:fl 218.116) (sun:fl 4.820))
    [~ u=%.n]
    
    > (lth:fl (sun:fl 218.116) [%n ~])
    ~
<


`++lte:fl`~

Less than or equal

Tests whether `a` is less than or equal to `b`. Returns `~` in the event of
`a` or `b` being a NaN (`[%n ~]`).

Accepts~

`a` is an `fn`.

`b` is an `fn`.

Produces~

A `unit` of `flag`.

Source~
>
    ++  lte
      |=  [a=fn b=fn]  ^-  (unit ?)
      %+  bind  (lth b a)  |=  a=?  !a
<

Examples~
>
    > (lte:fl (sun:fl 102) [%f %.y -5 973.655.724])
    [~ u=%.y]
    
    > (lte:fl (sun:fl 102) [%f %.y -24 973.655.724])
    [~ u=%.n]
    
    > (lte:fl [%f %.y --2 25] (sun:fl 100))
    [~ u=%.y]
    
    > (lte:fl [%f %.y --2 25] [%f %.y --3 2])
    [~ u=%.n]
    
    > (lte:fl [%f %.y --2 25] [%n ~])
    ~
<


`++equ:fl`~

Equals

Tests if `a` is equal to `b`. Returns `~` in the event of `a` or `b` being a
NaN (`[%n ~]`).

Accepts~

`a` is an `fn`.

`b` is an `fn`.

Produces~

An `unit` of `flag`.

Source~
>
    ++  equ
      |=  [a=fn b=fn]  ^-  (unit ?)
      ?:  |(?=([%n *] a) ?=([%n *] b))  ~  :-  ~
      ?:  =(a b)  &
      ?:  |(?=([%i *] a) ?=([%i *] b))  |
      ?:  |(=(a.a 0) =(a.b 0))
        ?:  &(=(a.a 0) =(a.b 0))  &  |
      ?:  |(=(e.a e.b) !=(s.a s.b))  |
      (^equ +>.a +>.b)
<

Examples~
>
    > (equ:fl [%f %.y --2 25] (sun:fl 100))
    [~ u=%.y]
    
    > (equ:fl [%f %.y --2 25] (sun:fl 101))
    [~ u=%.n]
<


`++gte:fl`~

Greater or equal than

Tests whether `a` is greater than or equal to `b`. Returns `~` in the event of
`a` or `b` being a NaN (`[%n ~]`).

Accepts~

`a` is an `fn`.

`b` is an `fn`.

Produces~

An `unit` of `flag`.

Source~
>
    ++  gte
      |=  [a=fn b=fn]  ^-  (unit ?)  (lte b a)
<

Examples~
>
    > (gte:fl [%f %.y --2 25] (sun:fl 100))
    [~ u=%.y]
    
    > (gth:fl [%f %.y --6 73.989] [%f %.y --5 919.599])
    [~ u=%.n]
    
    > (gth:fl [%f %.y --6 73.989] [%n ~])
    ~
<


`++gth:fl`~

Greater than

Tests whether `a` is greater than `b`. Returns `~` in the event of `a` or `b`
being a NaN (`[%n ~]`).

Accepts~

`a` is an `fn`.

`b` is an `fn`.

Produces~

An `unit` of `flag`.

Source~
>
    ++  gth
      |=  [a=fn b=fn]  ^-  (unit ?)  (lth b a)
<

Examples~
>
    > (gth:fl [%f %.y --2 25] (sun:fl 100))
    [~ u=%.n]
    
    > (gth:fl [%f %.y --6 73.989] [%f %.y --5 119.599])
    [~ u=%.y]
<


`++drg:fl`~

Float to decimal

Produces the decimal form of `a` using the Dragon4 algorithm. Guarantees
accurate results for rounded floats.

Accepts~

`a` is an `fn`.

Produces~

A `dn`.

Source~
>
    ++  drg
      |=  [a=fn]  ^-  dn
      ?:  ?=([%n *] a)  [%n ~]
      ?:  ?=([%i *] a)  [%i s.a]
      ?~  a.a  [%d s.a --0 0]
      [%d s.a (^drg +>.a)]
<

Examples~
>
    > (drg:fl [%f | --6 73.989])
    [%d s=%.n e=--0 a=4.735.296]
<


`++grd:fl`~

Decimal to float

Converts decimal `a` to `fn`.

Accepts~

`a` is a `dn`.

Produces~

An `fn`.

Source~
>
    ++  grd
      |=  [a=dn]  ^-  fn
      ?:  ?=([%n *] a)  [%n ~]
      ?:  ?=([%i *] a)  [%i s.a]
      =>  .(r %n)
      =+  q=(abs:si e.a)
      ?:  (syn:si e.a)
        (mul [%f s.a --0 a.a] [%f & e.a (pow 5 q)])
      (div [%f s.a --0 a.a] [%f & (sun:si q) (pow 5 q)])
<

Examples~
>
    > (grd:fl [%d s=%.n e=--0 a=73.989])
    [%f s=%.n e=-96 a=5.862.012.516.267.904.074.208.723.341.410.304]
    
    > (grd:fl [%d s=%.n e=--0 a=100])
    [%f s=%.n e=-106 a=8.112.963.841.460.668.169.578.900.514.406.400]
<


`++toi:fl`~

Round to signed integer

Rounds `a` to the nearest signed integer.

Accepts~

`a` is an `fn`.

Produces~

A `unit` of `@s`.

Source~
>
    ++  toi
      |=  [a=fn]  ^-  (unit @s)
      =+  b=(toj a)
      ?.  ?=([%f *] b)  ~  :-  ~
      =+  c=(^^mul (bex (abs:si e.b)) a.b)
      (new:si s.b c)
<

Examples~
>
    > (toi:fl [%f s=%.y e=-78 a=8.112.963.841.460.668.169.578.900.514.406.400])
    [~ u=--26.843.545.600]
<


`++toj:fl`~

Round to integer fn

Rounds `a` to the nearest decimal integer.

Accepts~

`a` is an `fn`.

Produces~

A `unit` of `@s`.

Source~
>
    ++  toj
      |=  [a=fn]  ^-  fn
      ?.  ?=([%f *] a)  a
      ?~  a.a  [%f s.a zer]
      ?:  s.a  (^toj +>.a)
      =.(r swr (fli (^toj +>.a)))
<

Examples~
>
    > (toj:fl [%f s=%.y e=-78 a=8.112.963.841.460.668.169.578.900.514.406.400])
    [%f s=%.y e=--0 a=26.843.545.600]
    
    > (toj:fl [%f s=%.y e=-78 a=8.112.963.841.460.668.169.578.900.514])
    [%f s=%.y e=--0 a=26.844]
    
    > (toj:fl [%f s=%.y e=-78 a=8.112.963.841.460])
    [%f s=%.y e=--0 a=0]
    
    > (toj:fl [%f s=%.y e=-9 a=9.002])
    [%f s=%.y e=--0 a=16]
<


------------------------------------------------------------------------------
FF                                                                  *++ff*

IEEE-754 Formatting

Container core for IEEE-754 formatting operations.

- `w` is width: The number of bits in the exponent field.
- `p` is precision: The number of bits in the significand field.
- `w` is bias: Added to exponent when storing.
- `r` is rounding mode: Possible modes are nearest (`%n`), up (`%u`), down
(`%d`), to zero (`%z`), and away from zero (`%a`). Default value is `%a`.


Source~
>
    ++  ff
      |_  [[w=@u p=@u b=@s] r=$?(%n %u %d %z %a)]
<

Examples~
>
    > =ffcore ~(. ff [8 8 0] %n)
    > ffcore
    <24.ull [[[@ud @ud @ud] r=%n] <51.qbt 123.ppa 46.hgz 1.pnw %140>]>
<


Discussion~

`++ff` has no use outside of the functionality provided to other cores:
`++rd`, `++rs`, `++rq`, and `++rh`. It's not intended to be used directly;
it's just meant to power those cores.


`++sb:ff`~

Sign bit

Produces the sign bit of `++ff`.

Source~
>
    ++  sb  (bex (^add w p))
<

Examples~
>
    > sb:ff
    1
<


`++me:ff`~

Minimum exponent

Produces the minimum possible exponent of `ff`.

Source~
>
    ++  me  (dif:si (dif:si --1 b) (sun:si p))
<

Examples~
>
    > me:ff
    --1
<


`++pa:ff`~

Initialize `fl`

Instantiates the core `fl`, giving values to its samples based on the
configuration of the `ff` core.

Source~
>
    ++  pa
      %*(. fl p +(p), v me, w (^sub (bex w) 3), d %d, r r)
<

Examples~
>
    > ~(pa ff [11 52 --1.023] %n)
    < 23.qzd
      28.btz
      { {{p/@ v/@s w/@} r/?($n $u $a $d $z) d/$d}
        <54.tyv 119.wim 31.ohr 1.jmk $143>
      }
    >
<

Discussion~

`++pa` exists exclusively for internal use of `++ff`, and `++ff` exists for
internal use in other cores.


`++sea:ff`~

`@r` to `fn`

Converts `a` from `@r` to `fn`.

Accepts~

`a` is a `@r`, an IEEE float.

Produces~

A `unit` of `@s`.

Source~
>
    ++  sea
      |=  [a=@r]  ^-  fn
      =+  [f=(cut 0 [0 p] a) e=(cut 0 [p w] a)]
      =+  s=(sig a)
      ?:  =(e 0)
        ?:  =(f 0)  [%f s --0 0]  [%f s me f]
      ?:  =(e (fil 0 w 1))
        ?:  =(f 0)  [%i s]  [%n ~]
      =+  q=:(sum:si (sun:si e) me -1)
      =+  r=(^add f (bex p))
      [%f s q r]
<

Examples~
>
    > (sea:ff `@r`0x8)
    [%f s=%.y e=--0 a=0]
<


`++bit:ff`~

`fn` to `@r`, rounding

Converts `a` from `fn` to `@r` and applies rounding.

Accepts~

`a` is an `fn`.

Produces~

A `@r`.

Source~
>
    ++  bit  |=  [a=fn]  (bif (rou:pa a))
<

Examples~
>
    > (bit:ma:rd [%f | -6 202])
    0xc009400000000000
<


`++bif:ff`~

`fn` to `@r`, no rounding

Converts `a` from `fn` to `@r`. No rounding is applied.

Accepts~

`a` is a `@r`, an IEEE float.

Produces~

A `flag`.

Source~
>
    ++  bif
      |=  [a=fn]  ^-  @r
      ?:  ?=([%i *] a)
        =+  q=(lsh [0 p] (fil 0 w 1))
        ?:  s.a  q  (^add q sb)
      ?:  ?=([%n *] a)  (lsh [0 (dec p)] (fil 0 +(w) 1))
      ?~  a.a  ?:  s.a  `@r`0  sb
      =+  ma=(met 0 a.a)
      ?.  =(ma +(p))
        ?>  =(e.a me)
        ?>  (^lth ma +(p))
        ?:  s.a  `@r`a.a  (^add a.a sb)
      =+  q=(sum:si (dif:si e.a me) --1)
      =+  r=(^add (lsh [0 p] (abs:si q)) (end [0 p] a.a))
      ?:  s.a  r  (^add r sb)
<

Examples~
>
    > (bif:ma:rd *fn)
    0x7ff8000000000000
<


`++sig:ff`~

Get sign

Produces the sign of `a`.

Accepts~

`a` is a `@r`, an IEEE float.

Produces~

A `flag`.

Source~
>
    ++  sig
      |=  [a=@r]  ^-  ?
      =(0 (cut 0 [(^add p w) 1] a))
<

Examples~
>
    > (sig:ff `@r`5)
    %.n
<


`++exp:ff`~

Get exponent

Produces the exponent of `a`.

Accepts~

`a` is a `@r`, an IEEE float.

Produces~

A signed integer.

Source~
>
    ++  exp
      |=  [a=@r]  ^-  @s
      (dif:si (sun:si (cut 0 [p w] a)) b)
<

Examples~
>
    > (exp:ff `@r`5)
    --0
<


`++add:ff`~

Add

Produces the sum of `a` plus `b`.

Accepts~

`a` is a `@r`, an IEEE float.

`b` is a `@r`, an IEEE float.

Produces~

A `@r`, an IEEE float.

Source~
>
    ++  add
      |=  [a=@r b=@r]
      (bif (add:pa (sea a) (sea b)))
<

Examples~
>
    > (add:ma:rd `@r`5 `@r`11)
    0x10
<


`++sub:ff`~

Sub

Produces the sum of `a` plus `b`.

Accepts~

`a` is a `@r`, an IEEE float.

`b` is a `@r`, an IEEE float.

Produces~

A `@r`, an IEEE float.

Source~
>
    ++  sub
      |=  [a=@r b=@r]
      (bif (sub:pa (sea a) (sea b)))
<

Examples~
>
    > (sub:ma:rd `@r`5 `@r`11)
    0x8000000000000006
<


`++mul:ff`~

Multiply

Produces the product of `a` multiplied by `b`.

Accepts~

`a` is a `@r`, an IEEE float.

`b` is a `@r`, an IEEE float.

Produces~

A `@r`, an IEEE float.

Multiply~
>
    ++  mul
      |=  [a=@r b=@r]
      (bif (mul:pa (sea a) (sea b)))
<

Examples~
>
    > (mul:ma:rd `@r`11 `@r`2)
    0x0
<


`++div:ff`~

Divide

Produces the quotient of `a` divided by `b`.

Accepts~

`a` is a `@r`, an IEEE float.

`b` is a `@r`, an IEEE float.

Produces~

A `@r`, an IEEE float.

Source~
>
    ++  div
      |=  [a=@r b=@r]
      (bif (div:pa (sea a) (sea b)))
<

Examples~
>
    > (div:ma:rd `@r`175 `@r`26)
    0x401aec4ec4ec4ec4
<


`++fma:ff`~

Fused multiply-add

Produces the sum of `c` plus the product of `a` multiplied by `b`; `(a * b) +
c`.

Accepts~

`a` is a `@r`, an IEEE float.

`b` is a `@r`, an IEEE float.

`c` is a `@r`, an IEEE float.

Produces~

A `@r`, an IEEE float.

Source~
>
    ++  fma
      |=  [a=@r b=@r c=@r]
      (bif (fma:pa (sea a) (sea b) (sea c)))
<

Examples~
>
    > (fma:ma:rd `@r`175 `@r`26 `@r`100)
    0x64
<


`++sqt:ff`~

Square root

Produces the square root of `a`.

Accepts~

`a` is a `@r`, an IEEE float.

Produces~

A `@r`, an IEEE float.

Source~
>
    ++  sqt
      |=  [a=@r]
      (bif (sqt:pa (sea a)))
<

Examples~
>
    > (sqt:ma:rd `@r`175)
    0x1e9a751f9447b724
<


`++lth:ff`~

Less than

Tests whether `a` is less than `b`.

Accepts~

`a` is a `@r`, an IEEE float.

`b` is a `@r`, an IEEE float.

Produces~

A `flag`.

Source~
>
    ++  lth
      |=  [a=@r b=@r]  (fall (lth:pa (sea a) (sea b)) |)
<

Examples~
>
    > (lth:ma:rd `@rd`1 `@rd`2)
    %.y
    
    > (lth:ma:rd `@rd`10 `@rd`2)
    %.n
<


`++lte:ff`~

Less than or equal to

Tests whether `a` is less than or equal to `b`.

Accepts~

`a` is a `@r`, an IEEE float.

`b` is a `@r`, an IEEE float.

Produces~

A `flag`.

Source~
>
    ++  lte
      |=  [a=@r b=@r]  (fall (lte:pa (sea a) (sea b)) |)
<

Examples~
>
    > (lte:ma:rd `@rd`10 `@rd`2)
    %.n
    
    > (lte:ma:rd `@rd`10 `@rd`10)
    %.y
<


`++equ:ff`~

Equals

Tests whether `a` is equal to `b`.

Accepts~

`a` is a `@r`, an IEEE float.

`b` is a `@r`, an IEEE float.

Produces~

A `flag`.

Source~
>
    ++  equ
      |=  [a=@r b=@r]  (fall (equ:pa (sea a) (sea b)) |)
<

Examples~
>
    > (equ:ma:rd `@rd`10 `@rd`2)
    %.n
    
    > (equ:ma:rd `@rd`10 `@rd`10)
    %.y
<


`++gte:ff`~

Greater or equal than

Tests whether `a` is greater than or equal to `b`.

Accepts~

`a` is a `@r`, an IEEE float.

`b` is a `@r`, an IEEE float.

Produces~

A `flag`.

Source~
>
    ++  gte
      |=  [a=@r b=@r]  (fall (gte:pa (sea a) (sea b)) |)
<

Examples~
>
    > (gte:ma:rd `@rd`10 `@rd`10)
    %.y
    
    > (gte:ma:rd `@rd`10 `@rd`11)
    %.n
<


`++gth:ff`~

Greater than

Tests whether `a` is greater than or equal to `b`.

Accepts~

`a` is a `@r`, an IEEE float.

`b` is a `@r`, an IEEE float.

Produces~

A `flag`.

Source~
>
    ++  gth
      |=  [a=@r b=@r]  (fall (gth:pa (sea a) (sea b)) |)
<

Examples~
>
    > (gth:ma:rd `@rd`10 `@rd`10)
    %.n
    
    > (gth:ma:rd `@rd`10 `@rd`9)
    %.y
<


`++sun:ff`~

Unsigned integer to `@r`

Converts `a` from an unsigned integer (`@u`) to `@r`.

Accepts~

`a` is `@u`, unsigned integer.

Produces~

A `@r`, an IEEE float.

Source~
>
    ++  sun
      |=  [a=@u]  (bit [%f & --0 a])
<

Examples~
>
    > (sun:ma:rd 658.149.282)
    0x41c39d47d1000000
<


`++san:ff`~

Signed integer to `@r`

Converts `a` from a signed integer to `@r`.

Accepts~

`a` is `@s`, an unsigned integer

Produces~

A `@r`, an IEEE float.

Source~
>
    ++  san
      |=  [a=@s]  (bit [%f (syn:si a) --0 (abs:si a)])
<

Examples~
>
    > (san:ma:rd --10)
    0x4024000000000000
<


`++toi:ff`~

Round to integer

Rounds `a` to the nearest signed integer.

Accepts~

`a` is a `@r`, an IEEE float.

Produces~

A `flag` of `@s`.

Source~
>
    ++  toi
      |=  [a=@r]  (toi:pa (sea a))
<

Examples~
>
    > (toi:ma:rd `@r`0x4af)
    [~ u=--0]
<


`++drg:ff`~

`@r` to decimal float

Converts `a` from `@r` to `dn` using the Dragon4 algorithm.

Accepts~

`a` is a `@r`, an IEEE float.

Produces~

A `dn`.

Source~
>
    ++  drg
      |=  [a=@r]  (drg:pa (sea a))
<

Examples~
>
    > (drg:ma:rd `@r`0x41c0)
    [%d s=%.y e=-323 a=8.316]
    
    > (drg:ma:rd (sun:ma:rd 658.149.282))
    [%d s=%.y e=--0 a=658.149.282]
<


`++grd:ff`~

Decimal float to `@r`

Converts `a` from `dn` to `@r`.

Accepts~

`a` is a `dn`.

Produces~

A `@r`, an IEEE float.

Source~
>
    ++  grd
      |=  [a=dn]  (bif (grd:pa a))
<

Examples~
>
    > (grd:ma:rd [%d s=%.y e=--0 a=658.149.282])
    0x41c39d47d1000000
<


------------------------------------------------------------------------------
RLYD                                                                  *++rlyd*

Prep `@rd` for print

Converts `a` from a double-precision binary float to decimal64.

Accepts~

`a` is a `@rd`, a double-precision float.

Produces~

A `dn`.

Source~
>
    ++  rlyd  |=  a=@rd  ^-  dn  (drg:rd a)
<

Examples~
>
    > (rlyd .~2.4703e-320)
    [%d s=%.y e=-324 a=24.703]
<


------------------------------------------------------------------------------
RLYS                                                                  *++rlys*

Prep @rs for print

Converts `a` from a single-precision binary float to decimal32.

Accepts~

`a` is a `@rs`, a single-precision float.

Produces~

A `dn`.

Source~
>
    ++  rlys  |=  a=@rs  ^-  dn  (drg:rs a)
<

Examples~
>
    > (rlys .1.681557e-39)
    [%d s=%.y e=-45 a=1.681.557]
<


------------------------------------------------------------------------------
RLYH                                                                  *++rlyh*

Prep `@rh` for print

Converts `a` from a half-precision binary float to decimal16.

Accepts~

`a` is a `@rh`, a half-precision float.

Produces~

A `dn`.

Source~
>
    ++  rlyh  |=  a=@rh  ^-  dn  (drg:rh a)
<

Examples~
>
    > (rlyh .~~3e1)
    [%d s=%.y e=--1 a=3]
<


------------------------------------------------------------------------------
RLYQ                                                                  *++rlyq*

Prep `@rq` for print

Converts `a` from a quad-precision binary float to decimal128.

Accepts~

`a` is a `@rq`, a quad-precision float.

Produces~

A `dn`.

Source~
>
    ++  rlyq  |=  a=@rq  ^-  dn  (drg:rq a)
<

Examples~
>
    > (rlyq .~~~2.2628017865927756787440310766086816e-4343)
    [%d s=%.y e=-4.377 a=22.628.017.865.927.756.787.440.310.766.086.816]
<


------------------------------------------------------------------------------
RYLD                                                                  *++ryld*

Finish parsing `@rd`

Converts `a` from a decimal float to a double-precision binary float.

Accepts~

`a` is a `dn`.

Produces~

A a `@rd`, a double-precision float.

Source~
>
    ++  ryld  |=  a=dn  ^-  @rd  (grd:rd a)
<

Examples~
>
    > (ryld [%d s=%.y e=-324 a=24.703])
    .~2.4703e-320
<


------------------------------------------------------------------------------
RYLS                                                                  *++ryls*

Finish parsing `@rs`

Converts `a` from a decimal float to a single-precision binary float.

Accepts~

`a` is a `dn`.

Produces~

A a `@rs`, a single-precision float.

Source~
>
    ++  ryls  |=  a=dn  ^-  @rs  (grd:rs a)
<

Examples~
>
    > (ryls [%d s=%.y e=-324 a=24.703])
    .0
    
    > (ryls [%d s=%.y e=-32 a=24.703])
    .2.4703e-28
<


------------------------------------------------------------------------------
RYLH                                                                  *++rylh*

Finish parsing `@rh`

Converts `a` from a decimal float to a half-precision binary float.

Accepts~

`a` is a `dn`.

Produces~

A a `@rh`, a half-precision float.

Source~
>
    ++  rylh  |=  a=dn  ^-  @rh  (grd:rh a)
<

Examples~
>
    > (rylh [%d s=%.y e=--1 a=703])
    .~~7.032e3
    
    > (rylh [%d s=%.y e=--3 a=56])
    .~~5.6e4
    
    > (rylh [%d s=%.y e=--4 a=56])
    .~~inf
<


------------------------------------------------------------------------------
RYLQ                                                                  *++rylq*

Finish parsing `@rq`

Converts `a` from a decimal float to a quad-precision binary float.

Accepts~

`a` is a `dn`.

Produces~

A a `@rq`, a quad-precision float.

Source~
>
    ++  rylq  |=  a=dn  ^-  @rq  (grd:rq a)
<

Examples~
>
    > (rylq [%d s=%.y e=-324 a=24.703])
    .~~~2.4703e-320
<


------------------------------------------------------------------------------
RD                                                                  *++rd*

Double-precision fp

A container core for operations related to double-precision binary floats.

`++rd` has four rounding modes: round to nearest (`%n`), round up (`%u`),
round down (`%d`), and round to zero (`%z`). The default rounding mode is
`%z`. If you need a different rounding mode, you'd do something like `=/  rd-n
~(. rd %n)` and then call the arms of your modified version instead.

Source~
>
    ++  rd
      ^|
      ~%  %rd  +>  ~
      |_  r=$?(%n %u %d %z)
<


`++ma:rd`~

Initialize `ff`

Instantiates the core `ff`, giving values to its samples based on the
configuration of the `rd` core. This arm is used internally by `++rd`, you
would not normally call this directly.

Source~
>
    ++  ma
      %*(. ff w 11, p 52, b --1.023, r r)
<

Examples~
>
    > ~(ma rd %n)
    < 24.ltg
      {{{w/@ud p/@ud b/@sd} r/?($n $u $d $z)} <54.tyv 119.wim 31.ohr 1.jmk $143>}
    >
<


`++sea:rd`~

`@rd` to `fn`

Converts `a` from a double-precision binary float to `fn`.

Source~
>
    ++  sea
      |=  [a=@rd]  (sea:ma a)
<

Examples~
>
    > (sea:rd .~4.94066e-319)
    [%f s=%.y e=-1.074 a=100.000]
<


`++bit:rd`~

`fn` to `@rd`

Converts `a` from `fn` to a double-precision binary float.

Accepts~

`a` is an `fn`.

Produces~

A `@rd`, a double-precision float.

Source~
>
    ++  bit
      |=  [a=fn]  ^-  @rd  (bit:ma a)
<

Examples~
>
    > (bit:rd [%f s=%.y e=-1.074 a=100.000])
    .~4.94066e-319
<


`++add:rd`~

Add

Produces the sum of `a` plus `b`.

Accepts~

`a` is a `@rd`, a double-precision float.

`b` is a `@rd`, a double-precision float.

Produces~

A `@rd`.

Source~
>
    ++  add  ~/  %add
      |=  [a=@rd b=@rd]  ^-  @rd
      ~_  leaf+"rd-fail"
      (add:ma a b)
<

Examples~
>
    > (add:rd .~3.94066e12 .~9.2846e11)
    .~4.86912e12
<


`++sub:rd`~

Subtract

Produces the difference of `a` minus `b`.

Accepts~

`a` is a `@rd`, a double-precision float.

`b` is a `@rd`, a double-precision float.

Produces~

A `@rd`.

Source~
>
    ++  sub  ~/  %sub
      |=  [a=@rd b=@rd]  ^-  @rd
      ~_  leaf+"rd-fail"
      (sub:ma a b)
<

Examples~
>
    > (sub:rd .~7.94069e2 .~1.2846e3)
    .~-4.9053099999999995e2
<


`++mul:rd`~

Multiply

Produces the product of `a` times `b`.

Accepts~

`a` is a `@rd`, a double-precision float.

`b` is a `@rd`, a double-precision float.

Produces~

A `@rd`.

Source~
>
    ++  mul  ~/  %mul
      |=  [a=@rd b=@rd]  ^-  @rd
      ~_  leaf+"rd-fail"
      (mul:ma a b)
<

Examples~
>
    > (mul:rd .~7.94069e2 .~1.2246e3)
    .~9.724168973999998e5
<


`++div:rd`~

Divide

Produces the quotient of `a` divided by `b`.

Accepts~

`a` is a `@rd`, a double-precision float.

`b` is a `@rd`.

Produces~

A `@rd`.

Source~
>
    ++  div  ~/  %div
      |=  [a=@rd b=@rd]  ^-  @rd
      ~_  leaf+"rd-fail"
      (div:ma a b)
<

Examples~
>
    > (div:rd .~7.94099e2 .~1.2246e3)
    .~6.484558223093255e-1
<


`++fma:rd`~

Fused multiply-add

Produces the sum of `c` plus the product of `a` multiplied by `b`; `(a * b) +
c`.

Accepts~

`a` is a `@rd`, an IEEE float.

`b` is a `@rd`.

`c` is a `@rd`.

Produces~

A `@rd`.

Source~
>
    ++  fma  ~/  %fma
      |=  [a=@rd b=@rd c=@rd]  ^-  @rd
      ~_  leaf+"rd-fail"
      (fma:ma a b c)
<

Examples~
>
    > (fma:rd .~7.94099e2 .~1.2246e3 .~3.94066e3)
    .~9.763942954e5
<


`++sqt:rd`~

Square root

Produces the square root of `a`.

Accepts~

`a` is a `@rd`, a double-precision float.

Produces~

A `@rd`.

Source~
>
    ++  sqt  ~/  %sqt
      |=  [a=@rd]  ^-  @rd  ~_  leaf+"rd-fail"
      (sqt:ma a)
<

Examples~
>
    > (sqt:rd .~3.94066e3)
    .~6.2774676422901614e1
<


`++lth:rd`~

Less than

Test whether `a` is less than `b`.

Accepts~

`a` is a `@rd`, a double-precision float.

`b` is a `@rd`, a double-precision float.

Produces~

A `@rd`.

Source~
>
    ++  lth  ~/  %lth
      |=  [a=@rd b=@rd]
      ~_  leaf+"rd-fail"
      (lth:ma a b)
<

Examples~
>
    > (lth:rd .~7.94099e2 .~1.2246e3)
    %.y
    
    > (lth:rd .~7.94099e2 .~1.2246e2)
    %.n
    
    > (lth:rd .~1.2246e2 .~1.2246e2)
    %.n
<


`++lte:rd`~

Less than or equal

Test whether `a` is less than or equal to `b`.

Accepts~

`a` is a `@rd`, a double-precision float.

`b` is a `@rd`, a double-precision float.

Produces~

A `@rd`.

Source~
>
    ++  lte  ~/  %lte
      |=  [a=@rd b=@rd]
      ~_  leaf+"rd-fail"
      (lte:ma a b)
<

Examples~
>
    > (lte:rd .~7.94099e2 .~1.2246e3)
    %.y
    
    > (lte:rd .~7.94099e2 .~1.2246e2)
    %.n
    
    > (lte:rd .~1.2246e2 .~1.2246e2)
    %.y
<


`++equ:rd`~

Equals

Test whether `a` is equal to `b`.

Accepts~

`a` is a `@rd`, a double-precision float.

`b` is a `@rd`, a double-precision float.

Produces~

A `@rd`.

Source~
>
    ++  equ  ~/  %equ
      |=  [a=@rd b=@rd]
      ~_  leaf+"rd-fail"
      (equ:ma a b)
<

Examples~
>
    > (equ:rd .~7.94099e2 .~1.2246e3)
    %.n
    
    > (equ:rd .~7.94099e2 .~1.2246e2)
    %.n
    
    > (equ:rd .~1.2246e2 .~1.2246e2)
    %.y
<


`++gte:rd`~

Greater than or equal

Test whether `a` is greater than or equal to `b`.

Accepts~

`a` is a `@rd`, a double-precision float.

`b` is a `@rd`, a double-precision float.

Produces~

A `@rd`.

Source~
>
    ++  gte  ~/  %gte
      |=  [a=@rd b=@rd]
      ~_  leaf+"rd-fail"
      (gte:ma a b)
<

Examples~
>
    > (gte:rd .~7.94099e2 .~1.2246e3)
    %.n
    
    > (gte:rd .~7.94099e2 .~1.2246e2)
    %.y
    
    > (gte:rd .~1.2246e2 .~1.2246e2)
    %.y
<


`++gth:rd`~

Greater than

Test whether `a` is greater `b`.

Accepts~

`a` is a `@rd`, a double-precision float.

`b` is a `@rd`, a double-precision float.

Produces~

A `@rd`.

Source~
>
    ++  gth  ~/  %gth
      |=  [a=@rd b=@rd]
      ~_  leaf+"rd-fail"
      (gth:ma a b)
<

Examples~
>
    > (gth:rd .~7.94099e2 .~1.2246e3)
    %.n
    
    > (gth:rd .~7.94099e2 .~1.2246e2)
    %.y
    
    > (gth:rd .~1.2246e2 .~1.2246e2)
    %.n
<


`++sun:rd`~

Unsigned integer to `@rd`

Converts an unsigned integer `a` to `@rd`.

Accepts~

`a` is a `@u`, an unsigned integer.

Produces~

A `@rd`.

Source~
>
    ++  sun  |=  [a=@u]  ^-  @rd  (sun:ma a)
<

Examples~
>
    > (sun:rd 511)
    .~5.11e2
<


`++san:rd`~

Signed integer to `@rd`

Converts a signed integer `a` to `@rd`.

Accepts~

`a` is a `@s`, a signed integer.

Produces~

A `@rd`.

Source~
>
    ++  san  |=  [a=@s]  ^-  @rd  (san:ma a)
<

Examples~
>
    > (san:rd -511)
    .~-5.11e2
<


`++sig:rd`~

Get sign

Produces the sign of `a`.

Accepts~

`a` is a `@rd`

Produces~

A `flag`.

Source~
>
    ++  sig  |=  [a=@rd]  ^-  ?  (sig:ma a)
<

Examples~
>
    > (sig:rd .~1.2246e3)
    %.y
<


`++exp:rd`~

Get exponent

Produces the exponent of `a`.

Accepts~

`a` is a `@rd`

Produces~

A `@s`.

Source~
>
    ++  exp  |=  [a=@rd]  ^-  @s  (exp:ma a)
<

Examples~
>
    > (exp:rd .~1.2246e3)
    --10
<


`++toi:rd`~

Round to integer

Rounds `a` to the nearest integer.

Accepts~

`a` is a `@rd`

Produces~

A `unit` of `@s`.

Source~
>
    ++  toi  |=  [a=@rd]  ^-  (unit @s)  (toi:ma a)
<

Examples~
>
    > (toi:rd .~1.2246e3)
    [~ u=--1.224]
<


`++drg:rd`~

`@rd` to decimal float

Produces the decimal form of `a` using the Dragon4 algorithm. Guarantees
accurate results for rounded floats.

Accepts~

`a` is a `@rd`

Produces~

A `dn`.

Source~
>
    ++  drg  |=  [a=@rd]  ^-  dn  (drg:ma a)
<

Examples~
>
    > (drg:rd .~1.2246e3)
    [%d s=%.y e=-1 a=12.246]
<


`++grd:rd`~

Decimal float to `@rd`

Converts `a` from decimal float to `@rd`.

Accepts~

`a` is a `@dn`

Produces~

A `@rd`.

Source~
>
    ++  grd  |=  [a=dn]  ^-  @rd  (grd:ma a)
<

Examples~
>
    > (grd:rd [%d s=%.y e=-1 a=12.246])
    .~1.2246e3
<


------------------------------------------------------------------------------
RS                                                                  *++rs*

Single-precision fp

A container core for operations related to single-precision binary floats.

`++rs` has four rounding modes: round to nearest (`%n`), round up (`%u`),
round down (`%d`), and round to zero (`%z`). The default rounding mode is
`%z`. If you need a different rounding mode, you'd do something like `=/  rs-n
~(. rs %n)` and then call the arms of your modified version instead.

Source~
>
    ++  rs
      ~%  %rs  +>  ~
      ^|
      |_  r=$?(%n %u %d %z)
<


`++ma:rs`~

Initialize `ff`

Instantiates the core `ff`, giving values to its samples based on the
configuration of the `rs` core. This arm is used internally by `++rs`, you
would not normally call this directly.

Source~
>
    ++  ma
      %*(. ff w 8, p 23, b --127, r r)
<

Examples~
>
    > ~(ma rs %n)
    < 24.ltg
      {{{w/@ud p/@ud b/@sd} r/?($n $u $d $z)} <54.tyv 119.wim 31.ohr 1.jmk $143>}
    >
<


`++sea:rs`~

`@rs` to `fn`

Converts `a` from `@rs` to `fn`.

Accepts~

`a` is a `@rs`, an single-precision float.

Produces~

An `fn`.

Source~
>
    ++  sea
      |=  [a=@rs]  (sea:ma a)
<

Examples~
>
    > (sea:rs .1.4e-43)
    [%f s=%.y e=-149 a=100]
<


`++bit:rs`~

`fn` to `@rs`

Converts `a` from `fn` to `@rs`.

Accepts~

`a` is an `fn`.

Produces~

A `@rs`, a single-precision float.

Source~
>
    ++  bit
      |=  [a=fn]  ^-  @rs  (bit:ma a)
<

Examples~
>
    > (bit:rs [%f & -2 1.000])
    .2.5e2
<


`++add:rs`~

Add

Produces the sum of `a` plus `b`.

Accepts~

`a` is a `@rs`, a single-precision float.

`b` is a `@rs`.

Produces~

A `@rs`.

Source~
>
    ++  add  ~/  %add
      |=  [a=@rs b=@rs]  ^-  @rs
      ~_  leaf+"rs-fail"
      (add:ma a b)
<

Examples~
>
    > (add:rs .2.5e1 .2.5e2)
    .2.75e2
<


`++sub:rs`~

Subtract

Subtracts `a` from `b`.

Accepts~

`a` is a `@rs`.

`b` is a `@rs`.

Source~
>
    ++  sub  ~/  %sub
      |=  [a=@rs b=@rs]  ^-  @rs
      ~_  leaf+"rs-fail"
      (sub:ma a b)
<

Examples~
>
    > (sub:rs .2.5e1 .2.5e2)
    .-2.25e2
<


`++mul:rs`~

Multiply

Produces the product of `a` multiplied by `b`.

Accepts~

`a` is a `@rs`, a single-precision float.

`b` is a `@rs`.

Produces~

A `@rs`.

Source~
>
    ++  mul  ~/  %mul
      |=  [a=@rs b=@rs]  ^-  @rs
      ~_  leaf+"rs-fail"
      (mul:ma a b)
<

Examples~
>
    > (mul:rs .2.5e1 .2.5e2)
    .6.25e3
<


`++div:rs`~

Divide

Produces the quotient of `a` divided by `b`.

Accepts~

`a` is a `@rs`, a single-precision float.

`b` is a `@rs`.

Produces~

A `@rs`.

Source~
>
    ++  div  ~/  %div
      |=  [a=@rs b=@rs]  ^-  @rs
      ~_  leaf+"rs-fail"
      (div:ma a b)
<

Examples~
>
    > (div:rs .4.5e1 .2.2e2)
    .2.0454545e-1
<


`++fma:rs`~

Fused multiply-add

Produces the sum of `c` plus the product of `a` multiplied by `b`; `(a * b) +
c`.

Accepts~

`a` is a `@rs`, a single-precision float.

`b` is a `@rs`.

`c` is a `@rs`.

Produces~

A `@rs`.

Source~
>
    ++  fma  ~/  %fma
      |=  [a=@rs b=@rs c=@rs]  ^-  @rs
      ~_  leaf+"rs-fail"
      (fma:ma a b c)
<

Examples~
>
    > (fma:rs .2.5e1 .2.5e2 .8.2e1)
    .6.332e3
<


`++sqt:rs`~

Square root

Produces the square root of `a`.

Accepts~

`a` is a `@rs`, a single-precision float.

Produces~

A `@rs`.

Source~
>
    ++  sqt  ~/  %sqt
      |=  [a=@rs]  ^-  @rs
      ~_  leaf+"rs-fail"
      (sqt:ma a)
<

Examples~
>
    > (sqt:rs .2.5e2)
    .1.5811388e1
<


`++lth:rs`~

Less than

Test whether `a` is less than `b`.

Accepts~

`a` is a `@rs`, a single-precision float.

`b` is a `@rs`.

Produces~

A `@rs`.

Source~
>
    ++  lth  ~/  %lth
      |=  [a=@rs b=@rs]
      ~_  leaf+"rs-fail"
      (lth:ma a b)
<

Examples~
>
    > (lth:rs .9.9e1 .1.1e2)
    %.y
    
    > (lth:rs .9.9e1 .9.9e1)
    %.n
<


`++lte:rs`~

Less than or equal

Test whether `a` is less than or equal to `b`.

Accepts~

`a` is a `@rs`, a single-precision float.

`b` is a `@rs`.

Produces~

A `@rs`.

Source~
>
    ++  lte  ~/  %lte
      |=  [a=@rs b=@rs]
      ~_  leaf+"rs-fail"
      (lte:ma a b)
<

Examples~
>
    > (lte:rs .9.9e1 .1.1e2)
    %.y
    
    > (lte:rs .9.9e1 .9.9e1)
    %.y
<


`++equ:rs`~

Equals

Test whether `a` is equal to `b`.

Accepts~

`a` is a `@rs`, a single-precision float.

`b` is a `@rs`.

Produces~

A `@rs`.

Source~
>
    ++  equ  ~/  %equ
      |=  [a=@rs b=@rs]
      ~_  leaf+"rs-fail"
      (equ:ma a b)
<

Examples~
>
    > (equ:rs .9.9e1 .1.1e2)
    %.n
    
    > (equ:rs .9.9e1 .9.9e1)
    %.y
<


`++gte:rs`~

Greater than or equal

Test whether `a` is greater than or equal to `b`.

Accepts~

`a` is a `@rs`, a single-precision float.

`b` is a `@rs`.

Produces~

A `@rs`.

Source~
>
    ++  gte  ~/  %gte
      |=  [a=@rs b=@rs]
      ~_  leaf+"rs-fail"
      (gte:ma a b)
<

Examples~
>
    > (gte:rs .9.9e1 .9.9e1)
    %.y
    
    > (gte:rs .9.9e1 .9.2e2)
    %.n
<


`++gth:rs`~

Greater than

Test whether `a` is greater than `b`.

Accepts~

`a` is a `@rs`, a single-precision float.

`b` is a `@rs`.

Produces~

A `@rs`.

Source~
>
    ++  gth  ~/  %gth
      |=  [a=@rs b=@rs]
      ~_  leaf+"rs-fail"
      (gth:ma a b)
<

Examples~
>
    > (gth:rs .9.9e1 .9.2e2)
    %.n
    
    > (gth:rs .9.9e1 .9.9e1)
    %.n
    
    > (gth:rs .9.9e1 .1.9e1)
    %.y
<


`++sun:rs`~

Unsigned integer to `@rs`

Converts `a` from an unsigned integer to `@rs`.

Accepts~

`a` is an unsigned integer.

Produces~

A `@rs`.

Source~
>
    ++  sun  |=  [a=@u]  ^-  @rs  (sun:ma a)
<

Examples~
>
    > (sun:rs 343)
    .3.43e2
<


`++san:rs`~

Signed integer to `@rs`'

Converts `a` from an unsigned integer to `@rs`.

Accepts~

`a` is a signed integer.

Produces~

A `@rs`.

Source~
>
    ++  san  |=  [a=@s]  ^-  @rs  (san:ma a)
<

Examples~
>
    > (san:rs -343)
    .-3.43e2'
<


`++sig:rs`~

Get sign

Produces the sign of `a`.

Accepts~

`a` is a `@rs`.

Produces~

A `flag`.

Source~
>
    ++  sig  |=  [a=@rs]  ^-  ?  (sig:ma a)
<

Examples~
>
    > (sig:rs .3.43e2)
    %.y
    
    > (sig:rs .-3.43e2)
    %.n
<


`++exp:rs`~

Get exponent

Produces the exponent of `a`.

Accepts~

`a` is a `@rs`.

Produces~

A signed integer.

Source~
>
    ++  exp  |=  [a=@rs]  ^-  @s  (exp:ma a)
<

Examples~
>
    > (exp:rs .-3.43e2)
    --8
<


`++toi:rs`~

Round to integer

Rounds `a` to the nearest integer.

Accepts~

`a` is a `@rs`.

Produces~

A `unit` of `@s`.

Source~
>
    ++  toi  |=  [a=@rs]  ^-  (unit @s)  (toi:ma a)
<

Examples~
>
    > (toi:rs .-3.43e2)
    [~ u=-343]
<


`++drg:rs`~

`@rs` to decimal float

Produces the decimal form of `a` using the Dragon4 algorithm. Guarantees
accurate results for rounded floats.

Accepts~

`a` is a `@rs`

Produces~

A `dn`.

Source~
>
    ++  drg  |=  [a=@rs]  ^-  dn  (drg:ma a)
<

Examples~
>
    > (drg:rs .-3.43e2)
    [%d s=%.n e=--0 a=343]
<


`++grd:rs`~

Decimal float to `@rs`

Converts `a` from `dn` to `@rs`.

Accepts~

`a` is a `dn`.

Produces~

A `@rs`.

Source~
>
    ++  grd  |=  [a=dn]  ^-  @rs  (grd:ma a)
<

Examples~
>
    > (grd:rs [%d s=%.n e=--0 a=343])
    .-3.43e2
<


------------------------------------------------------------------------------
RQ                                                                  *++rq*

Quadruple-precision fp

A container core for operations related to quadruple-precision binary floats.

`++rq` has four rounding modes: round to nearest (`%n`), round up (`%u`),
round down (`%d`), and round to zero (`%z`). The default rounding mode is
`%z`. If you need a different rounding mode, you'd do something like `=/  rq-n
~(. rq %n)` and then call the arms of your modified version instead.

Source~
>
    ++  rq
      ~%  %rq  +>  ~
      ^|
      |_  r=$?(%n %u %d %z)
<

`++ma:rq`~

Initialize `ff`

Instantiates the core `ff`, giving values to its samples based on the
configuration of the `rq` core. This arm is used internally by `++rq`, you
would not normally call this directly.

Source~
>
    ++  ma
      %*(. ff w 15, p 112, b --16.383, r r)
<


`++sea:rq`~

`@rq` to `fn`

Converts `a` from `@rq` to `fn`.

Accepts~

`a` is a `@rq`, a quad-precision float.

Produces~

An `fn`.

Source~
>
    ++  sea
      |=  [a=@rq]  (sea:ma a)
<

Examples~
>
    > (sea:rq .~~~1.05102e5)
    [%f s=%.y e=-96 a=8.327.038.336.574.210.409.756.656.268.214.272]
<


`++bit:rq`~

`fn` to `@rq`

Converts `a` from `fn` to `@rq`.

Accepts~

`a` is an `fn`.

Produces~

A `@rq`, a quad-precision float.

Source~
>
    ++  bit
      |=  [a=fn]  ^-  @rq  (bit:ma a)
<

Examples~
>
    > (bit:rq [%f s=%.y e=-96 a=8.327.038.336.574.210.409.756.656.268.214.272])
    .~~~1.05102e5
<


`++add:rq`~

Add

Produces the sum of `a` plus `b`.

Accepts~

`a` is a `@rq`, a quad-precision float.

`b` is a `@rq`.

Produces~

A `@rq`.

Source~
>
    ++  add  ~/  %add
      |=  [a=@rq b=@rq]  ^-  @rq
      ~_  leaf+"rq-fail"
      (add:ma a b)
<

Examples~
>
    > (add:rq .~~~-1.821e5 .~~~1.05102e5)
    .~~~-7.6998e4
<


`++sub:rq`~

Subtract

Produces the difference of `a` minus `b`.

Accepts~

`a` is a `@rq`, a quad-precision float.

`b` is a `@rq`.

Produces~

A `@rq`.

Source~
>
    ++  sub  ~/  %sub
      |=  [a=@rq b=@rq]  ^-  @rq
      ~_  leaf+"rq-fail"
      (sub:ma a b)
<

Examples~
>
    > (sub:rq .~~~1.821e5 .~~~1.05102e5)
    .~~~7.6998e4
    
    > (sub:rq .~~~1.821e5 .~~~-1.05102e5)
    .~~~2.87202e5
<


`++mul:rq`~

Multiply

Produces the product of `a` times `b`.

Accepts~

`a` is a `@rq`, a quad-precision float.

`b` is a `@rq`.

Produces~

A `@rq`.

Source~
>
    ++  mul  ~/  %mul
      |=  [a=@rq b=@rq]  ^-  @rq
      ~_  leaf+"rq-fail"
      (mul:ma a b)
<

Examples~
>
    > (mul:rq .~~~1.821e5 .~~~-1.05102e5)
    .~~~-1.91390742e10
<


`++div:rq`~

Divide

Produces the product of `a` divided by `b`.

Accepts~

`a` is a `@rq`, a quad-precision float.

`b` is a `@rq`.

Produces~

A `@rq`.

Source~
>
    ++  div  ~/  %div
      |=  [a=@rq b=@rq]  ^-  @rq
      ~_  leaf+"rq-fail"
      (div:ma a b)
<

Examples~
>
    > (div:rq .~~~1.821e5 .~~~1.05102e3)
    .~~~1.732602614602957127361991208540275e2
<


`++fma:rq`~

Fused multiply-add

Produces the sum of `c` plus the product of `a` multiplied by `b`; `(a * b) +
c`.

Accepts~

`a` is a `@rq`, a quad-precision float.

`b` is a `@rq`.

`c` is a `@rq`.

Produces~

A `@rq`.

Source~
>
    ++  fma  ~/  %fma
      |=  [a=@rq b=@rq c=@rq]  ^-  @rq
      ~_  leaf+"rq-fail"
      (fma:ma a b c)
<

Examples~
>
    > (fma:rq .~~~1.821e5 .~~~-1.05102e2 .~~~6.2044e7)
    .~~~4.29049258e7
<


`++sqt:rq`~

Square root

Produces the square root of `a`.

Accepts~

`a` is a `@rq`, a quad-precision float.

Produces~

A `@rq`.

Source~
>
    ++  sqt  ~/  %sqt
      |=  [a=@rq]  ^-  @rq
      ~_  leaf+"rq-fail"
      (sqt:ma a)
<

Examples~
>
    > (sqt:rq .~~~6.2044e7)
    .~~~7.876801381271461258959876570289002e3
<


`++lth:rq`~

Less than

Tests whether `a` is less than `b`.

Accepts~

`a` is a `@rq`, a quad-precision float.

`b` is a `@rq`.

Produces~

A `@rq`.

Source~
>
    ++  lth  ~/  %lth
      |=  [a=@rq b=@rq]
      ~_  leaf+"rq-fail"
      (lth:ma a b)
<

Examples~
>
    > (lth:rq .~~~1.2044e7 (mul:rq .~~~9.02e2 .~~~7.114e3))
    %.n
    
    > (lth:rq .~~~1.2044e7 (mul:rq .~~~9.02e3 .~~~7.114e3))
    %.y
<


`++lte:rq`~

Less than or equal

Tests whether `a` is less than or equal to `b`.

Accepts~

`a` is a `@rq`, a quad-precision float.

`b` is a `@rq`.

Produces~

A `@rq`.

Source~
>
    ++  lte  ~/  %lte
      |=  [a=@rq b=@rq]
      ~_  leaf+"rq-fail"
      (lte:ma a b)
<

Examples~
>
    > (lte:rq .~~~1.2044e7 (mul:rq .~~~9.02e2 .~~~7.114e3))
    %.n
    
    > (lte:rq .~~~1.2044e7 (mul:rq .~~~9.02e3 .~~~7.114e3))
    %.y
    
    > (lte:rq .~~~1.2044e7 .~~~1.2044e7)
    %.y
<


`++equ:rq`~

Equals

Tests whether `a` is equal to `b`.

Accepts~

`a` is a `@rq`, a quad-precision float.

`b` is a `@rq`.

Produces~

A `@rq`.

Source~
>
    ++  equ  ~/  %equ
      |=  [a=@rq b=@rq]
      ~_  leaf+"rq-fail"
      (equ:ma a b)
<

Examples~
>
    > (equ:rq .~~~1.2044e7 .~~~1.2044e7)
    %.y
    
    > (equ:rq .~~~2.2044e7 .~~~1.2044e7)
    %.n
<


`++gte:rq`~

Greater than or equal

Tests whether `a` is greater than or equal to `b`.

Accepts~

`a` is a `@rq`, a quad-precision float.

`b` is a `@rq`.

Produces~

A `@rq`.

Source~
>
    ++  gte  ~/  %gte
      |=  [a=@rq b=@rq]
      ~_  leaf+"rq-fail"
      (gte:ma a b)
<

Examples~
>
    > (gte:rq .~~~1.2044e7 .~~~1.2044e7)
    %.y
    
    > (gte:rq .~~~2.2044e7 .~~~1.2044e7)
    %.y
    
    > (gte:rq .~~~1.2044e7 .~~~2.2044e7)
    %.n
<


`++gth:rq`~

Tests whether `a` is greater than `b`.

Accepts~

`a` is a `@rq`, a quad-precision float.

`b` is a `@rq`.

Produces~

A `@rq`.

Source~
>
    ++  gth  ~/  %gth
      |=  [a=@rq b=@rq]
      ~_  leaf+"rq-fail"
      (gth:ma a b)
<

Examples~
>
    > (gth:rq .~~~1.2044e7 .~~~1.2044e7)
    %.n
    
    > (gth:rq .~~~2.2044e7 .~~~1.2044e7)
    %.y
    
    > (gth:rq .~~~1.2044e7 .~~~2.2044e7)
    %.n
<


`++sun:rq`~

Unsigned integer to `@rq`

Converts `@` from an unsigned integer to `@rq`.

Accepts~

`a` is a `@u`, an unsigned integer.

Produces~

A `@rq`, a quad-precision float.

Source~
>
    ++  sun  |=  [a=@u]  ^-  @rq  (sun:ma a)
<

Examples~
>
    > (sun:rq 205)
    .~~~2.05e2
<


`++san:rq`~

Signed integer to `rq`

Converts `@` from a signed integer to `@rq`.

Accepts~

`a` is a `@s`, a signed integer.

Produces~

A `@rq`, a quad-precision float.

Source~
>
    ++  san  |=  [a=@s]  ^-  @rq  (san:ma a)
<

Examples~
>
    > (san:rq -205)
    .~~~-2.05e2
<


`++sig:rq`~

Get sign

Produces the sign of `a`.

Accepts~

`a` is a `@rq`, a quad-precision float.

Produces~

A `flag`.

Source~
>
    ++  sig  |=  [a=@rq]  ^-  ?  (sig:ma a)
<

Examples~
>
    > (sig:rq .~~~-2.05e2)
    %.n
<


`++exp:rq`~

Get exponent

Gets the exponent of `a`.

Accepts~

`a` is a `@rq`, a quad-precision float.

Produces~

A `@s`, a signed integer.

Source~
>
    ++  exp  |=  [a=@rq]  ^-  @s  (exp:ma a)
<

Examples~
>
    > (exp:rq .~~~-2.05e2)
    --7
<


`++toi:rq`~

Round to integer

Rounds `a` to the nearest integer.

Accepts~

`a` is a `@rq`, a quad-precision float.

Produces~

A `unit` of `@s`.

Source~
>
    ++  toi  |=  [a=@rq]  ^-  (unit @s)  (toi:ma a)
<

Examples~
>
    > (toi:rq .~~~-2.085e2)
    [~ u=-208]
    
    > (toi:rq .~~~-2.08e2)
    [~ u=-208]
<


`++drg:rq`~

`@rq` to decimal float

Produces the decimal form of `a` using the Dragon4 algorithm. Guarantees
accurate results for rounded floats.

Accepts~

`a` is a `@rq`, a quad-precision float.

Produces~

A `dn`.

Source~
>
    ++  drg  |=  [a=@rq]  ^-  dn  (drg:ma a)
<

Examples~
>
    > (drg:rq .~~~-2.085e2)
    [%d s=%.n e=-1 a=2.085]
    
    > (drg:rq .~~~-2.08e2)
    [%d s=%.n e=--0 a=208]
<


`++grd:rq`~

Decimal float to `@rq`

Converts `a` from `dn` to `@rq`.

Accepts~

`a` is `dn`.

`a` is a `@rq`.

Produces~

A `@rq`, a quad-precision float.

Source~
>
    ++  grd  |=  [a=dn]  ^-  @rq  (grd:ma a)
<

Examples~
>
    > (grd:rq [%d s=%.n e=--0 a=343])
    .~~~-3.43e2
<


------------------------------------------------------------------------------
RH                                                                  *++rh*

Half-precision fp

A container core for operations related to half-precision binary floats.

`++rh` has four rounding modes: round to nearest (`%n`), round up (`%u`),
round down (`%d`), and round to zero (`%z`). The default rounding mode is
`%z`. If you need a different rounding mode, you'd do something like `=/  rh-n
~(. rh %n)` and then call the arms of your modified version instead.

Source~
>
    ++  rh
      ~%  %rh  +>  ~
      ^|
      |_  r=$?(%n %u %d %z)
<


`++ma:rh`~

Initialize `ff`

Instantiates the core `ff`, giving values to its samples based on the
configuration of the `rh` core. This arm is used internally by `++rh`, you
would not normally call this directly.

Source~
>
    ++  ma
      %*(. ff w 5, p 10, b --15, r r)
<


`++sea:rh`~

`@rh` to `fn`

Converts `a` from `@rh` to `fn`.

Accepts~

`a` is a `@rh`, a half-precision float.

Produces~

An `fn`.

Source~
>
    ++  sea
      |=  [a=@rh]  (sea:ma a)
<

Examples~
>
    > (sea:rh .~~1.22e-5)
    [%f s=%.y e=-24 a=205]
<


`++bit:rh`~

`fn` to `@rh`

Converts `a` from `fn` to `@rh`.

Accepts~

`a` is an `fn`.

Produces~

A `@rh`, a half-precision float.

Source~
>
    ++  bit
      |=  [a=fn]  ^-  @rh  (bit:ma a)
<

Examples~
>
    > (bit:rh [%f s=%.y e=-24 a=205])
    .~~1.22e-5
<


`++add:rh`~

Produces the sum of `a` plus `b`.

Accepts~

`a` is a `@rh`, a half-precision float.

`b` is a `@rh`.

Produces~

A `@rh`.

Source~
>
    ++  add  ~/  %add
      |=  [a=@rh b=@rh]  ^-  @rh
      ~_  leaf+"rh-fail"
      (add:ma a b)
<

Examples~
>
    > (add:rh .~~1.82e2 .~~1.02e2)
    .~~2.84e2
<


`++sub:rh`~

Subtract

Produces the difference of `a` minus `b`.

Accepts~

`a` is a `@rh`, a half-precision float.

`b` is a `@rh`.

Produces~

A `@rh`.

Source~
>
    ++  sub  ~/  %sub
      |=  [a=@rh b=@rh]  ^-  @rh
      ~_  leaf+"rh-fail"
      (sub:ma a b)
<

Examples~
>
    > (sub:rh .~~1.821e2 .~~1.051e2)
    .~~7.7e1
    
    > (sub:rh .~~1.821e2 .~~6.051e2)
    .~~-4.228e2
<


`++mul:rh`~

Multiply

Produces the product of `a` times `b`.

Accepts~

`a` is a `@rh`, a quad-precision float.

`b` is a `@rh`.

Produces~

A `@rh`.

Source~
>
    ++  mul  ~/  %mul
      |=  [a=@rh b=@rh]  ^-  @rh
      ~_  leaf+"rh-fail"
      (mul:ma a b)
<

Examples~
>
    > (mul:rh .~~1.821e1 .~~-1.05102e2)
    .~~-1.913e3
<


`++div:rh`~

Divide

Produces the product of `a` divided by `b`.

Accepts~

`a` is a `@rh`, a half-precision float.

`b` is a `@rh`.

Produces~

A `@rh`.

Source~
>
    ++  div  ~/  %div
      |=  [a=@rh b=@rh]  ^-  @rh
      ~_  leaf+"rh-fail"
      (div:ma a b)
<

examples~
>
    > (div:rh .~~1.821e3 .~~1.05102e2)
    .~~1.731e1
<


`++fma:rh`~

Fused multiply-add

Produces the sum of `c` plus the product of `a` multiplied by `b`; `(a * b) +
c`.

Accepts~

`a` is a `@rh`, a half-precision float.

`b` is a `@rh`.

`c` is a `@rh`.

Produces~

A `@rh`.

Source~
>
    ++  fma  ~/  %fma
      |=  [a=@rh b=@rh c=@rh]  ^-  @rh
      ~_  leaf+"rh-fail"
      (fma:ma a b c)
<

Examples~
>
    > (fma:rh .~~1.821e4 .~~-1.05102e2 .~~6.2044e3)
    .~~-6.55e4
<


`++sqt:rh`~

Square root

Produces the square root of `a`.

Accepts~

`a` is a `@rh`, a half-precision float.

Produces~

A `@rh`.

Source~
>
    ++  sqt  ~/  %sqt
      |=  [a=@rh]  ^-  @rh
      ~_  leaf+"rh-fail"
      (sqt:ma a)
<

Example~
>
    > (sqt:rh .~~6.24e4)
    .~~2.498e2
<


`++lth:rh`~

Less than

Tests whether `a` is less than `b`.

Accepts~

`a` is a `@rh`, a half-precision float.

`b` is a `@rh`.

Produces~

A `@rh`.

Source~
>
    ++  lth  ~/  %lth
      |=  [a=@rh b=@rh]
      ~_  leaf+"rh-fail"
      (lth:ma a b)
<

Examples~
>
    > (lth:rh .~~1.2e5 (mul:rh .~~9.02e2 .~~7.114e2))
    %.n
    
    > (lth:rh .~~1.2e3 (mul:rh .~~9.02e1 .~~7.114e2))
    %.y
<


`++lte:rh`~

Less than or equal

Tests whether `a` is less than or equal to `b`.

Accepts~

`a` is a `@rh`, a half-precision float.

`b` is a `@rh`.

Produces~

A `@rh`.

Source~
>
    ++  lte  ~/  %lte
      |=  [a=@rh b=@rh]
      ~_  leaf+"rh-fail"
      (lte:ma a b)
<

Examples~
>
    > (lte:rh .~~1.2e5 (mul:rh .~~9.02e2 .~~7.114e2))
    %.n
    
    > (lte:rh .~~1.2e3 (mul:rh .~~9.02e1 .~~7.114e2))
    %.y
    
    > (lte:rh .~~1.2e3 .~~1.2e3)
    %.y
<


`++equ:rh`~

Equals

Tests whether `a` is equal to `b`.

Accepts~

`a` is a `@rh`, a half-precision float.

`b` is a `@rh`.

Produces~

A `@rh`.

Source~
>
    ++  equ  ~/  %equ
      |=  [a=@rh b=@rh]
      ~_  leaf+"rh-fail"
      (equ:ma a b)
<

Examples~
>
    > (equ:rh .~~1.24e4 .~~1.24e4)
    %.y
    
    > (equ:rh .~~2.24e4 .~~1.24e4)
    %.n
<


`++gte:rh`~

Greater than or equal

Tests whether `a` is greater than or equal to `b`.

Accepts~

`a` is a `@rh`, a half-precision float.

`b` is a `@rh`.

Produces~

A `@rh`.

Source~
>
    ++  gte  ~/  %gte
      |=  [a=@rh b=@rh]
      ~_  leaf+"rh-fail"
      (gte:ma a b)
<

Examples~
>
    > (gte:rh .~~1.24e4 .~~1.24e4)
    %.y
    
    > (gte:rh .~~2.24e4 .~~1.24e4)
    %.y
    
    > (gte:rh .~~1.24e4 .~~2.24e4)
    %.n
<


`++gth:rh`~

Tests whether `a` is greater than `b`.

Accepts~

`a` is a `@rh`, a half-precision float.

`b` is a `@rh`.

Produces~

A `@rh`.

Source~
>
    ++  gth  ~/  %gth
      |=  [a=@rh b=@rh]
      ~_  leaf+"rh-fail"
      (gth:ma a b)
<

Examples~
>
    > (gth:rh .~~1.24e4 .~~1.244e4)
    %.n
    
    > (gth:rh .~~2.24e4 .~~1.24e4)
    %.y
    
    > (gth:rh .~~1.24e4 .~~2.24e4)
    %.n
<


`++tos:rh`~

`@rh` to `@rs`

Converts `@` from `@rh` to `@rs`.

Accepts~

`a` is a `@rh`, a half-precision float.

Produces~

A `@rs`, a single-precision float.

Source~
>
    ++  tos
      |=  [a=@rh]  (bit:rs (sea a))
<

Examples~
>
    > (tos:rh .~~2.5e2)
    .2.5e2
<


`++fos:rh`~

`@rs` to `@rh`

Converts `@` from `@rs` to `@rh`.

Accepts~

`a` is a `@rs`, a single-precision float.

Produces~

A `@rh`, a half-precision float.

Source~
>
    ++  fos
      |=  [a=@rs]  (bit (sea:rs a))
<

Examples~
>
    > (fos:rh .2.5e2)
    .~~2.5e2
<


`++sun:rh`~

Unsigned integer to `@rh`

Converts `@` from an unsigned integer to `@rh`.

Accepts~

`a` is a `@u`, an unsigned integer.

Produces~

A `@rh`, a half-precision float.

Source~
>
    ++  sun  |=  [a=@u]  ^-  @rh  (sun:ma a)
<

Examples~
>
    > (sun:rh 205)
    .~~2.05e2
<


`++san:rh`~

Signed integer to `@rh`

Converts `@` from a signed integer to `@rh`.

Accepts~

`a` is a `@s`, a signed integer.

Produces~

A `@rh`, a half-precision float.

Source~
>
    ++  san  |=  [a=@s]  ^-  @rh  (san:ma a)
<

Examples~
>
    > (san:rh -205)
    .~~-2.05e2
<


`++sig:rh`~

Get sign

Produces the sign of `a`.

Accepts~

`a` is a `@rh`, a half-precision float.

Produces~

A `flag`.

Source~
>
    ++  sig  |=  [a=@rh]  ^-  ?  (sig:ma a)
<

Examples~
>
    > (sig:rh .~~-2.05e2)
    %.n
<


`++exp:rh`~

Get exponent

Gets the exponent of `a`.

Accepts~

`a` is a `@rh`, a half-precision float.

Produces~

A `@s`, a signed integer.

Source~
>
    ++  exp  |=  [a=@rh]  ^-  @s  (exp:ma a)
<

Examples~
>
    > (exp:rh .~~-2.05e2)
    --7
<


`++toi:rh`~

Round to integer

Rounds `a` to the nearest integer.

Accepts~

`a` is a `@rh`, a half-precision float.

Produces~

A `unit` of `@s`.

Source~
>
    ++  toi  |=  [a=@rh]  ^-  (unit @s)  (toi:ma a)
<

Examples~
>
    > (toi:rh .~~-2.085e2)
    [~ u=-208]
    
    > (toi:rh .~~-2.08e2)
    [~ u=-208]
<


`++drg:rh`~

`@rh` to decimal float

Produces the decimal form of `a` using the Dragon4 algorithm. Guarantees
accurate results for rounded floats.

Accepts~

`a` is a `@rh`, a half-precision float.

Produces~

A `dn`.

Source~
>
    ++  drg  |=  [a=@rh]  ^-  dn  (drg:ma a)
<

Examples~
>
    > (drg:rh .~~-2.085e2)
    [%d s=%.n e=-1 a=2.085]
    
    > (drg:rh .~~-2.08e2)
    [%d s=%.n e=--0 a=208]
<


`++grd:rh`~

Decimal float to `@rh`

Converts `a` from `dn` to `@rh`.

Accepts~

`a` is `dn`.

`a` is a `@rh`.

Produces~

A `@rh`, a a half-precision float.

Source~
>
    ++  grd  |=  [a=dn]  ^-  @rh  (grd:ma a)
<

Examples~
>
    > (grd:rh [%d s=%.n e=--0 a=343])
    .~~-3.43e2
<



==============================================================================
 3c: Urbit Time                                                                         

------------------------------------------------------------------------------
YEAR                                                                  *++year*

Date to `@da`

Accept a parsed date of form `[[a=? y=@ud] m=@ud t=tarp]` and produce its
`@da` representation.

Accepts~

`det` is a `date`

Produces~

A `@da`.

Source~
>
    ++  year
      |=  det=date
      ^-  @da
      =+  ^=  yer
          ?:  a.det
            (add 292.277.024.400 y.det)
          (sub 292.277.024.400 (dec y.det))
      =+  day=(yawn yer m.det d.t.det)
      (yule day h.t.det m.t.det s.t.det f.t.det)
<

Examples~
>
    > (year [[a=%.y y=2.014] m=8 t=[d=4 h=20 m=4 s=57 f=~[0xd940]]])
    ~2014.8.4..20.04.57..d940
<


------------------------------------------------------------------------------
YORE                                                                  *++yore*

Date from atomic date

Produces a `date` from a `@da`.

Accepts~

`now` is a time atom, `@da`.

Produces~

A `date`.

Source~
>
    ++  yore
      |=  now=@da
      ^-  date
      =+  rip=(yell now)
      =+  ger=(yall d.rip)
      :-  ?:  (gth y.ger 292.277.024.400)
            [a=& y=(sub y.ger 292.277.024.400)]
          [a=| y=+((sub 292.277.024.400 y.ger))]
      [m.ger d.ger h.rip m.rip s.rip f.rip]
<

Examples~
>
    > (yore ~2014.6.6..21.09.15..0a16)
    [[a=%.y y=2.014] m=6 t=[d=6 h=21 m=9 s=15 f=~[0xa16]]]
<


------------------------------------------------------------------------------
YELL                                                                  *++yell*

Tarp from atomic date

Produce a `$tarp` time format from a`@da`.

Accepts~

`now` is a `@da`.

Produces~

A `tarp`.

Source~
>
    ++  yell
      |=  now=@d
      ^-  tarp
      =+  sec=(rsh 6 now)
      =+  ^=  fan
          =+  [muc=4 raw=(end 6 now)]
          |-  ^-  (list @ux)
          ?:  |(=(0 raw) =(0 muc))
            ~
          =>  .(muc (dec muc))
          [(cut 4 [muc 1] raw) $(raw (end [4 muc] raw))]
      =+  day=(div sec day:yo)
      =>  .(sec (mod sec day:yo))
      =+  hor=(div sec hor:yo)
      =>  .(sec (mod sec hor:yo))
      =+  mit=(div sec mit:yo)
      =>  .(sec (mod sec mit:yo))
      [day hor mit sec fan]
<

Examples~
>
    > (yell ~2014.3.20..05.42.53..7456)
    [d=106.751.991.820.094 h=5 m=42 s=53 f=~[0x7456]]
    
    > (yell ~2014.6.9..19.09.40..8b66)
    [d=106.751.991.820.175 h=19 m=9 s=40 f=~[0x8b66]]
    
    > (yell ~1776.7.4)
    [d=106.751.991.733.273 h=0 m=0 s=0 f=~]
<


------------------------------------------------------------------------------
YULE                                                                  *++yule*

Daily time to time atom

Accepts a `$tarp`, a parsed daily time, and produces a `@da`.

Accepts~

`rip` is a `tarp`.

Produces~

A time atom, `@da`.

Source~
>
    ++  yule
      |=  rip=tarp
      ^-  @d
      =+  ^=  sec  ;:  add
                     (mul d.rip day:yo)
                     (mul h.rip hor:yo)
                     (mul m.rip mit:yo)
                     s.rip
                   ==
      =+  ^=  fac  =+  muc=4
                   |-  ^-  @
                   ?~  f.rip
                     0
                   =>  .(muc (dec muc))
                   (add (lsh [4 muc] i.f.rip) $(f.rip t.f.rip))
      (con (lsh 6 sec) fac)
<

Examples~
>
    > =murica (yell ~1776.7.4)
    
    > murica
    [d=106.751.991.733.273 h=0 m=0 s=0 f=~]
    
    > (yule murica)
    0x8000000b62aaf5800000000000000000
    
    > `@da`(yule murica)
    ~1776.7.4
    
    > `@da`(yule (yell ~2014.3.20..05.42.53..7456))
    ~2014.3.20..05.42.53..7456
    
    > `tarp`[31 12 30 0 ~]
    [d=31 h=12 m=30 s=0 f=~]
    
    > `@dr`(yule `tarp`[31 12 30 0 ~])
    ~d31.h12.m30
<


------------------------------------------------------------------------------
YALL                                                                  *++yall*

Time since beginning of time

Produce the date tuple of `[y=@ud m=@ud d=@ud]` of the year, month, and day
from a number of days from the beginning of the Gregorian calendar.

Accepts~

`day` is a `@ud`.

Produces~

A cell of unsigned decimals.

Source~
>
    ++  yall
      |=  day=@ud
      ^-  [y=@ud m=@ud d=@ud]
      =+  [era=0 cet=0 lep=*?]
      =>  .(era (div day era:yo), day (mod day era:yo))
      =>  ^+  .
          ?:  (lth day +(cet:yo))
            .(lep &, cet 0)
          =>  .(lep |, cet 1, day (sub day +(cet:yo)))
          .(cet (add cet (div day cet:yo)), day (mod day cet:yo))
      =+  yer=(add (mul 400 era) (mul 100 cet))
      |-  ^-  [y=@ud m=@ud d=@ud]
      =+  dis=?:(lep 366 365)
      ?.  (lth day dis)
        =+  ner=+(yer)
        $(yer ner, day (sub day dis), lep =(0 (end [0 2] ner)))
      |-  ^-  [y=@ud m=@ud d=@ud]
      =+  [mot=0 cah=?:(lep moy:yo moh:yo)]
      |-  ^-  [y=@ud m=@ud d=@ud]
      =+  zis=(snag mot cah)
      ?:  (lth day zis)
        [yer +(mot) +(day)]
      $(mot +(mot), day (sub day zis))
<

Examples~
>
    > (yall 198)
    [y=0 m=7 d=17]
    
    > (yall 90.398)
    [y=247 m=7 d=3]
    
    > (yall 0)
    [y=0 m=1 d=1]
<


------------------------------------------------------------------------------
YAWN                                                                  *++yawn*

Days since beginning of time

Inverse of `yall`, computes number of days A.D. from y/m/d date as the tuple
`[yer=@ud mot=@ud day=@ud]`.

Accepts~

`yer` is an unsigned decimal.

`mon` is an unsigned decimal.

`day` is an unsigned decimal.

Produces~

An unsigned decimal.

Source~
>
    ++  yawn
      |=  [yer=@ud mot=@ud day=@ud]
      ^-  @ud
      =>  .(mot (dec mot), day (dec day))
      =>  ^+  .
          %=    .
              day
            =+  cah=?:((yelp yer) moy:yo moh:yo)
            |-  ^-  @ud
            ?:  =(0 mot)
              day
            $(mot (dec mot), cah (slag 1 cah), day (add day (snag 0 cah)))
          ==
      |-  ^-  @ud
      ?.  =(0 (mod yer 4))
        =+  ney=(dec yer)
        $(yer ney, day (add day ?:((yelp ney) 366 365)))
      ?.  =(0 (mod yer 100))
        =+  nef=(sub yer 4)
        $(yer nef, day (add day ?:((yelp nef) 1.461 1.460)))
      ?.  =(0 (mod yer 400))
        =+  nec=(sub yer 100)
        $(yer nec, day (add day ?:((yelp nec) 36.525 36.524)))
      (add day (mul (div yer 400) (add 1 (mul 4 36.524))))
<

Examples~
>
    > (yawn 2.018 7 4)
    737.244
    
    > (yawn 1.776 7 4)
    648.856
    
    > (yawn 1.990 10 11)
    727.116
<


------------------------------------------------------------------------------
YELP                                                                  *++yelp*

Leap year?

Determines whether a year is a leap year. Produces a flag.

Accepts~

`yer` is an unsigned decimal.

Produces~

A flag.

Source~
>
    ++  yelp
      |=  yer=@ud  ^-  ?
      &(=(0 (mod yer 4)) |(!=(0 (mod yer 100)) =(0 (mod yer 400))))
<

Examples~
>
    > (yelp 2.014)
    %.n
    
    > (yelp 2.008)
    %.y
    
    > (yelp 0)
    %.y
    
    > (yelp 14.011)
    %.n
<


------------------------------------------------------------------------------
YO                                                                  *++yo*

Time constants core

Core whose arms contain constants for interacting with earth time.

Source~
>
    ++  yo
<


`++cet:yo`~

Days in a century

Derived by multiplying the number of days in a year (365) by the number of
years in a century (100), then adding the number days from leap-years in a
century (24).

Produces~

An atom.

Source~
>
    ++  cet  36.524
<

Examples~
>
    > cet:yo
    36.524
    
    > (add 365 cet:yo)
    36.889
    
    > (sub (add 24 (mul 100 365)) cet:yo)
    0
<


`++day:yo`~

Seconds in day

The number of seconds in a day.

Produces~

An atom.

Source~
>
    ++  day  86.400
<

Examples~
>
    > day:yo
    86.400
    
    > (add 60 day:yo)
    86.460
<


`++era:yo`~

Leap-year period

The number of days in a 400-year period, arrived at by multiplying `cet` by
four and adding one. This is done because every 400 years, there is a leap-
year where there would otherwise not be.

Produces~

An atom.

Source~
>
    ++  era  146.097
<

Examples~
>
    > era:yo
    146.097
    
    > (sub era:yo (mul 4 cet:yo))
    1
<

Discussion~

A year is a leap-year if:

- it's divisible by 4;
- unless it's divisible by 100;
- or if it's divisible by 400.



`++hor:yo`~

Seconds in hour

The number of seconds in an hour. Derived by multiplying the number of seconds
in a minute by the minutes in an hour.

Produces~

An atom.

Source~
>
    ++  hor  3.600
<

Examples~
>
    > hor:yo
    3.600
    
    > (div hor:yo 60)
    60
<


`++jes:yo`~

Maximum 64-bit timestamp

This is the number of days (starting from 1970) that can be represented in a
64-bit timestamp. Derived by multiplying `era:yo` by 730,692,561.

Produces~

An atom.

Source~
>
    ++  jes  106.751.991.084.417
<

Examples~
>
    > jes:yo
    106.751.991.084.417
<

Discussion~

The date is December 4, 292,277,026,596.


`++mit:yo`~

Seconds in minute

The number of seconds in a minute.

Produces~

An atom.

Source~
>
    ++  mit  60
<

Examples~
>
    > mit:yo
    60
<


`++moh:yo`~

Days in month

The days in each month of the Gregorian common year. A list of unsigned
decimal atoms (Either 28, 30, or 31) denoting the number of days in the month
at the year at that index.

Produces~

A `list` of `@ud`

Source~
>
    ++  moh  `(list @ud)`[31 28 31 30 31 30 31 31 30 31 30 31 ~]
<

Examples~
>
    > moh:yo
    ~[31 28 31 30 31 30 31 31 30 31 30 31]
    
    > (snag 4 moh:yo)
    31
<


`++moy:yo`~

Days in months of leap-year

The days in each month of the Gregorian leap-year. A list of unsigned decimal
atoms (Either 29, 30, or 31) denoting the number of days in the month at the
leap-year at that index.

Produces~

A `list` of `@ud`.

Source~
>
    ++  moy  `(list @ud)`[31 29 31 30 31 30 31 31 30 31 30 31 ~]
<

Examples~
>
    > moy:yo
    ~[31 29 31 30 31 30 31 31 30 31 30 31]
    
    > (snag 1 moy:yo)
    29
<


`++qad:yo`~

Seconds in 4 years

The number of seconds in four years. Derived by adding one second to the
number of seconds in four years.

Produces~

An atom.

Source~
>
    ++  qad  126.144.001
<

Examples~
>
    > qad:yo
    126.144.001
<


`++yer:yo`~

Seconds in year

The number of seconds in a year. Derived by multiplying the number of seconds
in a day by 365.

Produces~

An atom.

Source~
>
    ++  yer  31.536.000
<

Examples~
>
    > yer:yo
    31.536.000
<



==============================================================================
 3d: SHA Hash Family                                                                         

------------------------------------------------------------------------------
SHAD                                                                  *++shad*

Double SHA-256

Produces an atom that is twice-hashed with `shax`, the SHA-256 cryptographic
hash algorithm.

Accepts~

`ruz` is an atom.

Produces~

An atom.

Source~
>
    ++  shad  |=(ruz=@ (shax (shax ruz)))
<

Examples~
>
    > `@uw`(shad 11)
    0w2Rt.J1gzO.JjsQc.0Komy.DYUUO.27koh.QxwE0.Qgwt7.EPGCi
<


------------------------------------------------------------------------------
SHAF                                                                  *++shaf*

Half SHA-256

Produces a 128-bit atom by performing the bitwise XOR on the first and last
halves of the 256-bit salted hash `shas`.

Accepts~

`sal` is an atom.

`ruz` is an atom.

Source~
>
    ++  shaf
      |=  [sal=@ ruz=@]
      =+  haz=(shas sal ruz)
      (mix (end 7 haz) (rsh 7 haz))
<

Examples~
>
    > `@uw`(shaf 17 8)
    0wD.DSP0L.WUuQg.-A765.4RY-h
<


------------------------------------------------------------------------------
SHAM                                                                  *++sham*

128-bit noun hash

Produces a 128-bit atom by hashing a noun `yux` with the `+shaf` function. If
that noun is a cell, then it is passed to the `jam` function to produce an
atom to be hashed.

Accepts~

`yux` is a noun.

Produces~

A `@uvH`.

Source~
>
    ++  sham
      |=  yux=*  ^-  @uvH  ^-  @
      ?@  yux
        (shaf %mash yux)
      (shaf %sham (jam yux))
<

Examples~
>
    > (sham [2 4])
    0v3.71s52.4bqnp.ki2b8.9hhsp.2ufgg
    
    > (sham "hello")
    0v1.hg8mv.t7s3f.u4f8a.q5noe.dvqvh
<


------------------------------------------------------------------------------
SHAS                                                                  *++shas*

Salted hash

Produces an atom by using SHA-256 plus a salt input. The bitwise XOR is
performed on salt `sal` and the product of atom `ruz` hashed with SHA-256. The
product of that logical operation is then itself hashed with SHA-256.

Accepts~

`sal` is an atom.

`ruz` is an atom.

Source~
>
    ++  shas
      ~/  %shas
      |=  [sal=@ ruz=@]
      (shax (mix sal (shax ruz)))
<

Examples~
>
    > `@uw`(shas 1 1)
    0w5hZ.Gim4L.9xKlU.jJJQr.2Bgi~.RHd5s.IwXuV.p43at.ZdsTY
<


------------------------------------------------------------------------------
SHAX                                                                  *++shax*

SHA-256

Produces an atom by hashing an atom `ruz` with SHA-256.

Sources~
>
    ++  shax
      ~/  %shax
      |=  ruz=@  ^-  @
      (shay [(met 3 ruz) ruz])
<

Examples~
>
    > `@uw`(shax 'foo')
    0waXD.pCa8n.EHVEb.-3p70.JgxcQ.gj0tf.4mr-o.~6~Sx.HJ2oI
<


------------------------------------------------------------------------------
SHAY                                                                  *++shay*

SHA-256 with length

Produces an atom by hashing an atom `ruz` with SHA-512. Another atom, `len`,
is the byte-length of the theoretical buffer represented by the atom.

Accepts~

`len` is an atom.

`ruz` is an atom.

Source~
>
    ++  shay
      ~/  %shay
      |=  [len=@u ruz=@]  ^-  @
      =>  .(ruz (cut 3 [0 len] ruz))
      =+  [few==>(fe .(a 5)) wac=|=([a=@ b=@] (cut 5 [a 1] b))]
      =+  [sum=sum.few ror=ror.few net=net.few inv=inv.few]
      =+  ral=(lsh [0 3] len)
      =+  ^=  ful
          %+  can  0
          :~  [ral ruz]
              [8 128]
              [(mod (sub 960 (mod (add 8 ral) 512)) 512) 0]
              [64 (~(net fe 6) ral)]
          ==
      =+  lex=(met 9 ful)
      =+  ^=  kbx  0xc671.78f2.bef9.a3f7.a450.6ceb.90be.fffa.
                     8cc7.0208.84c8.7814.78a5.636f.748f.82ee.
                     682e.6ff3.5b9c.ca4f.4ed8.aa4a.391c.0cb3.
                     34b0.bcb5.2748.774c.1e37.6c08.19a4.c116.
                     106a.a070.f40e.3585.d699.0624.d192.e819.
                     c76c.51a3.c24b.8b70.a81a.664b.a2bf.e8a1.
                     9272.2c85.81c2.c92e.766a.0abb.650a.7354.
                     5338.0d13.4d2c.6dfc.2e1b.2138.27b7.0a85.
                     1429.2967.06ca.6351.d5a7.9147.c6e0.0bf3.
                     bf59.7fc7.b003.27c8.a831.c66d.983e.5152.
                     76f9.88da.5cb0.a9dc.4a74.84aa.2de9.2c6f.
                     240c.a1cc.0fc1.9dc6.efbe.4786.e49b.69c1.
                     c19b.f174.9bdc.06a7.80de.b1fe.72be.5d74.
                     550c.7dc3.2431.85be.1283.5b01.d807.aa98.
                     ab1c.5ed5.923f.82a4.59f1.11f1.3956.c25b.
                     e9b5.dba5.b5c0.fbcf.7137.4491.428a.2f98
      =+  ^=  hax  0x5be0.cd19.1f83.d9ab.9b05.688c.510e.527f.
                     a54f.f53a.3c6e.f372.bb67.ae85.6a09.e667
      =+  i=0
      |-  ^-  @
      ?:  =(i lex)
        (run 5 hax net)
      =+  ^=  wox
          =+  dux=(cut 9 [i 1] ful)
          =+  wox=(run 5 dux net)
          =+  j=16
          |-  ^-  @
          ?:  =(64 j)
            wox
          =+  :*  l=(wac (sub j 15) wox)
                  m=(wac (sub j 2) wox)
                  n=(wac (sub j 16) wox)
                  o=(wac (sub j 7) wox)
              ==
          =+  x=:(mix (ror 0 7 l) (ror 0 18 l) (rsh [0 3] l))
          =+  y=:(mix (ror 0 17 m) (ror 0 19 m) (rsh [0 10] m))
          =+  z=:(sum n x o y)
          $(wox (con (lsh [5 j] z) wox), j +(j))
      =+  j=0
      =+  :*  a=(wac 0 hax)
              b=(wac 1 hax)
              c=(wac 2 hax)
              d=(wac 3 hax)
              e=(wac 4 hax)
              f=(wac 5 hax)
              g=(wac 6 hax)
              h=(wac 7 hax)
          ==
      |-  ^-  @
      ?:  =(64 j)
        %=  ^$
          i  +(i)
          hax  %+  rep  5
               :~  (sum a (wac 0 hax))
                   (sum b (wac 1 hax))
                   (sum c (wac 2 hax))
                   (sum d (wac 3 hax))
                   (sum e (wac 4 hax))
                   (sum f (wac 5 hax))
                   (sum g (wac 6 hax))
                   (sum h (wac 7 hax))
               ==
        ==
      =+  l=:(mix (ror 0 2 a) (ror 0 13 a) (ror 0 22 a))    ::  s0
      =+  m=:(mix (dis a b) (dis a c) (dis b c))            ::  maj
      =+  n=(sum l m)                                       ::  t2
      =+  o=:(mix (ror 0 6 e) (ror 0 11 e) (ror 0 25 e))    ::  s1
      =+  p=(mix (dis e f) (dis (inv e) g))                 ::  ch
      =+  q=:(sum h o p (wac j kbx) (wac j wox))            ::  t1
      $(j +(j), a (sum q n), b a, c b, d c, e (sum d q), f e, g f, h g)
<

Examples~
>
    > `@uw`(shay 1 'hello')
    0w2eN.jupNe.OyGTU.-l0Co.SWSGS.fFD9k.HPHg1.-AYmg.CgaCG
<
>
    > `@uw`(shay 2 'hello')
    0wdUu.vKccX.fhjYt.tY2a4.B~sqA.KWNOM.1TnEu.8sQd8.LvyYT
<

Discussion~

Because byte-strings can have leading zeros, but atoms cannot, we use `len` as
a way of saying that the atom `ruz` is shorter than its representative byte-
string.


------------------------------------------------------------------------------
SHAW                                                                  *++shaw*

Hash to nbits

Produces an atom of `len` random bits by hashing `ruz` with the salted SHA-256
hash algorithm, where `sal` is the cryptographic salt.

Accepts~

`sal` is an atom.

`len` is an atom.

`ruz` is an atom.

Produces~

An atom.

Source~
>
    ++  shaw
      |=  [sal=@ len=@ ruz=@]
      (~(raw og (shas sal (mix len ruz))) len)
<

Examples~
>
    > `@ub`(shaw 3 6 98)
    0b11.0111
    
    > `@ub`(shaw 2 6 98)
    0b11
<


------------------------------------------------------------------------------
SHAZ                                                                  *++shaz*

SHA-512

Produces an atom by hashing an atom `ruz` with SHA-512.

Accepts~

`ruz` is an atom.

Produces~

An atom.

Source~
>
    ++  shaz
      |=  ruz=@  ^-  @
      (shal [(met 3 ruz) ruz])
<

Examples~
>
    `@uw`(shaz 'hello')
    0w1.3MdWY.sS~QT.zFsbB.N7oQo.cSImU.56Xcu.DMtMq.mrSsc.z8WsY.pNABZ.Z~ySG.Ecysb.XCP5P.fuHjq.Jimnn.zPoHQ.AQD6r
<


------------------------------------------------------------------------------
SHAL                                                                  *++shal*

SHA-512 with length

Produces an atom by hashing an atom `ruz` with SHA-512. Another atom, `len`,
is the byte-length of the theoretical buffer represented by the atom.

Accepts~

`len` is an atom.

`ruz` is an atom.

Produces~

An atom.

Source~
>
    ++  shal
      ~/  %shal
      |=  [len=@ ruz=@]  ^-  @
      =>  .(ruz (cut 3 [0 len] ruz))
      =+  [few==>(fe .(a 6)) wac=|=([a=@ b=@] (cut 6 [a 1] b))]
      =+  [sum=sum.few ror=ror.few net=net.few inv=inv.few]
      =+  ral=(lsh [0 3] len)
      =+  ^=  ful
          %+  can  0
          :~  [ral ruz]
              [8 128]
              [(mod (sub 1.920 (mod (add 8 ral) 1.024)) 1.024) 0]
              [128 (~(net fe 7) ral)]
          ==
      =+  lex=(met 10 ful)
      =+  ^=  kbx  0x6c44.198c.4a47.5817.5fcb.6fab.3ad6.faec.
                     597f.299c.fc65.7e2a.4cc5.d4be.cb3e.42b6.
                     431d.67c4.9c10.0d4c.3c9e.be0a.15c9.bebc.
                     32ca.ab7b.40c7.2493.28db.77f5.2304.7d84.
                     1b71.0b35.131c.471b.113f.9804.bef9.0dae.
                     0a63.7dc5.a2c8.98a6.06f0.67aa.7217.6fba.
                     f57d.4f7f.ee6e.d178.eada.7dd6.cde0.eb1e.
                     d186.b8c7.21c0.c207.ca27.3ece.ea26.619c.
                     c671.78f2.e372.532b.bef9.a3f7.b2c6.7915.
                     a450.6ceb.de82.bde9.90be.fffa.2363.1e28.
                     8cc7.0208.1a64.39ec.84c8.7814.a1f0.ab72.
                     78a5.636f.4317.2f60.748f.82ee.5def.b2fc.
                     682e.6ff3.d6b2.b8a3.5b9c.ca4f.7763.e373.
                     4ed8.aa4a.e341.8acb.391c.0cb3.c5c9.5a63.
                     34b0.bcb5.e19b.48a8.2748.774c.df8e.eb99.
                     1e37.6c08.5141.ab53.19a4.c116.b8d2.d0c8.
                     106a.a070.32bb.d1b8.f40e.3585.5771.202a.
                     d699.0624.5565.a910.d192.e819.d6ef.5218.
                     c76c.51a3.0654.be30.c24b.8b70.d0f8.9791.
                     a81a.664b.bc42.3001.a2bf.e8a1.4cf1.0364.
                     9272.2c85.1482.353b.81c2.c92e.47ed.aee6.
                     766a.0abb.3c77.b2a8.650a.7354.8baf.63de.
                     5338.0d13.9d95.b3df.4d2c.6dfc.5ac4.2aed.
                     2e1b.2138.5c26.c926.27b7.0a85.46d2.2ffc.
                     1429.2967.0a0e.6e70.06ca.6351.e003.826f.
                     d5a7.9147.930a.a725.c6e0.0bf3.3da8.8fc2.
                     bf59.7fc7.beef.0ee4.b003.27c8.98fb.213f.
                     a831.c66d.2db4.3210.983e.5152.ee66.dfab.
                     76f9.88da.8311.53b5.5cb0.a9dc.bd41.fbd4.
                     4a74.84aa.6ea6.e483.2de9.2c6f.592b.0275.
                     240c.a1cc.77ac.9c65.0fc1.9dc6.8b8c.d5b5.
                     efbe.4786.384f.25e3.e49b.69c1.9ef1.4ad2.
                     c19b.f174.cf69.2694.9bdc.06a7.25c7.1235.
                     80de.b1fe.3b16.96b1.72be.5d74.f27b.896f.
                     550c.7dc3.d5ff.b4e2.2431.85be.4ee4.b28c.
                     1283.5b01.4570.6fbe.d807.aa98.a303.0242.
                     ab1c.5ed5.da6d.8118.923f.82a4.af19.4f9b.
                     59f1.11f1.b605.d019.3956.c25b.f348.b538.
                     e9b5.dba5.8189.dbbc.b5c0.fbcf.ec4d.3b2f.
                     7137.4491.23ef.65cd.428a.2f98.d728.ae22
      =+  ^=  hax  0x5be0.cd19.137e.2179.1f83.d9ab.fb41.bd6b.
                     9b05.688c.2b3e.6c1f.510e.527f.ade6.82d1.
                     a54f.f53a.5f1d.36f1.3c6e.f372.fe94.f82b.
                     bb67.ae85.84ca.a73b.6a09.e667.f3bc.c908
      =+  i=0
      |-  ^-  @
      ?:  =(i lex)
        (run 6 hax net)
      =+  ^=  wox
          =+  dux=(cut 10 [i 1] ful)
          =+  wox=(run 6 dux net)
          =+  j=16
          |-  ^-  @
          ?:  =(80 j)
            wox
          =+  :*  l=(wac (sub j 15) wox)
                  m=(wac (sub j 2) wox)
                  n=(wac (sub j 16) wox)
                  o=(wac (sub j 7) wox)
              ==
          =+  x=:(mix (ror 0 1 l) (ror 0 8 l) (rsh [0 7] l))
          =+  y=:(mix (ror 0 19 m) (ror 0 61 m) (rsh [0 6] m))
          =+  z=:(sum n x o y)
          $(wox (con (lsh [6 j] z) wox), j +(j))
      =+  j=0
      =+  :*  a=(wac 0 hax)
              b=(wac 1 hax)
              c=(wac 2 hax)
              d=(wac 3 hax)
              e=(wac 4 hax)
              f=(wac 5 hax)
              g=(wac 6 hax)
              h=(wac 7 hax)
          ==
      |-  ^-  @
      ?:  =(80 j)
        %=  ^$
          i  +(i)
          hax  %+  rep  6
               :~  (sum a (wac 0 hax))
                   (sum b (wac 1 hax))
                   (sum c (wac 2 hax))
                   (sum d (wac 3 hax))
                   (sum e (wac 4 hax))
                   (sum f (wac 5 hax))
                   (sum g (wac 6 hax))
                   (sum h (wac 7 hax))
               ==
        ==
      =+  l=:(mix (ror 0 28 a) (ror 0 34 a) (ror 0 39 a))   ::  S0
      =+  m=:(mix (dis a b) (dis a c) (dis b c))            ::  maj
      =+  n=(sum l m)                                       ::  t2
      =+  o=:(mix (ror 0 14 e) (ror 0 18 e) (ror 0 41 e))   ::  S1
      =+  p=(mix (dis e f) (dis (inv e) g))                 ::  ch
      =+  q=:(sum h o p (wac j kbx) (wac j wox))            ::  t1
      $(j +(j), a (sum q n), b a, c b, d c, e (sum d q), f e, g f, h g)
<

Examples~
>
    > `@uw`(shal 1 'hello')
    0w2.nWO0R.zMAzH.OSWU1.apOje.19Mta.RE24o.4u~MB.wQuj4.NDdG6.0QZA0.w21Br.yQVhu.pFBII.Cdgvd.WT-bH.g51Yu.fL44y
<
>
    > `@uw`(shal 2 'hello')
    0w1.r3W4g.hae37.8YUFp.ntryr.DsQuY.rPsdm.p3Xjv.rayLz.DslEc.Lxvll.OJUc3.tZeLZ.TjUnu.XMyGr.82qPA.zl1y0.HbSpT
<

Discussion~

Because byte-strings can have leading zeros, but atoms cannot, we use `len` as
a way of saying that the atom `ruz` is shorter than its representative byte-
string.


------------------------------------------------------------------------------
SHAN                                                                  *++shan*

SHA-1

Produces an atom by hashing an atom `ruz` with SHA-1.

Accepts~

`ruz` is an atom.

Produces~

An atom.

Source~
>
    ++  shan
      |=  ruz=@
      =+  [few==>(fe .(a 5)) wac=|=([a=@ b=@] (cut 5 [a 1] b))]
      =+  [sum=sum.few ror=ror.few rol=rol.few net=net.few inv=inv.few]
      =+  ral=(lsh [0 3] (met 3 ruz))
      =+  ^=  ful
          %+  can  0
          :~  [ral ruz]
              [8 128]
              [(mod (sub 960 (mod (add 8 ral) 512)) 512) 0]
              [64 (~(net fe 6) ral)]
          ==
      =+  lex=(met 9 ful)
      =+  kbx=0xca62.c1d6.8f1b.bcdc.6ed9.eba1.5a82.7999
      =+  hax=0xc3d2.e1f0.1032.5476.98ba.dcfe.efcd.ab89.6745.2301
      =+  i=0
      |-
      ?:  =(i lex)
        (rep 5 (flop (rip 5 hax)))
      =+  ^=  wox
          =+  dux=(cut 9 [i 1] ful)
          =+  wox=(rep 5 (turn (rip 5 dux) net))
          =+  j=16
          |-  ^-  @
          ?:  =(80 j)
            wox
          =+  :*  l=(wac (sub j 3) wox)
                  m=(wac (sub j 8) wox)
                  n=(wac (sub j 14) wox)
                  o=(wac (sub j 16) wox)
              ==
          =+  z=(rol 0 1 :(mix l m n o))
          $(wox (con (lsh [5 j] z) wox), j +(j))
      =+  j=0
      =+  :*  a=(wac 0 hax)
              b=(wac 1 hax)
              c=(wac 2 hax)
              d=(wac 3 hax)
              e=(wac 4 hax)
          ==
      |-  ^-  @
      ?:  =(80 j)
        %=  ^$
          i  +(i)
          hax  %+  rep  5
               :~
                   (sum a (wac 0 hax))
                   (sum b (wac 1 hax))
                   (sum c (wac 2 hax))
                   (sum d (wac 3 hax))
                   (sum e (wac 4 hax))
               ==
        ==
      =+  fx=(con (dis b c) (dis (not 5 1 b) d))
      =+  fy=:(mix b c d)
      =+  fz=:(con (dis b c) (dis b d) (dis c d))
      =+  ^=  tem
          ?:  &((gte j 0) (lte j 19))
            :(sum (rol 0 5 a) fx e (wac 0 kbx) (wac j wox))
          ?:  &((gte j 20) (lte j 39))
            :(sum (rol 0 5 a) fy e (wac 1 kbx) (wac j wox))
          ?:  &((gte j 40) (lte j 59))
            :(sum (rol 0 5 a) fz e (wac 2 kbx) (wac j wox))
          :(sum (rol 0 5 a) fy e (wac 3 kbx) (wac j wox))
      $(j +(j), a tem, b a, c (rol 0 30 b), d c, e d)
<

Examples~
>
    > `@uw`(shan 'hello')
    0waH.QNxTs.NuyyS.HXu3P.J8bdC.KGkdd
<

Discussion~

SHA-1 is a deprecated function; it is not considered secure.


------------------------------------------------------------------------------
OG                                                                  *++og*

Container arm for SHA-256-powered random-number generation. Its sample `a` is
an atom that is used as a seed for the hash.

Accepts~

`a` is an atom.

Produces~

A core.

Source~
>
    ++  og
      ~/  %og
      |_  a=@
<

Examples~
>
    > ~(. og 919)
    <4.wmp {a/@ud <54.tyv 119.olq 31.ohr 1.jmk $143>}>
<

Discussion~

Note that the product is deterministic; the seed will produce the same result
every time it is run. Use `eny`, 256 bits of entropy, for a non-deterministic
product.


`++rad:og`~

Random in range

Produces a random number that is within the range of first `b` whole numbers,
starting at `0`.

Accepts~

`b` is an atom.

Produces~

An atom.

Source~
>
    ++  rad
      |=  b=@  ^-  @
      ~_  leaf+"rad-zero"
      ?<  =(0 b)
      =+  c=(raw (met 0 b))
      ?:((lth c b) c $(a +(a)))
<

Examples~
>
    > (~(rad og 5) 11)
    4
    
    > (~(rad og 758.716.593) 11)
    2
    
    > (~(rad og 1) 100.000)
    71.499
    
    > (~(rad og eny) 11)               ::  `eny` acts as a random sample
    7
<


`++rads:og`~

Random continuation

Produces a cell. The head of the cell is a random number that is within the
range of first `b` whole numbers, starting at `0`. The tail is a new core
produced from hashing the parent core with `(rad b)`.

Accepts~

`b` is an atom.

Produces~

A cell.

Source~
>
    ++  rads
      |=  b=@
      =+  r=(rad b)
      [r +>.$(a (shas %og-s (mix a r)))]
<

Examples~
>
    > (~(rads og 4) 10)
    [2 <4.wmp {a/@ <54.tyv 119.olq 31.ohr 1.jmk $143>}>]
    
    > =/  rng  ~(. og 7)
        =^  a  rng  (rads:rng 10)
        =^  b  rng  (rads:rng 10)
        [a b]
    [2 8]
<

Discussion~

Since everything in Hoon is a pure function, we need to use tricks like this
to generate separate random values from the same seed. Notice how we jump from
one `rads` function call to another in the above example.


`++raw:og`~

Random bits

Produces an atom with a bitwidth `b` that is composed of random bits.

Accepts~

`b` is an atom.

Produces~

An atom.

Source~
>
    ++  raw
      ~/  %raw
      |=  b=@  ^-  @
      %+  can
        0
      =+  c=(shas %og-a (mix b a))
      |-  ^-  (list [@ @])
      ?:  =(0 b)
        ~
      =+  d=(shas %og-b (mix b (mix a c)))
      ?:  (lth b 256)
        [[b (end [0 b] d)] ~]
      [[256 d] $(c d, b (sub b 256))]
<

Examples~
>
    > `@ud`(~(raw og 27) 4)
    0b1001
    
    > `@ub`(~(raw og 27) 3)
    0b0
    
    > `@ub`(~(raw og 11) 4)
    0b1111
    
    > `@ub`(~(raw og 11) 3)
    0b100
<


`++raws:og`~

Random bits continuation

Produces a cell. The head of the cell is an atom with a bitwidth `b` that is
composed of random bits. The tail is a new core produced from hashing the
parent core with `(raw b)`.

Source~
>
    ++  raws
      |=  b=@
      =+  r=(raw b)
      [r +>.$(a (shas %og-s (mix a r)))]
<

Examples~
>
    > `[@ub _og]`(~(raws og 7) 4)
    [0b1100 <4.wmp {a/@ <54.tyv 119.olq 31.ohr 1.jmk $143>}>]
    
    > =/  rng  ~(. og 7)
              =^  a  rng  (rads:rng 4)
              =^  b  rng  (rads:rng 4)
              [`@ub`a `@ub`b]
    [0b10 0b1]
<

Discussion~

Since everything in Hoon is a pure function, we need to use tricks like this
to generate separate random values from the same seed. Notice how we jump from
one `raws` function call to another in the above example.



==============================================================================
 3f: Scrambling                                                                         

------------------------------------------------------------------------------
UN                                                                  *++un*

Reversible scrambling

A core that contains arms that perform reversible scrambling operations. Used
in the `@p` phonetic base.

Source~
>
    ++  un
      |%
<


`++wren:un`~

Conceal structure

Scrambles a byte-string `pyn` by adding the current position to each byte,
looking it up in an s-box, and then performing the XOR operation on the
result, pushing it forward. The inverse of `wred`.

Accepts~

`pyn` is an atom.

Produces~

An atom.

Source~
>
    ++  wren
      |=  pyn=@  ^-  @
      =+  len=(met 3 pyn)
      ?:  =(0 len)
        0
      =>  .(len (dec len))
      =+  mig=(zaft (xafo len (cut 3 [len 1] pyn)))
      %+  can  3
      %-  flop  ^-  (list [@ @])
      :-  [1 mig]
      |-  ^-  (list [@ @])
      ?:  =(0 len)
        ~
      =>  .(len (dec len))
      =+  mog=(zyft :(mix mig (end 3 len) (cut 3 [len 1] pyn)))
      [[1 mog] $(mig mog)]
<

Examples~
>
    > `@ux`(wren:un 'testing')
    0x30.bf6a.b9fe.7d8f
    
    > `@ux`'testing'
    0x67.6e69.7473.6574
    
    > `@da`(wred:un (wren:un ~2001.2.5))
    ~2001.2.5
<


`++wred:un`~

Restore structure

Unscrambles a byte-string `cry` by subtracting the current position from each
byte, looking it up in an s-box, and performing the XOR operation on the
result, pushing it forward. The inverse of `wren`.

Accepts~

`cry` is an atom.

Produces~

An atom.

Source~
>
    ++  wred
      |=  cry=@  ^-  @
      =+  len=(met 3 cry)
      ?:  =(0 len)
        0
      =>  .(len (dec len))
      =+  mig=(cut 3 [len 1] cry)
      %+  can  3
      %-  flop  ^-  (list [@ @])
      :-  [1 (xaro len (zart mig))]
      |-  ^-  (list [@ @])
      ?:  =(0 len)
        ~
      =>  .(len (dec len))
      =+  mog=(cut 3 [len 1] cry)
      [[1 :(mix mig (end 3 len) (zyrt mog))] $(mig mog)]
<

Examples~
>
    > (wred:un 0x30.bf6a.b9fe.7d8f)
    29.113.321.805.538.676
    
    > `@t`(wred:un 0x30.bf6a.b9fe.7d8f)
    'testing'
    
    > (wred:un (wren:un 200.038.426))
    200.038.426
<


`++xafo:un`~

Add modulo 255

Produces the sum of two atoms modulo 255, encoded as a nonzero byte. The
inverse of `xaro`.

Accepts~

`a` is an atom.

`b` is an atom.

Produces~

An atom.

Source~
>
    ++  xafo  |=([a=@ b=@] +((mod (add (dec b) a) 255)))
<

Examples~
>
    > (xafo:un 5 6)
    11
    
    > (xafo:un 256 20)
    21
    
    > (xafo:un 256 (xaro:un 256 20))
    20
<


`++xaro:un`~

Subtract modulo 255

Produces the sum of two atoms modulo 255, encoded as a nonzero byte. The
inverse of `xafo`.

Accepts~

`a` is an atom.

`b` is an atom.

Produces~

An atom.

Source~
>
    ++  xaro  |=([a=@ b=@] +((mod (add (dec b) (sub 255 (mod a 255))) 255)))
<

Examples~
>
    > (xaro:un 17 57)
    40
    
    > (xaro:un 265 12)
    2
    
    > (xaro:un 256 (xafo:un 256 20))
    20
<


`++zaft:un`~

Look up in 255 sub box

Looks up a nonzero byte `a` in a substitution box with 255 values, producing a
unique nonzero byte. The inverse of `zart`.

Accepts~

`a` is an atom of one byte in length.

Produces~

An atom.

Source~
>
    ++  zaft
      |=  a=@D
      =+  ^=  b
          0xcc.75bc.86c8.2fb1.9a42.f0b3.79a0.92ca.21f6.1e41.cde5.fcc0.
          7e85.51ae.1005.c72d.1246.07e8.7c64.a914.8d69.d9f4.59c2.8038.
          1f4a.dca2.6fdf.66f9.f561.a12e.5a16.f7b0.a39f.364e.cb70.7318.
          1de1.ad31.63d1.abd4.db68.6a33.134d.a760.edee.5434.493a.e323.
          930d.8f3d.3562.bb81.0b24.43cf.bea5.a6eb.52b4.0229.06b2.6704.
          78c9.45ec.d75e.58af.c577.b7b9.c40e.017d.90c3.87f8.96fa.1153.
          0372.7f30.1c32.ac83.ff17.c6e4.d36d.6b55.e2ce.8c71.8a5b.b6f3.
          9d4b.eab5.8b3c.e7f2.a8fe.9574.5de0.bf20.3f15.9784.9939.5f9c.
          e609.564f.d8a4.b825.9819.94aa.2c08.8e4c.9b22.477a.2840.3ed6.
          3750.6ef1.44dd.89ef.6576.d00a.fbda.9ed2.3b6c.7b0c.bde9.2ade.
          5c88.c182.481a.1b0f.2bfd.d591.2726.57ba
      (cut 3 [(dec a) 1] b)
<

Examples~
>
    > (zaft:un 0x12)
    42
    
    > (zaft:un 0xff)
    204
    > `@ux`(zart:un 204)
    0xff
    
    > (zaft:un 0x0)
    ! decrement-underflow
    ! exit
<


`++zart:un`~

Reverse look up in 255 sub box

Looks up the index of a nonzero byte `a` in the substitution box with 255
values, producing a unique nonzero byte. The inverse of `zaft`.

Accepts~

`a` is an atom of one byte in length.

Produces~

An atom.

Source~
>
    ++  zart
      |=  a=@D
      =+  ^=  b
          0x68.4f07.ea1c.73c9.75c2.efc8.d559.5125.f621.a7a8.8591.5613.
          dd52.40eb.65a2.60b7.4bcb.1123.ceb0.1bd6.3c84.2906.b164.19b3.
          1e95.5fec.ffbc.f187.fbe2.6680.7c77.d30e.e94a.9414.fd9a.017d.
          3a7e.5a55.8ff5.8bf9.c181.e5b6.6ab2.35da.50aa.9293.3bc0.cdc6.
          f3bf.1a58.4130.f844.3846.744e.36a0.f205.789e.32d8.5e54.5c22.
          0f76.fce7.4569.0d99.d26e.e879.dc16.2df4.887f.1ffe.4dba.6f5d.
          bbcc.2663.1762.aed7.af8a.ca20.dbb4.9bc7.a942.834c.105b.c4d4.
          8202.3e61.a671.90e6.273d.bdab.3157.cfa4.0c2e.df86.2496.f7ed.
          2b48.2a9d.5318.a343.d128.be9c.a5ad.6bb5.6dfa.c5e1.3408.128d.
          2c04.0339.97a1.2ff0.49d0.eeb8.6c0a.0b37.b967.c347.d9ac.e072.
          e409.7b9f.1598.1d3f.33de.8ce3.8970.8e7a
      (cut 3 [(dec a) 1] b)
<

Examples~
>
    > `@ux`(zart:un 204)
    0xff
    
    > `@ux`(zart:un 42)
    0x12
    
    > (zaft:un 0x12)
    42
<


`++zyft:un`~

Lookup byte in 256 sub box

Looks up a byte `a` in a substitution box with 256 values, producing a byte.
The inverse of `zyrt`.

Accepts~

`a` is an atom of one byte in length.

Produces~

An atom.

Source~
>
    ++  zyft
      |=  a=@D
      =+  ^=  b
          0xbb49.b71f.b881.b402.17e4.6b86.69b5.1647.115f.dddb.7ca5.
            8371.4bd5.19a9.b092.605d.0d9b.e030.a0cc.78ba.5706.4d2d.
            986a.768c.f8e8.c4c7.2f1c.effe.3cae.01c0.253e.65d3.3872.
            ce0e.7a74.8ac6.daac.7e5c.6479.44ec.4143.3d20.4af0.ee6c.
            c828.deca.0377.249f.ffcd.7b4f.eb7d.66f2.8951.042e.595a.
            8e13.f9c3.a79a.f788.6199.9391.7fab.6200.4ce5.0758.e2f1.
            7594.c945.d218.4248.afa1.e61a.54fb.1482.bea4.96a2.3473.
            63c2.e7cb.155b.120a.4ed7.bfd8.b31b.4008.f329.fca3.5380.
            9556.0cb2.8722.2bea.e96e.3ac5.d1bc.10e3.2c52.a62a.b1d6.
            35aa.d05e.f6a8.0f3b.31ed.559d.09ad.f585.6d21.fd1d.8d67.
            370b.26f4.70c1.b923.4684.6fbd.cf8b.5036.0539.9cdc.d93f.
            9068.1edf.8f33.b632.d427.97fa.9ee1
      (cut 3 [a 1] b)
<

Examples~
>
    > (zyft:un 0x12)
    57
    
    > (zyft:un 0x0)
    225
    
    > (zyft:un 0xff)
    187
    > `@ux`(zyrt:un 187)
    0xff
<


`++zyrt:un`~

Reverse lookup byte in 256 sub box

Looks up a byte `a` in a substitution box with 256 values, producing a byte.
The inverse of `zyft`.

Accepts~

`a` is an atom of one byte in length.

Produces~

An atom.

Source~
>
    ++  zyrt
      |=  a=@D
      =+  ^=  b
          0x9fc8.2753.6e02.8fcf.8b35.2b20.5598.7caa.c9a9.30b0.9b48.
            47ce.6371.80f6.407d.00dd.0aa5.ed10.ecb7.0f5a.5c3a.e605.
            c077.4337.17bd.9eda.62a4.79a7.ccb8.44cd.8e64.1ec4.5b6b.
            1842.ffd8.1dfb.fd07.f2f9.594c.3be3.73c6.2cb6.8438.e434.
            8d3d.ea6a.5268.72db.a001.2e11.de8c.88d3.0369.4f7a.87e2.
            860d.0991.25d0.16b9.978a.4bf4.2a1a.e96c.fa50.85b5.9aeb.
            9dbb.b2d9.a2d1.7bba.66be.e81f.1946.29a8.f5d2.f30c.2499.
            c1b3.6583.89e1.ee36.e0b4.6092.937e.d74e.2f6f.513e.9615.
            9c5d.d581.e7ab.fe74.f01b.78b1.ae75.af57.0ec2.adc7.3245.
            12bf.2314.3967.0806.31dc.cb94.d43f.493c.54a6.0421.c3a1.
            1c4a.28ac.fc0b.26ca.5870.e576.f7f1.616d.905f.ef41.33bc.
            df4d.225e.2d56.7fd6.1395.a3f8.c582
      (cut 3 [a 1] b)
<

Examples~
>
    > `@ux`(zyrt:un 57)
    0x12
    
    > `@ux`(zyrt:un 225)
    0x0
    
    > `@ux`(zyrt:un 187)
    0xff
    > (zyft:un 0xff)
    187
<


------------------------------------------------------------------------------
OB                                                                  *++ob*

Reversible scrambling, v3

A core for performing reversible scrambling operations for the `@p` phonetic
base.

Source~
>
    ++  ob
      ~%  %ob  ..ob
        ==
          %fein  fein
          %fynd  fynd
        ==
      |%
<


`++fein:ob`~

conceal structure, v3

`+fein` conceals planet-sized atoms. The idea is that it should not be trivial
to tell which planet a star has spawned under.

Permutes atom `pyn` which fits into 17 to 32 bits, or if `pyn` fits into 33 to
64 bits, does the same permutation on the low 32 bits only. Otherwise, passes
`pyn` through unchanged.

Accepts~

`pyn` is an atom.

Produces~

An atom.

Source~
>
    ++  fein
      ~/  %fein
      |=  pyn=@  ^-  @
      ?:  &((gte pyn 0x1.0000) (lte pyn 0xffff.ffff))
        (add 0x1.0000 (feis (sub pyn 0x1.0000)))
      ?:  &((gte pyn 0x1.0000.0000) (lte pyn 0xffff.ffff.ffff.ffff))
        =/  lo  (dis pyn 0xffff.ffff)
        =/  hi  (dis pyn 0xffff.ffff.0000.0000)
        %+  con  hi
        $(pyn lo)
      pyn
<

Examples~
>
    > (fein:ob 111.103)
    2.783.373.008
    
    > (fynd:ob 2.783.373.008)
    111.103
<


`++fynd:ob`~

Restore structure, v3

Restores obfuscated values that have been enciphered with +fein.

Permutes atom `cry` that fits into 17 to 32 bits, or permutes the low 32 bits
of `cry` if it fits into 33 to 64 bits. Otherwise, passes the atom through
unchanged. The inverse of the one applied by `+fein`.

Accepts~

`cry` is an atom.

Produces~

An atom.

Source~
>
    ++  fynd
      ~/  %fynd
      |=  cry=@  ^-  @
      ?:  &((gte cry 0x1.0000) (lte cry 0xffff.ffff))
        (add 0x1.0000 (tail (sub cry 0x1.0000)))
      ?:  &((gte cry 0x1.0000.0000) (lte cry 0xffff.ffff.ffff.ffff))
        =/  lo  (dis cry 0xffff.ffff)
        =/  hi  (dis cry 0xffff.ffff.0000.0000)
        %+  con  hi
        $(cry lo)
      cry
<

Examples~
>
    > (fein:ob 111.103)
    2.783.373.008
    
    > (fynd:ob 2.783.373.008)
    111.103
<


`++feis:ob`~

Four-round generalised Feistel cipher over the domain [0, 2^32 - 2^16 - 1]

See: Black & Rogaway (2002), Ciphers for arbitrary finite domains.

Inverse of `+tail`.

Accepts~

`m` is an atom.

Produces~

An atom.

Source~
>
    ++  feis
      |=  m=@
      ^-  @
      (fee 4 0xffff 0x1.0000 (mul 0xffff 0x1.0000) eff m)
<

Examples~
>
    > (feis:ob 11)
    776.343.932
    
    > (tail:ob 776.343.932)
    11
<


`++tail:ob`~

Reverse `+feis`

Applies the reverse of the Feistel cipher applied by `+feis`.

Accepts~

`m` is an atom.

Produces~

An atom.

Source~
>
    ++  tail
      |=  m=@
      ^-  @
      (feen 4 0xffff 0x1.0000 (mul 0xffff 0x1.0000) eff m)
<

Examples~
>
    > (feis:ob 11)
    776.343.932
    
    > (tail:ob 776.343.932)
    11
<


`++fee:ob`~

"Fe" in B&R (2002)

A Feistel cipher given the following parameters:

- `r`: Number of Feistel rounds.
- `a`, `b`: Parameters such that `ab` >= `k`.
- `k`: Value such that the domain of the cipher is [0, k - 1].
- `prf`: A gate denoting a family of pseudorandom functions indexed by its first
argument and taking its second argument as input.
- `m`: An input value in the domain [0, k - 1].


Accepts~

`r`, `a`, `b`, `k` are an atoms.

`prft` is a gate: `$-([j=@ r=@] @)`.

`m` is an atom.

Produces~

An atom.

Source~
>
    ++  fee
      |=  [r=@ a=@ b=@ k=@ prf=$-([j=@ r=@] @) m=@]
      ^-  @
      =/  c  (fe r a b prf m)
      ?:  (lth c k)
        c
      (fe r a b prf c)
<


`++feen:ob`~

Reverse `+fee`

"Fe^-1" in B&R (2002). Reverses a Feistel cipher constructed with parameters
as described in `+fee`.

Accepts~

`r`, `a`, `b`, and `k` are atoms.

`prf` is a gate: `$-([j=@ r=@] @)`.

`m` is an atom.

Produces~

An atom.

Source~
>
    ++  feen
      |=  [r=@ a=@ b=@ k=@ prf=$-([j=@ r=@] @) m=@]
      ^-  @
      =/  c  (fen r a b prf m)
      ?:  (lth c k)
        c
      (fen r a b prf c)
<


`+fe:ob`~

An internal function to `+fee`.

Note that this implementation differs slightly from the reference paper to
support some legacy behaviour.

Accepts~

`r`, `a`, and `b` are atoms.

`prf` is a gate: `$-([j=@ r=@] @)`.

`m` is an atom.

Produces~

An atom.

Source~
>
    ++  fe
      |=  [r=@ a=@ b=@ prf=$-([j=@ r=@] @) m=@]
      =/  j  1
      =/  ell  (mod m a)
      =/  arr  (div m a)
      |-  ^-  @
      ::
      ?:  (gth j r)
        ?.  =((mod r 2) 0)
          (add (mul arr a) ell)
        ::
        :: Note that +fe differs from B&R (2002)'s "fe" below, as a previous
        :: implementation of this cipher contained a bug such that certain inputs
        :: could encipher to the same output.
        ::
        :: To correct these problem cases while also preserving the cipher's
        :: legacy behaviour on most inputs, we check for a problem case (which
        :: occurs when 'arr' is equal to 'a') and, if detected, use an alternate
        :: permutation instead.
        ::
        ?:  =(arr a)
          (add (mul arr a) ell)
        (add (mul ell a) arr)
      ::
      =/  f  (prf (sub j 1) arr)
      ::
      =/  tmp
        ?.  =((mod j 2) 0)
          (mod (add f ell) a)
        (mod (add f ell) b)
      ::
      $(j +(j), ell arr, arr tmp)
<


`++fen:ob`~

Reverse `+fe`

This is an internal function to `+feen`

Note that this implementation differs slightly from the reference paper to
support some legacy behaviour.

Accepts~

`r`, `a` and `b` are atoms.

`prf` is a gate: `$-([j=@ r=@] @)`.

`m` is an atom.

Produces~

An atom.

Source~
>
    ++  fen
      |=  [r=@ a=@ b=@ prf=$-([j=@ r=@] @) m=@]
      =/  j  r
      ::
      =/  ahh
        ?.  =((mod r 2) 0)
          (div m a)
        (mod m a)
      ::
      =/  ale
        ?.  =((mod r 2) 0)
          (mod m a)
        (div m a)
      ::
      :: Similar to the comment in +fe, +fen differs from B&R (2002)'s "fe^-1"
      :: here in order to preserve the legacy cipher's behaviour on most inputs.
      ::
      :: Here problem cases can be identified by 'ahh' equating with 'a'; we
      :: correct those cases by swapping the values of 'ahh' and 'ale'.
      ::
      =/  ell
        ?:  =(ale a)
          ahh
        ale
      ::
      =/  arr
        ?:  =(ale a)
          ale
        ahh
      ::
      |-  ^-  @
      ?:  (lth j 1)
        (add (mul arr a) ell)
      =/  f  (prf (sub j 1) ell)
      ::
      ::  Note that there is a slight deviation here to avoid dealing with
      ::  negative values.  We add 'a' or 'b' to arr as appropriate and reduce
      ::  'f' modulo the same number before performing subtraction.
      ::
      =/  tmp
        ?.  =((mod j 2) 0)
          (mod (sub (add arr a) (mod f a)) a)
        (mod (sub (add arr b) (mod f b)) b)
      ::
      $(j (sub j 1), ell tmp, arr ell)
<


`++eff:ob`~

murmur3-based pseudorandom function.

'F' in B&R (2002).

- `j` is a number between 0 and 3, selecting the seed with that index in +raku.
- `r` is an atom with a maximum length of two bytes. This is an internal
function of `+feis` and `+tail`.


Accepts~

`j` is an atom.

`r` is an atom.

Produces~

An atom.

Source~
>
    ++  eff
      |=  [j=@ r=@]
      ^-  @
      (muk (snag j raku) 2 r)
<

Example~
>
    > (eff:ob 0 'ab')
    1.178.819.349
<


`++raku:ob`~

Key list

Produces a list of arbitrary hexademical keys for use with `+eff`.

Produces~

A list of atoms of aura `@ux` (hexadecimal).

Source~
>
    ++  raku
      ^-  (list @ux)
      :~  0xb76d.5eed
          0xee28.1300
          0x85bc.ae01
          0x4b38.7af7
      ==
<

Examples~
>
    > raku:ob
    ~[0xb76d.5eed 0xee28.1300 0x85bc.ae01 0x4b38.7af7]
<



==============================================================================
 3g: Molds and Mold-Builders                                                                         

------------------------------------------------------------------------------
+$COIN                                                                  *+$coin*

Noun-literal syntax cases

Syntax cases for nouns-literal: atoms, jammed nouns, and nestable tuples.
Parsed and printed using `++so` and `++co` cores.

Source~
>
    +$  coin  $~  [%$ %ud 0]
              $%  [%$ p=dime]
                  [%blob p=*]
                  [%many p=(list coin)]
<

Examples~
>
    > `coin`(need (slay '~s1'))
    [%$ p=[p=~.dr q=18.446.744.073.709.551.616]]
    
    > `coin`(need (slay '0x2b59'))
    [%$ p=[p=~.ux q=11.097]]
    
    > ~(rend co [%many ~[[%$ %ud 1] [%$ %tas 'a'] [%$ %s -2]]])
    "._1_a_-2__"
    > ._1_a_-2__
    [1 %a -2]
    
    > `@uv`(jam [3 4])
    0v2cd1
    
    > (slay '~02cd1')
    [~ u=[%blob p=[3 4]]]
    
    > ~02cd1
    [3 4]
<


------------------------------------------------------------------------------
+$DIME                                                                  *+$dime*

Aura-atom pair

Used in `++coin`. Convenience methods `++scot` and `++scow` print dimes as
`++cord` and `++tape`, respectively. `++slat`, `++slav`, and `++slaw` are used
to parse atoms of specific auras.

Source~
>
    +$  dime  [p=@ta q=@]
<

Examples~
>
    > +>:(slay '0x123')
    p=[p=~.ux q=291]
<


------------------------------------------------------------------------------
+$EDGE                                                                  *+$edge*

Parsing location metadata. Parsing location input `p` and optional result
`p.q` and parsing continuation `q.q`.

Source~
>
    +$  edge  [p=hair q=(unit [p=* q=nail])]
<

Examples~
>
    > *edge
    [p=[p=0 q=0] q=~]
    
    > (tall:vast [1 1] "a b")
    [p=[p=1 q=3] q=[~ u=[p=[%wing p=~[%a]] q=[p=[p=1 q=2] q=" b"]]]]
<

Discussion~

See also: $rule.


------------------------------------------------------------------------------
+$HAIR                                                                  *+$hair*

Parsing line and column

A pair of two `@ud` used in parsing indicating line and column number.

Source~
>
    +$  hair  [p=@ud q=@ud]
<

Examples~
>
    > *hair
    [p=0 q=0]
    
    > `hair`[1 1]                                               :: parsing starts at [1 1] as a convention.
    [p=1 q=1]
    
    > ((plus ace) [1 1] "   --")
    [p=[p=1 q=4] q=[~ u=[p=[~~. "  "] q=[p=[p=1 q=4] q="--"]]]]
    
    > `hair`p:((plus ace) [1 1] "   --")
    [p=1 q=4]
<


------------------------------------------------------------------------------
LIKE                                                                  *++like*

Generic edge

Generates an `$edge` with a parsed result set to a specific type.

Source~
>
    ++  like  |*  a=$-(* *)
              |:  b=`*`[(hair) ~]
              :-  p=(hair -.b)
              ^=  q
              ?@  +.b  ~
              :-  ~
              u=[p=(a +>-.b) q=[p=(hair -.b) q=(tape +.b)]]
<

Examples~
>
    > *(like char)
    [p=[p=0 q=0] q=~]
    
    > (ace [1 1] " a")
    [p=[p=1 q=2] q=[~ u=[p=' ' q=[p=[p=1 q=2] q="a"]]]]
    
    > `(like char)`(ace [1 1] " a")
    [p=[p=1 q=2] q=[~ [p=~~. q=[p=[p=1 q=2] q="a"]]]]
    
    > `(like ,@)`(ace [1 1] " a")
    [p=[p=1 q=2] q=[~ u=[p=32 q=[p=[p=1 q=2] q="a"]]]]
<


------------------------------------------------------------------------------
+$NAIL                                                                  *+$nail*

Location, remainder of parsed text

Indicates parsing position `p`, and remaining text to be parsed `q`.

Source~
>
    +$  nail  [p=hair q=tape]
<

Examples~
>
    > +<:;~(plug cab cab)
    c=[p=[p=0 q=0] q=""]
<


------------------------------------------------------------------------------
+$PINT                                                                  *+$pint*

Parsing range

A `$pint` is a pair of `$hair`, indicating from `p` to `q`. Mostly used for
stack traces.

Source~
>
    +$  pint  [p=[p=@ q=@] q=[p=@ q=@]]
<

Examples~
>
    > !:(!!)                                                    :: !! always produces a crash
    /~zod/base/~2014.9.20..01.22.04..52e3/:<[1 4].[1 6]>
    
    > `pint`[[1 4] [1 6]]
    [p=[p=1 q=4] q=[p=1 q=6]]
<


------------------------------------------------------------------------------
+$RULE                                                                  *+$rule*

Parsing rule

An empty parsing rule, but used to check that parsing rules match this with
`_`.

Source~
>
    +$  rule  _|:($:nail $:edge)
<

Examples~
>
    > ([|=(a=nail [p.a ~ u=['a' a]])]:|6 [1 1] "hi")
    [[p=1 q=1] ~ u=['a' p=[p=1 q=1] q="hi"]]
<


------------------------------------------------------------------------------
+$SPOT                                                                  *+$spot*

Stack trace line

The stack trace that is printed after crashing.

Source~
>
        ++  spot  [p=path q=pint]
<

Examples~
>
    > !:  !!                                                    :: !! always produces a crash
    /~zod/base/~2018.8.8..21.42.40..7852:<[1 5].[1 7]>
    ! exit
<


------------------------------------------------------------------------------
+$TONE                                                                  *+$tone*

Nock result, error report

Produces either success (`%0`), a block with list of requests blocked on
(`%1`), or failure with an error report (`%2`).

Source~
>
    +$  tone  $%  [%0 product=*]
                  [%1 block=*]
                  [%2 trace=(list [@ta *])]
              ==
<

Examples~
>
    > (mink [[20 21] 0 3] $~)
    [%0 product=21]
<
>
    > (mink [[1 2] !=(!:(+(.)))] ,~)
    [%2 trace=~[[~.spot [[1.685.027.454 1.702.060.386 20.241.306.789.072.368.304.935.424.358.627.395.315.601.229.215.400.789.787.861.332.606 0] [1 20] 1 24]]]]
<


------------------------------------------------------------------------------
+$TOON                                                                  *+$toon*

Nock result, stack trace

Produces either success (`%0`), a block with list of requests blocked on
(`%1`), or failure with a stack trace (`%2`).

Source~
>
    +$  toon  $%  [%0 p=*]              ::  success
                  [%1 p=*]              ::  block
                  [%2 p=(list tank)]    ::  stack trace
              ==                        ::
<

Examples~
>
    > (mock [[20 21] 0 3] $~)
    [%0 p=21]
<
>
    > (mock [[1 2] !=(!:(+(.)))] ,~)
    [ %2
        p
      ~[
        [ %rose
          p=[p=":" q="" r=""]
          q=[i=[%rose p=[p="/" q="/" r=""] q=[i=[%leaf p="~zod"] t=[i=[%leaf p="base"] t=[i=[%leaf p="~2021.10.16..10.03.16..59ee"] t=~]]]] t=[i=[%leaf p="<[1 20].[1 24]>"] t=~]]
        ]
      ]
    ]
<


------------------------------------------------------------------------------
WONK                                                                  *++wonk*

Product from edge

Pull result out of a `$edge`, or crash if there's no result.

Source~
>
    ++  wonk  =+  veq=$:edge
              |@  ++  $  ?~(q.veq !! p.u.q.veq)
              --
<

Examples~
>
    > (wide:vast [1 1] "(add 2 2)")
    [p=[p=1 q=10] q=[~ [p=[%cncl p=[%wing p=~[%add]] q=~[[%sand p=%ud q=2] [%sand p=%ud q=2]]] q=[p=[p=1 q=10] q=""]]]]
<
>
    > (wonk (wide:vast [1 1] "(add 2 2)"))
    [%cncl p=[%wing p=~[%add]] q=~[[%sand p=%ud q=2] [%sand p=%ud q=2]]]
<

Discussion~

See also: `$edge`



==============================================================================
 4a: Exotic Bases                                                                         

------------------------------------------------------------------------------
PO                                                                  *++po*

Phonetic base

Container core for providing phonetic syllables and name generators for the
Urbit naming system. The two faces, `sis` and `dex`, are available to the
contained arms.

Source~
>
    ~/  %po
    =+  :-  ^=  sis                                       ::  prefix syllables
        'dozmarbinwansamlitsighidfidlissogdirwacsabwissib\
        /rigsoldopmodfoglidhopdardorlorhodfolrintogsilmir\
        /holpaslacrovlivdalsatlibtabhanticpidtorbolfosdot\
        /losdilforpilramtirwintadbicdifrocwidbisdasmidlop\
        /rilnardapmolsanlocnovsitnidtipsicropwitnatpanmin\
        /ritpodmottamtolsavposnapnopsomfinfonbanmorworsip\
        /ronnorbotwicsocwatdolmagpicdavbidbaltimtasmallig\
        /sivtagpadsaldivdactansidfabtarmonranniswolmispal\
        /lasdismaprabtobrollatlonnodnavfignomnibpagsopral\
        /bilhaddocridmocpacravripfaltodtiltinhapmicfanpat\
        /taclabmogsimsonpinlomrictapfirhasbosbatpochactid\
        /havsaplindibhosdabbitbarracparloddosbortochilmac\
        /tomdigfilfasmithobharmighinradmashalraglagfadtop\
        /mophabnilnosmilfopfamdatnoldinhatnacrisfotribhoc\
        /nimlarfitwalrapsarnalmoslandondanladdovrivbacpol\
        /laptalpitnambonrostonfodponsovnocsorlavmatmipfip'
        ^=  dex                                           ::  suffix syllables
        'zodnecbudwessevpersutletfulpensytdurwepserwylsun\
        /rypsyxdyrnuphebpeglupdepdysputlughecryttyvsydnex\
        /lunmeplutseppesdelsulpedtemledtulmetwenbynhexfeb\
        /pyldulhetmevruttylwydtepbesdexsefwycburderneppur\
        /rysrebdennutsubpetrulsynregtydsupsemwynrecmegnet\
        /secmulnymtevwebsummutnyxrextebfushepbenmuswyxsym\
        /selrucdecwexsyrwetdylmynmesdetbetbeltuxtugmyrpel\
        /syptermebsetdutdegtexsurfeltudnuxruxrenwytnubmed\
        /lytdusnebrumtynseglyxpunresredfunrevrefmectedrus\
        /bexlebduxrynnumpyxrygryxfeptyrtustyclegnemfermer\
        /tenlusnussyltecmexpubrymtucfyllepdebbermughuttun\
        /bylsudpemdevlurdefbusbeprunmelpexdytbyttyplevmyl\
        /wedducfurfexnulluclennerlexrupnedlecrydlydfenwel\
        /nydhusrelrudneshesfetdesretdunlernyrsebhulryllud\
        /remlysfynwerrycsugnysnyllyndyndemluxfedsedbecmun\
        /lyrtesmudnytbyrsenwegfyrmurtelreptegpecnelnevfes'
    |%
<


`++ind:po`~

Parse suffix

Produces the byte of the right-hand syllable `a`.

Accepts~

`a` is a `@tas`.

Produces~

A `(unit @)`.

Source~
>
    ++  ind  ~/  %ind
             |=  a=@tas
             =+  b=0
             |-  ^-  (unit @)
             ?:(=(256 b) ~ ?:(=(a (tod b)) [~ b] $(b +(b))))
<

Examples~
>
    > (ind:po %zod)
    [~ 0]
<
>
    > (ind:po %foo)
    ~
<
>
    > (ind:po %wet)
    [~ 101]
<


`++ins:po`~

Parse prefix

Produces the byte of the left-hand phonetic syllable `a`.

Accepts~

`a` is a `@tas`.

Produces~

A `(unit @)`.

Source~
>
    ++  ins  ~/  %ins
             |=  a=@tas
             =+  b=0
             |-  ^-  (unit @)
             ?:(=(256 b) ~ ?:(=(a (tos b)) [~ b] $(b +(b))))
<

Examples~
>
    > (ins:po %doz)
    [~ 0]
<
>
    > (ins:po %foo)
    ~
<
>
    > (ins:po %pit)
    [~ 242]
<


`++tod:po`~

Fetch suffix

Produces the phonetic suffix syllable from index `a` within `dex` as an atom.

Accepts~

`a` is an atom

Produces~

An atom.

Source~
>
    ++  tod  ~/  %tod
             |=(a=@ ?>((lth a 256) (cut 3 [(mul 3 a) 3] dex)))
<

Examples~
>
    > `@t`(tod:po 0)
    'zod'
<
>
    > `@t`(tod:po 100)
    'syr'
<
>
    > `@t`(tod:po 255)
    'fes'
<
>
    > `@t`(tod:po 256)
    dojo: hoon expression failed
<


`++tos:po`~

Fetch prefix

Produces the phonetic prefix syllable from index `a` within `sis` as an atom.

Accepts~

`a` is an atom.

Produces~

An atom.

Source~
>
    ++  tos  ~/  %tos
             |=(a=@ ?>((lth a 256) (cut 3 [(mul 3 a) 3] sis)))
<

Examples~
>
    > `@t`(tos:po 0)
    'doz'
<
>
    > `@t`(tos:po 100)
    'soc'
<
>
    > `@t`(tos:po 255)
    'fip'
<
>
    > `@t`(tos:po 256)
    dojo: hoon expression failed
<


------------------------------------------------------------------------------
FA                                                                  *++fa*

base58check

Container core for base58check (e.g. bitcoin address) functions.

Source~
>
    ++  fa
      =+  key='123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
      =/  yek=@ux  ~+
          =-  yek:(roll (rip 3 key) -)
          =+  [a=*char b=*@ yek=`@ux`(fil 3 256 0xff)]
          |.
          [+(b) (mix yek (lsh [3 `@u`a] (~(inv fe 3) b)))]
      |%
<


`++cha:fa`~

Decode base58check character

Check whether character `a` is valid in base58check encoding, producing a
`unit` of its decoded value if it's valid, and a null `unit` if it's not.

Accepts~

`a` is a `char`.

Produces~

A `(unit @uF)`.

Source~
>
    ++  cha  |=(a=char `(unit @uF)`=+(b=(cut 3 [`@`a 1] yek) ?:(=(b 0xff) ~ `b)))
<

Examples~
>
    > (cha:fa 'Z')
    [~ 32]
<
>
    > (cha:fa 'n')
    [~ 45]
<
>
    > (cha:fa 'l')
    ~
<


`++tok:fa`~

Compute base58check checksum

Compute the base58check checksum of `a`.

Accepts~

`a` is a `@ux`.

Produces~

A `@ux`.

Source~
>
    ++  tok
      |=  a=@ux  ^-  @ux
      =+  b=(pad a)
      =-  (~(net fe 5) (end [3 4] (shay 32 -)))
      (shay (add b (met 3 a)) (lsh [3 b] (swp 3 a)))
<

Examples~
>
    > (tok:fa 0xdead.beef)
    0x938b.8b0c
<


`++pad:fa`~

base58check padding bytes

Compute the number of bytes of 0s needed to pad `a` to 21 bytes, if it's less
than 21 bytes.

Accepts~

`a` is a `@` - a value without its base58check checksum.

Produces~

A `@`.

Source~
>
    ++  pad  |=(a=@ =+(b=(met 3 a) ?:((gte b 21) 0 (sub 21 b))))
<

Examples~
>
    > (pad:fa 0xdead.beef)
    17
<


`++enc:fa`~

encode base58check

Compute and append checksum to `a`.

Accepts~

`a` is a `@ux`.

Produces~

A `@ux`.

Source~
>
    ++  enc  |=(a=@ux `@ux`(mix (lsh [3 4] a) (tok a)))
<

Example~
>
    > (enc:fa 0xdead.beef)
    0xdead.beef.938b.8b0c
<


`++den:fa`~

decode base58check

Check checksum of `a`, return a `unit` of `a` sans the checksum if successful,
or a null `unit` otherwise.

Accepts~

`a` is a `@ux`

Produces~

A `(unit @ux)`.

Source~
>
    ++  den
      |=  a=@ux  ^-  (unit @ux)
      =+  b=(rsh [3 4] a)
      ?.  =((tok b) (end [3 4] a))
        ~
      `b
<

Examples~
>
    > (den:fa 0xdead.beef.938b.8b0c)
    [~ 0xdead.beef]
<
>
    > (den:fa 0xdead.beef.1111.1111)
    ~
<



==============================================================================
 4b: Text Processing                                                                         

------------------------------------------------------------------------------
AT                                                                  *++at*

Basic printing

Container core for basic atom printing functions.

Note that these are largely deprecated, using outdated syntax, character
mappings and encodings, and should generally not be used.

Accepts~

`a` is a `@`.

Source~
>
    ++  at
      |_  a=@
<


`++r:at`~

Print term, number or hex

If `a` is composed of the letters `a` through `z` and `-`, print as `@tas`
syntax. If `a` is an atom of two bytes or less, print as an integer with
comma-separated thousands. Otherwise, print `a` as `@ux` syntax.

Accepts~

`a` is a `@`, and is the sample of `++at`.

Produces~

A `tape`.

Source~
>
    ++  r
      ?:  ?&  (gte (met 3 a) 2)
              |-
              ?:  =(0 a)
                &
              =+  vis=(end 3 a)
              ?&  ?|(=('-' vis) ?&((gte vis 'a') (lte vis 'z')))
                  $(a (rsh 3 a))
              ==
          ==
        rtam
      ?:  (lte (met 3 a) 2)
        rud
      rux
<

Examples~
>
    > ~(r at 'foo-bar')
    "%foo-bar"
<
>
    > ~(r at 0xbeef)
    "48,879"
<
>
    > ~(r at 0xdead.beef)
    "0xdead-beef"
<


`++rf:at`~

Print loobean

If `a` is a loobean, print as `|`/`&`, otherwise crash.

Accepts~

`a` is a `@`, and is the sample of `++at`.

Produces~

A `tape`.

Source~
>
    ++  rf    `tape`[?-(a %& '&', %| '|', * !!) ~]
<

Examples~
>
    > ~(rf at %.y)
    "&"
<
>
    > ~(rf at %.n)
    "|"
<
>
    > ~(rf at 'foo')
    dojo: hoon expression failed
<


`++rn:at`~

Print null

If `a` is null, print `~`, otherwise crash.

Accepts~

`a` is a `@`, and is the sample of `++at`.

Produces~

A `tape`.

Source~
>
    ++  rn    `tape`[?>(=(0 a) '~') ~]
<

Examples~
>
    > ~(rn at ~)
    "~"
<
>
    > ~(rn at 'foo')
    dojo: hoon expression failed
<

`++rt:at`~

Print cord, including escape characters

Print `a` with `cord` syntax, including escape characters.

Accepts~

`a` is a `@`, and the sample of `++at`.

Produces~

A `tape`.

Source~
>
    ++  rt    `tape`['\'' (weld (mesc (trip a)) `tape`['\'' ~])]
<

Examples~
>
    > ~(rt at 'foo')
    "'foo'"
<
>
    > ~(rt at 'fo\\o')
    "'fo\\\\o'"
<
>
    > ~(rt at 'fo\'o')
    "'fo\\0x27/o'"
<


`++rta:at`~

Same as `++rt:at`

Source~
>
    ++  rta   rt
<


`++rtam:at`~

Print cord with `@tas` syntax

Treat `a` as `cord`, print it with `%` prefix.

Accepts~

`a` is a `@`, and is the sample of `++at`.

Produces~

A `tape`.

Source~
>
    ++  rtam  `tape`['%' (trip a)]
<

Examples~
>
    > ~(rtam at 'foo')
    "%foo"
<
>
    > ~(rtam at '12')
    "%12"
<
>
    > ~(rtam at '!!!')
    "%!!!"
<


`++rub:at`~

Print binary

Print `a` as `@ub` syntax, except with `-` separators rather than `.`
separators.

Accepts~

`a` is a `@`, and is the sample of `++at`.

Produces~

A `tape`.

Source~
>
    ++  rub   `tape`['0' 'b' (rum 2 ~ |=(b=@ (add '0' b)))]
<

Examples~
>
    > ~(rub at 0xbeef)
    "0b1011-1110-1110-1111"
<


`++rud:at`~

Print atom as integer

Print atom `a` as an integer, with commas separating thousands.

Accepts~

`a` is a `@`.

Produces~

A `tape`.

Source~
>
    ++  rud   (rum 10 ~ |=(b=@ (add '0' b)))
<

Examples~
>
    > ~(rud at 0xbeef)
    "48,879"
<


`++rum:at`~

Print base-n

Print `a` as base `b` with suffix `c` and using gate `d` to convert blocks to
characters. Each set of four characters will be separated by `-`, except for
base 10 which will be printed with commas separating thousands.

Accepts~

- `a` is a `@`, and is the sample of `++at`
- `b` is a `@`, denoting the the base.
- `c` is a `tape`, and will be appended to the end of the result.
- `d` is a `gate` that takes `@` and produces `@`.


Produces~

A `tape`.

Source~
>
    ++  rum
      |=  [b=@ c=tape d=$-(@ @)]
      ^-  tape
      ?:  =(0 a)
        [(d 0) c]
      =+  e=0
      |-  ^-  tape
      ?:  =(0 a)
        c
      =+  f=&(!=(0 e) =(0 (mod e ?:(=(10 b) 3 4))))
      %=  $
        a  (div a b)
        c  [(d (mod a b)) ?:(f [?:(=(10 b) ',' '-') c] c)]
        e  +(e)
      ==
<

Examples~
>
    > (~(rum at 0xdead.beef) 10 ~ |=(b=@ (add '0' b)))
    "3,735,928,559"
<
>
    > (~(rum at 0xdead.beef) 10 " m/s" |=(b=@ (add '0' b)))
    "3,735,928,559 m/s"
<
>
    > (~(rum at 0xdead.beef) 2 ~ |=(b=@ (add '0' b)))
    "1101-1110-1010-1101-1011-1110-1110-1111"
<


`++rup:at`~

Print `@p` (outdated)

Print `a` as an `@p`, but with outdated syntax and number<->syllable mapping.
This function almost certainly should not be used.

Accepts~

`a` is a `@`.

Produces~

A `tape`.

Source~
>
    ++  rup
      =+  b=(met 3 a)
      ^-  tape
      :-  '-'
      |-  ^-  tape
      ?:  (gth (met 5 a) 1)
        %+  weld
          $(a (rsh 5 a), b (sub b 4))
        `tape`['-' '-' $(a (end 5 a), b 4)]
      ?:  =(0 b)
        ['~' ~]
      ?:  (lte b 1)
        (trip (tos:po a))
      |-  ^-  tape
      ?:  =(2 b)
        =+  c=(rsh 3 a)
        =+  d=(end 3 a)
        (weld (trip (tod:po c)) (trip (tos:po (mix c d))))
      =+  c=(rsh [3 2] a)
      =+  d=(end [3 2] a)
      (weld ^$(a c, b (met 3 c)) `tape`['-' $(a (mix c d), b 2)])
<

Examples~
>
    > ~(rup at 0xdead.beef)
    "-rylsal-sellac"
<
>
    > ~(rup at ~sampel-palnet)
    "-sellod-lebdiv"
<
>
    > ~(rup at ~zod)
    "-~"
<


`++ruv:at`~

Print base-64

Print `a` as outdated base-64 syntax, with `0v` rather than `0w` prefix,
different character mappings and separators.

Accepts~

`a` is a `@`, and is the sample of `++at`.

Produces~

A `tape`.

Source~
>
    ++  ruv
      ^-  tape
      :+  '0'
        'v'
      %^    rum
          64
        ~
      |=  b=@
      ?:  =(63 b)
        '+'
      ?:  =(62 b)
        '-'
      ?:((lth b 26) (add 65 b) ?:((lth b 52) (add 71 b) (sub b 4)))
<

Examples~
>
    > ~(ruv at 0xdead.beef)
    "0vDe-rb7v"
<

Note this is how it should be rendered:
>
    > `@uw`0xdead.beef
    0w3.uHrXL
<


`++rux:at`~

Print hexadecimal

Print `a` as `@ux` except with `-` separators rather than `.`s.

Accepts~

`a` is a `@`, and is the sample of `++at`.

Produces~

A `tape`.

Source~
>
    ++  rux  `tape`['0' 'x' (rum 16 ~ |=(b=@ (add b ?:((lth b 10) 48 87))))]
<

Examples~
>
    > ~(rux at 0xdead.beef)
    "0xdead-beef"
<


------------------------------------------------------------------------------
CASS                                                                  *++cass*

To lowercase

Turn all occurences of uppercase letters in any `tape` into lowercase letters.
Returns a `tape`.

Accepts~

`vib` is a `tape`.

Produces~

A `tape`.

Source~
>
    ++  cass
      |=  vib=tape
      ^-  tape
      (turn vib |=(a=@ ?.(&((gte a 'A') (lte a 'Z')) a (add 32 a))))
<

Examples~
>
    > (cass "JOHN DOE")
    "john doe"
    
    > (cass "abc ABC 123 !@#")
    "abc abc 123 !@#"
    
    > (cass "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsQqRrVvWwXxYyZz")
    "aabbccddeeffgghhiijjkkllmmnnooppqqrrssqqrrvvwwxxyyzz"
<


------------------------------------------------------------------------------
CRIP                                                                  *++crip*

Tape to cord

Produce a `cord` from a `tape`.

Accepts~

`a` is a `tape`.

Produces~

A `cord`.

Source~
>
    ++  crip  |=(a=tape `@t`(rap 3 a))
<

Examples~
>
    > (crip "john doe")
    'john doe'
    
    > (crip "abc 123 !@#")
    'abc 123 !@#'
    
    > `@ud`(crip "abc")
    6.513.249
<


------------------------------------------------------------------------------
CUSS                                                                  *++cuss*

To uppercase

Turn all occurences of lowercase letters in any `tape` into uppercase letters.
Returns a `tape`.

Accepts~

`vib` is a `tape`.

Produces~

A `tape`.

Source~
>
    ++  cuss
      |=  vib=tape
      ^-  tape
      (turn vib |=(a=@ ?.(&((gte a 'a') (lte a 'z')) a (sub a 32))))
<

Examples~
>
    > (cuss "john doe")
    "JOHN DOE"
    
    > (cuss "abc ABC 123 !@#")
    "ABC ABC 123 !@#"
    
    > (cuss "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsQqRrVvWwXxYyZz")
    "AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSQQRRVVWWXXYYZZ"
<


------------------------------------------------------------------------------
MESC                                                                  *++mesc*

Escape special chars

Escape special characters.

Accepts~

`vib` is a `tape`.

Produces~

A `tape`.

Source~
>
    ++  mesc
      |=  vib=tape
      ^-  tape
      ?~  vib
        ~
      ?:  =('\\' i.vib)
        ['\\' '\\' $(vib t.vib)]
      ?:  ?|((gth i.vib 126) (lth i.vib 32) =(`@`39 i.vib))
        ['\\' (welp ~(rux at i.vib) '/' $(vib t.vib))]
      [i.vib $(vib t.vib)]
<

Examples~
>
    > (mesc "ham lus")
    "ham lus"
    > (mesc "bas\\hur")
    "bas\\\\hur"
    > (mesc "as'sa")
    "as\0x27/sa\0xc3/\0x9f/"
<


------------------------------------------------------------------------------
RUNT                                                                  *++runt*

Prepend `n` times

Add `a` repetitions of character `b` to the head of `tape` `c`.

Accepts~

`[a b]` are atoms.

`c` is a `tape`.

Produces~

A `tape`.

Source~
>
    ++  runt
      |=  [[a=@ b=@] c=tape]
      ^-  tape
      ?:  =(0 a)
        c
      [b $(a (dec a))]
<

Examples~
>
    > (runt [2 '/'] "ham")
    "//ham"
    
    > (runt [10 'a'] "")
    "aaaaaaaaaa"
<


------------------------------------------------------------------------------
SAND                                                                  *++sand*

Soft-cast by aura

Check characters in `b` are valid for aura `a`. Produce a `unit` of `a` if
valid and a null `unit` if not. Takes `a` and produces a gate that takes `b`.

Accepts~

`a` is a `@ta`, and specifies the aura like `%tas` or `%ta`.

`b` is an atom.

Produces~

A `(unit @)`.

Source~
>
    ++  sand
      |=  a=@ta
      (flit (sane a))
<

Examples~
>
    > `(unit @ta)`((sand %ta) 'sym-som')
    [~ ~.sym-som]
<
>
    > `(unit @ta)`((sand %ta) 'err!')
    ~
<


------------------------------------------------------------------------------
SANE                                                                  *++sane*

Check aura validity

Check validity of `a` by aura `b`. Takes `b` and produces a gate that takes
`a`.

Accepts~

`a` is a `@ta`, and specifies the aura like `%tas` or `%ta`.

`b` is an atom.

Produces~

A `?`.

Source~
>
    ++  sane
      |=  a=@ta
      |=  b=@  ^-  ?
      ?.  =(%t (end 3 a))
        ::  XX more and better sanity
        ::
        &
      =+  [inx=0 len=(met 3 b)]
      ?:  =(%tas a)
        |-  ^-  ?
        ?:  =(inx len)  &
        =+  cur=(cut 3 [inx 1] b)
        ?&  ?|  &((gte cur 'a') (lte cur 'z'))
                &(=('-' cur) !=(0 inx) !=(len inx))
                &(&((gte cur '0') (lte cur '9')) !=(0 inx))
            ==
            $(inx +(inx))
        ==
      ?:  =(%ta a)
        |-  ^-  ?
        ?:  =(inx len)  &
        =+  cur=(cut 3 [inx 1] b)
        ?&  ?|  &((gte cur 'a') (lte cur 'z'))
                &((gte cur '0') (lte cur '9'))
                |(=('-' cur) =('~' cur) =('_' cur) =('.' cur))
            ==
            $(inx +(inx))
        ==
      |-  ^-  ?
      ?:  =(0 b)  &
      =+  cur=(end 3 b)
      ?:  &((lth cur 32) !=(10 cur))  |
      =+  len=(teff cur)
      ?&  |(=(1 len) =+(i=1 |-(|(=(i len) &((gte (cut 3 [i 1] b) 128) $(i +(i)))))))
          $(b (rsh [3 len] b))
      ==
<

Examples~
>
    > ((sane %tas) %mol)
    %.y
    
    > ((sane %tas) 'lam')
    %.y
    
    > ((sane %tas) 'more ace')
    %.n
<


------------------------------------------------------------------------------
TAFT                                                                  *++taft*

UTF8 to UTF32

Convert `cord` `a` to a UTF32 `@c`.

Accepts~

`a` is a `@t`.

Produces~

A `@c`.

Source~
>
    ++  taft
      |=  a=@t
      ^-  @c
      %+  rap  5
      |-  ^-  (list @c)
      =+  b=(teff a)
      ?:  =(0 b)  ~
      =+  ^=  c
          %+  can  0
          %+  turn
            ^-  (list [p=@ q=@])
            ?+  b  !!
              %1  [[0 7] ~]
              %2  [[8 6] [0 5] ~]
              %3  [[16 6] [8 6] [0 4] ~]
              %4  [[24 6] [16 6] [8 6] [0 3] ~]
            ==
          |=([p=@ q=@] [q (cut 0 [p q] a)])
      ?>  =((tuft c) (end [3 b] a))
      [c $(a (rsh [3 b] a))]
<

Examples~
>
    > (taft 'foobar')
    ~-foobar
    
    > `@ux`'foobar'
    0x7261.626f.6f66
    
    > `@ux`~-foobar
    0x72.0000.0061.0000.0062.0000.006f.0000.006f.0000.0066
<


------------------------------------------------------------------------------
TEFF                                                                  *++teff*

UTF8 Length

Produces the number of utf8 bytes of `a`, a single `@t` character. If `a`
contains more than one character, it will produce the byte-length of the first
one.

Accepts~

`a` is a `@t`.

Produces~

An atom.

Source~
>
    ++  teff
      |=  a=@t  ^-  @
      =+  b=(end 3 a)
      ?:  =(0 b)
        ?>(=(`@`0 a) 0)
      ?>  |((gte b 32) =(10 b))
      ?:((lte b 127) 1 ?:((lte b 223) 2 ?:((lte b 239) 3 4)))
<

Examples~
>
    > (teff 'a')
    1
    
    > (teff '')
    2
    
    > (teff 'a')
    1
<


------------------------------------------------------------------------------
TRIM                                                                  *++trim*

Tape split

Split first `a` characters off `tape` `b`.

Accepts~

`a` is an atom.

`b` is a `tape`.

Produces~

A cell of `tape`s, `p` and `q`.

Source~
>
    ++  trim
      |=  [a=@ b=tape]
      ^-  [p=tape q=tape]
      ?~  b
        [~ ~]
      ?:  =(0 a)
        [~ b]
      =+  c=$(a (dec a), b t.b)
      [[i.b p.c] q.c]
<

Examples~
>
    > (trim 5 "lasok termun")
    [p="lasok" q=" termun"]
    
    > (trim 5 "zam")
    [p="zam" q=""]
<


------------------------------------------------------------------------------
TRIP                                                                  *++trip*

Cord to tape

Produce a `tape` from `cord` `a`.

Accepts~

`a` is an atom.

Produces~

A `tape`.

Source~
>
    ++  trip
      ~/  %trip
      |=  a=@  ^-  tape
      ?:  =(0 (met 3 a))
        ~
      [^-(@ta (end 3 a)) $(a (rsh 3 a))]
<

Examples~
>
    > (trip 'john doe')
    "john doe"
    
    > (trip 'abc 123 !@#')
    "abc 123 !@#"
    
    > (trip 'abc')
    "abc"
<


------------------------------------------------------------------------------
TUBA                                                                  *++tuba*

UTF8 tape to UTF32 tape

Convert `tape` to a `list` of codepoints (`@c`).

Accepts~

`a` is a `tape`.

Produces~

A `(list @c)`.

Source~
>
    ++  tuba
      |=  a=tape
      ^-  (list @c)
      (rip 5 (taft (rap 3 a)))
<

Examples~
>
    > (tuba " ")
    ~[~-~44f. ~-. ~-~442. ~-~443. ~-~442.]
    
    > (tuba "chars")
    ~[~-c ~-h ~-a ~-r ~-s]
<


------------------------------------------------------------------------------
TUFA                                                                  *++tufa*

UTF32 to UTF8 tape

Wrap a `list` of utf32 codepoints into a utf8 `tape`.

Accepts~

`a` is a `(list @c)`.

Produces~

A `tape`.

Source~
>
    ++  tufa
      |=  a=(list @c)
      ^-  tape
      ?~  a  ""
      (weld (rip 3 (tuft i.a)) $(a t.a))
<

Examples~
>
    > (tufa ~[~-~44f. ~-. ~-~442. ~-~443. ~-~442.])
    " "
    
    > (tufa ((list @c) ~[%a %b 0xb1 %c]))
    "abc"
<


------------------------------------------------------------------------------
TUFT                                                                  *++tuft*

UTF32 to UTF8

Convert `@c` to `cord`.

Accepts~

`a` is a `@c`.

Produces~

A `cord`.

Source~
>
    ++  tuft
      |=  a=@c
      ^-  @t
      %+  rap  3
      |-  ^-  (list @)
      ?:  =(`@`0 a)
        ~
      =+  b=(end 5 a)
      =+  c=$(a (rsh 5 a))
      ?:  (lte b 0x7f)
        [b c]
      ?:  (lte b 0x7ff)
        :*  (mix 0b1100.0000 (cut 0 [6 5] b))
            (mix 0b1000.0000 (end [0 6] b))
            c
        ==
      ?:  (lte b 0xffff)
        :*  (mix 0b1110.0000 (cut 0 [12 4] b))
            (mix 0b1000.0000 (cut 0 [6 6] b))
            (mix 0b1000.0000 (end [0 6] b))
            c
        ==
      :*  (mix 0b1111.0000 (cut 0 [18 3] b))
          (mix 0b1000.0000 (cut 0 [12 6] b))
          (mix 0b1000.0000 (cut 0 [6 6] b))
          (mix 0b1000.0000 (end [0 6] b))
          c
      ==
<

Examples~
>
    > (tuft ~-foobar)
    'foobar'
    
    > `@ux`~-foobar
    0x72.0000.0061.0000.0062.0000.006f.0000.006f.0000.0066
    
    > `@ux`'foobar'
    0x7261.626f.6f66
<


------------------------------------------------------------------------------
WACK                                                                  *++wack*

Knot escape

Escape `knot` `~` as `~~` and `_` as `~-`. Used for printing.

Accepts~

`a` is a `knot`.

Produces~

A `knot`.

Source~
>
    ++  wack
      |=  a=@ta
      ^-  @ta
      =+  b=(rip 3 a)
      %+  rap  3
      |-  ^-  tape
      ?~  b
        ~
      ?:  =('~' i.b)  ['~' '~' $(b t.b)]
      ?:  =('_' i.b)  ['~' '-' $(b t.b)]
      [i.b $(b t.b)]
<

Examples~
>
    > (wack '~20_sam~')
    ~.~~20~-sam~~
    
    > `@t`(wack '~20_sam~')
    '~~20~-sam~~'
<


------------------------------------------------------------------------------
WICK                                                                  *++wick*

Knot unescape

Unescape `knot` `~~` as `~` and `~-` as `_`. Produces a `unit`, which is null
if the `knot` contains unescaped `~` characters.

Accepts~

`a` is a an atom.

Produces~

A `(unit @ta)`.

Source~
>
    ++  wick
      |=  a=@
      ^-  (unit @ta)
      =+  b=(rip 3 a)
      =-  ?^(b ~ (some (rap 3 (flop c))))
      =|  c=tape
      |-  ^-  [b=tape c=tape]
      ?~  b  [~ c]
      ?.  =('~' i.b)
        $(b t.b, c [i.b c])
      ?~  t.b  [b ~]
      ?-  i.t.b
        %'~'  $(b t.t.b, c ['~' c])
        %'-'  $(b t.t.b, c ['_' c])
        @     [b ~]
      ==
<

Examples~
>
    > (wick ~.~~20~-sam~~)
    [~ ~.~20_sam~]
    
    > (wick ~.~20~-sam~~)
    ~
<


------------------------------------------------------------------------------
WOAD                                                                  *++woad*

Unescape cord

Unescape `knot`-encoded `cord`.

Accepts~

`a` is a `@ta`.

Produces~

A `cord`.

Source~
>
    ++  woad
      |=  a=@ta
      ^-  @t
      %+  rap  3
      |-  ^-  (list @)
      ?:  =(`@`0 a)
        ~
      =+  b=(end 3 a)
      =+  c=(rsh 3 a)
      ?:  =('.' b)
        [' ' $(a c)]
      ?.  =('~' b)
        [b $(a c)]
      =>  .(b (end 3 c), c (rsh 3 c))
      ?+  b  =-  (weld (rip 3 (tuft p.d)) $(a q.d))
             ^=  d
             =+  d=0
             |-  ^-  [p=@ q=@]
             ?:  =('.' b)
               [d c]
             ?<  =(0 c)
             %=    $
                b  (end 3 c)
                c  (rsh 3 c)
                d  %+  add  (mul 16 d)
                   %+  sub  b
                   ?:  &((gte b '0') (lte b '9'))  48
                   ?>(&((gte b 'a') (lte b 'z')) 87)
             ==
        %'.'  ['.' $(a c)]
        %'~'  ['~' $(a c)]
      ==
<

Examples~
>
    > (woad ~.foo.bar~21.)
    'foo bar!'
<


------------------------------------------------------------------------------
WOOD                                                                  *++wood*

Escape cord

Escape `cord` `a` so it can be encoded in a `knot`.

Accepts~

`a` is a `cord`.

Produces~

A `knot`.

Source~
>
    ++  wood
      |=  a=@t
      ^-  @ta
      %+  rap  3
      |-  ^-  (list @)
      ?:  =(`@`0 a)
        ~
      =+  b=(teff a)
      =+  c=(taft (end [3 b] a))
      =+  d=$(a (rsh [3 b] a))
      ?:  ?|  &((gte c 'a') (lte c 'z'))
              &((gte c '0') (lte c '9'))
              =(`@`'-' c)
          ==
        [c d]
      ?+  c
        :-  '~'
        =+  e=(met 2 c)
        |-  ^-  tape
        ?:  =(0 e)
          ['.' d]
        =.  e  (dec e)
        =+  f=(rsh [2 e] c)
        [(add ?:((lte f 9) 48 87) f) $(c (end [2 e] c))]
      ::
        %' '  ['.' d]
        %'.'  ['~' '.' d]
        %'~'  ['~' '~' d]
      ==
<

Examples~
>
    > (wood 'foo bar!')
    ~.foo.bar~21.
<



==============================================================================
 4c: Tank Printer                                                                         

------------------------------------------------------------------------------
WASH                                                                  *++wash*

Render tank at width

Render `tac` with indent `tab` and maximum width `edg`. If `tac` cannot be
rendered in-line in less than `tac` characters, it will be split into multiple
lines if possible. If `tac` cannot be made to fit, `wash` will crash.

Accepts~

`[tab=@ edg=@]` - `tab` is the number of characters of indentation and `edge`
is the maximum number of characters of width.

`tac` is a `tank`.

Produces~

A `wall` (list of `tape`s).

Source~
>
    ++  wash
      |=  [[tab=@ edg=@] tac=tank]  ^-  wall
      (~(win re tac) tab edg)
<

Examples~
>
    > =rose `tank`[%rose [" " "[" "]"] ~['abc' 'def' 'ghi']]
    
    > ((slog (crip (of-wall:format (wash [0 80] rose))) ~) ~)
    [abc def ghi]
    
    
    > ((slog (crip (of-wall:format (wash [0 8] rose))) ~) ~)
    [ abc
      def
      ghi
    ]
    
    > ((slog (crip (of-wall:format (wash [3 15] rose))) ~) ~)
       [ abc
         def
         ghi
       ]
<

------------------------------------------------------------------------------
RE                                                                  *++re*

Pretty-printing engine

Container core for a pretty-printing engine that accepts a `tank` sample and
contains arms that perform computation on it.

Accepts~

`tac` is a `tank`.

Source~
>
    ++  re
      |_  tac=tank
<


`++ram:re`~

Flatten to tape

Flatten `tank` out into a `tape`.

Accepts~

`tac` is a `tank`, taken from sample of `++re` core.

Produces~

A `tape`.

Source~
>
    ++  ram
      ^-  tape
      ?@  tac
        (trip tac)
      ?-    -.tac
          %leaf  p.tac
      ::
      ::  flat %palm rendered as %rose with welded openers
      ::
          %palm
        =*  mid  p.p.tac
        =*  for  (weld q.p.tac r.p.tac)
        =*  end  s.p.tac
        ram(tac [%rose [mid for end] q.tac])
      ::
      ::  flat %rose rendered with open/mid/close
      ::
          %rose
        =*  mid  p.p.tac
        =*  for  q.p.tac
        =*  end  r.p.tac
        =*  lit  q.tac
        %+  weld
          for
        |-  ^-  tape
        ?~  lit
          end
        %+  weld
          ram(tac i.lit)
        =*  voz  $(lit t.lit)
        ?~(t.lit voz (weld mid voz))
      ==
<

Examples~
>
    > ~(ram re leaf+"foo")
    "foo"
    
    > ~(ram re [%rose [" " "[" "]"] ~['abc' 'def' 'ghi']])
    "[abc def ghi]"
<


`++win:re`~

Render at indent

Render at indent level `tab` and width `edg`.

Accepts~

`tac` is a `tank`, taken from sample of `++re` core.

`tab` and `edg` are atoms.

Produces~

A `wall` (list of `tape`).

Source~
>
    ++  win
      |=  [tab=@ud edg=@ud]
      ::  output stack
      ::
      =|  lug=wall
      |^  ^-  wall
          ?@  tac
            (rig (trip tac))
          ?-    -.tac
              %leaf  (rig p.tac)
          ::
              %palm
            =/  hom  ram
            ?:  (lte (lent hom) (sub edg tab))
              (rig hom)
            ::
            =*  for  q.p.tac
            =*  lit  q.tac
            ?~  lit
              (rig for)
            ?~  t.lit
              =:  tab  (add 2 tab)
                  lug  $(tac i.lit)
                ==
              (rig for)
            ::
            =>  .(lit `(list tank)`lit)
            =/  lyn  (mul 2 (lent lit))
            =.  lug
              |-  ^-  wall
              ?~  lit
                lug
              =/  nyl  (sub lyn 2)
              %=  ^$
                tac  i.lit
                tab  (add tab nyl)
                lug  $(lit t.lit, lyn nyl)
              ==
            (wig for)
          ::
              %rose
            =/  hom  ram
            ?:  (lte (lent hom) (sub edg tab))
              (rig hom)
            ::
            =*  for  q.p.tac
            =*  end  r.p.tac
            =*  lit  q.tac
            =.  lug
              |-  ^-  wall
              ?~  lit
                ?~(end lug (rig end))
              %=  ^$
                tac  i.lit
                tab  (mod (add 2 tab) (mul 2 (div edg 3)))
                lug  $(lit t.lit)
              ==
            ?~(for lug (wig for))
          ==
      ::  +rig: indent tape and cons with output stack
      ::
      ++  rig
        |=  hom=tape
        ^-  wall
        [(runt [tab ' '] hom) lug]
      ::  +wig: indent tape and cons with output stack
      ::
      ::    joined with the top line if whitespace/indentation allow
      ::
      ++  wig
        |=  hom=tape
        ^-  wall
        ?~  lug
          (rig hom)
        =/  wug  :(add 1 tab (lent hom))
        ?.  =+  mir=i.lug
            |-  ^-  ?
            ?~  mir  |
            ?|  =(0 wug)
                ?&(=(' ' i.mir) $(mir t.mir, wug (dec wug)))
            ==
          (rig hom)       :: ^ XX regular form?
        :_  t.lug
        %+  runt  [tab ' ']
        (weld hom `tape`[' ' (slag wug i.lug)])
      --
<

Examples~
>
    > =rose `tank`[%rose [" " "[" "]"] ~['abc' 'def' 'ghi']]
    
    > ((slog (crip (of-wall:format (~(win re rose) 0 80))) ~) ~)
    [abc def ghi]
    
    > ((slog (crip (of-wall:format (~(win re rose) 3 80))) ~) ~)
       [abc def ghi]
    
    > ((slog (crip (of-wall:format (~(win re rose) 0 10))) ~) ~)
    [ abc
      def
      ghi
    ]
    
    > ((slog (crip (of-wall:format (~(win re rose) 3 15))) ~) ~)
       [ abc
         def
         ghi
       ]
<


------------------------------------------------------------------------------
SHOW                                                                  *++show*

Pretty-printer (deprecated)

Pretty prints noun `vem`, producing a `tank`. This function is deprecated and
in most cases produces outdated syntax or incorrect results.

Accepts~

`vem` is a noun.

Produces~

A `tank`.

Source~
>
    ++  show
      |=  vem=*
      |^  ^-  tank
          ?:  ?=(@ vem)
            [%leaf (mesc (trip vem))]
          ?-    vem
              [s=~ c=*]
            [%leaf '\'' (weld (mesc (tape +.vem)) `tape`['\'' ~])]
          ::
              [s=%a c=@]        [%leaf (mesc (trip c.vem))]
              [s=%b c=*]        (shop c.vem |=(a=@ ~(rub at a)))
              [s=[%c p=@] c=*]
            :+  %palm
              [['.' ~] ['-' ~] ~ ~]
            [[%leaf (mesc (trip p.s.vem))] $(vem c.vem) ~]
          ::
              [s=%d c=*]        (shop c.vem |=(a=@ ~(rud at a)))
              [s=%k c=*]        (tank c.vem)
              [s=%h c=*]
            :+  %rose
              [['/' ~] ['/' ~] ~]
            =+  yol=((list @ta) c.vem)
            (turn yol |=(a=@ta [%leaf (trip a)]))
          ::
              [s=%l c=*]        (shol c.vem)
              [s=%o c=*]
            %=    $
                vem
              :-  [%m '%h::[%d %d].[%d %d]>']
              [-.c.vem +<-.c.vem +<+.c.vem +>-.c.vem +>+.c.vem ~]
            ==
          ::
              [s=%p c=*]        (shop c.vem |=(a=@ ~(rup at a)))
              [s=%q c=*]        (shop c.vem |=(a=@ ~(r at a)))
              [s=%r c=*]        $(vem [[%r ' ' '{' '}'] c.vem])
              [s=%t c=*]        (shop c.vem |=(a=@ ~(rt at a)))
              [s=%v c=*]        (shop c.vem |=(a=@ ~(ruv at a)))
              [s=%x c=*]        (shop c.vem |=(a=@ ~(rux at a)))
              [s=[%m p=@] c=*]  (shep p.s.vem c.vem)
              [s=[%r p=@] c=*]
            $(vem [[%r ' ' (cut 3 [0 1] p.s.vem) (cut 3 [1 1] p.s.vem)] c.vem])
          ::
              [s=[%r p=@ q=@ r=@] c=*]
            :+  %rose
              :*  p=(mesc (trip p.s.vem))
                  q=(mesc (trip q.s.vem))
                  r=(mesc (trip r.s.vem))
              ==
            |-  ^-  (list tank)
            ?@  c.vem
              ~
            [^$(vem -.c.vem) $(c.vem +.c.vem)]
          ::
              [s=%z c=*]        $(vem [[%r %$ %$ %$] c.vem])
              *                 !!
          ==
      ++  shep
        |=  [fom=@ gar=*]
        ^-  tank
        =+  l=(met 3 fom)
        =+  i=0
        :-  %leaf
        |-  ^-  tape
        ?:  (gte i l)
          ~
        =+  c=(cut 3 [i 1] fom)
        ?.  =(37 c)
          (weld (mesc [c ~]) $(i +(i)))
        =+  d=(cut 3 [+(i) 1] fom)
        ?.  .?(gar)
          ['\\' '#' $(i (add 2 i))]
        (weld ~(ram re (show d -.gar)) $(i (add 2 i), gar +.gar))
      ::
      ++  shop
        |=  [aug=* vel=$-(a=@ tape)]
        ^-  tank
        ?:  ?=(@ aug)
          [%leaf (vel aug)]
        :+  %rose
          [[' ' ~] ['[' ~] [']' ~]]
        =>  .(aug `*`aug)
        |-  ^-  (list tank)
        ?:  ?=(@ aug)
          [^$ ~]
        [^$(aug -.aug) $(aug +.aug)]
      ::
      ++  shol
        |=  lim=*
        :+  %rose
          [['.' ~] ~ ~]
        |-    ^-  (list tank)
        ?:  ?=(@ lim)  ~
        :_  $(lim +.lim)
        ?+  -.lim  (show '#')
            ~   (show '$')
            c=@  (show c.lim)
            [%& %1]  (show '.')
            [%& c=@]
          [%leaf '+' ~(rud at c.lim)]
        ::
            [%| @ ~]  (show ',')
            [%| n=@ ~ c=@]
          [%leaf (weld (reap n.lim '^') ?~(c.lim "$" (trip c.lim)))]
        ==
      --
<



==============================================================================
 4d: Parsing Tracing                                                                         

------------------------------------------------------------------------------
LAST                                                                  *++last*

Further trace

Compares two line-column pairs, `zyc` and `naz`, producing whichever is
further along.

Accepts~

`zyc` is a `hair`.

`naz` is a `hair`.

Produces~

A `hair`.

Source~
>
    ++  last  |=  [zyc=hair naz=hair]
              ^-  hair
              ?:  =(p.zyc p.naz)
                ?:((gth q.zyc q.naz) zyc naz)
              ?:((gth p.zyc p.naz) zyc naz)
<

Examples~
>
    > (last [1 1] [1 2])
    [p=1 q=2]
    
    > (last [2 1] [1 2])
    [p=2 q=1]
    
    > (last [0 0] [99 0])
    [p=99 q=0]
    
    > (last [7 7] [7 7])
    [p=7 q=7]
<


------------------------------------------------------------------------------
LUST                                                                  *++lust*

Detect newline

Advances `naz` by a row if the `weq` is a newline, or by a column if `weq` is
any other character.

Accepts~

`weq` is a `char`.

`naz` is a `hair`.

Produces~

A `hair`.

Source~
>
    ++  lust  |=  [weq=char naz=hair]
              ^-  hair
              ?:(=(`@`10 weq) [+(p.naz) 1] [p.naz +(q.naz)])
<

Examples~
>
    > (lust `a` [1 1])
    [p=1 q=2]
    
    > (lust `@t`10 [1 1])
    [p=2 q=1]
    
    > (lust '9' [10 10])
    [p=10 q=11]
    
    > (roll "maze" [.(+<+ [1 1])]:lust)
    [1 5]
    
    > %-  roll  :_  [.(+<+ [1 1])]:lust
      """
      Sam
      lokes
      """
    [2 6]
<



==============================================================================
 4e: Parsing Combinators                                                                         

------------------------------------------------------------------------------
BEND                                                                  *++bend*

Conditional composer

Parsing composer: connects the `edge` `vex` with the subsequent `rule` `sab`
as an optional suffix, using gate `raq` to compose or reject its result. If
there is no suffix, or if the suffix fails to be composed with the current
result, the current result is produced. Used to map a group of rules to a
specified output.

Accepts~

`raq` is a gate.

`sab` is a rule.

`vex` is an edge.

Produces~

A `rule`.

Source~
>
    ++  bend
      ~/  %bend
      =+  raq=|*([a=* b=*] [~ u=[a b]])
      |@
      ++  $
        ~/  %fun
        |*  [vex=edge sab=rule]
        ?~  q.vex
          vex
        =+  yit=(sab q.u.q.vex)
        =+  yur=(last p.vex p.yit)
        ?~  q.yit
          [p=yur q=q.vex]
        =+  vux=(raq p.u.q.vex p.u.q.yit)
        ?~  vux
          [p=yur q=q.vex]
        [p=yur q=[~ u=[p=u.vux q=q.u.q.yit]]]
      --
<

Examples~
>
    > (;~((bend |=([a=char b=char] ?.(=(a b) ~ (some +(a))))) prn prn) [1 1] "qs")
    [p=[p=1 q=3] q=[~ u=[p=113 q=[p=[p=1 q=2] q="s"]]]]
    
    > (;~((bend |=([a=char b=char] ?.(=(a b) ~ (some +(a))))) prn prn) [1 1] "qqq")
    [p=[p=1 q=3] q=[~ u=[p=114 q=[p=[p=1 q=3] q="q"]]]]
    
    > `@t`(scan "aa" ;~((bend |=([a=char b=char] ?.(=(a b) ~ (some +(a))))) prn prn))
    'b'
    
    > (scan "ba" ;~((bend |=([a=char b=char] ?.(=(a b) ~ (some +(a))))) prn prn))
    {1 3}
    syntax error
    
    > `(unit @tas)`(scan "" ;~((bend) (easy ~) sym))
    ~
    
    > `(unit @tas)`(scan "sep" ;~((bend) (easy ~) sym))
    [~ %sep]
<


------------------------------------------------------------------------------
COMP                                                                  *++comp*

Arbitrary compose

Parsing composer: connects the `edge` `vex` with a following `rule` `sab`,
combining the contents of `vex` with the result of `sab` using a binary gate
`raq`. Used to fold over the results of several `rule`s.

Accepts~

`raq` is a gate that accepts a cell of two nouns, `a` and `b`, and produces a
cell of two nouns.

`vex` is an edge.

`sab` is a rule.

Produces~

A `rule`.

Source~
>
    ++  comp
      ~/  %comp
      =+  raq=|*([a=* b=*] [a b])
      |@
      ++  $
        ~/  %fun
        |*  [vex=edge sab=rule]
        ~!  +<
        ?~  q.vex
          vex
        =+  yit=(sab q.u.q.vex)
        =+  yur=(last p.vex p.yit)
        ?~  q.yit
          [p=yur q=q.yit]
        [p=yur q=[~ u=[p=(raq p.u.q.vex p.u.q.yit) q=q.u.q.yit]]]
      --
<

Examples~
>
    > (scan "123" ;~((comp |=([a=@ud b=@ud] (add a b))) dit dit dit))
    6
    
    > (scan "12" ;~((comp |=([a=@ud b=@ud] (add a b))) dit dit dit))
    {1 3}
    syntax error
<


------------------------------------------------------------------------------
FAIL                                                                  *++fail*

Never parse

Produces an `edge` at the same text position (`hair`) with a failing result
(`q=~`).

Accepts~

`tub` is a `nail`.

Produces~

An `edge`.

Source~
>
    ++  fail  |=(tub=nail [p=p.tub q=~])
<

Examples~
>
    > (fail [[1 1] "abc"])
    [p=[p=1 q=1] q=~]
    
    > (fail [[p=1.337 q=70] "Parse me, please?"])
    [p=[p=1.337 q=70] q=~]
<


------------------------------------------------------------------------------
GLUE                                                                  *++glue*

Skip delimiter

Parsing composer: connects an `edge` `vex` with a following `rule` `sab` by
parsing the `rule` `bus` (the delimiting symbol) and throwing out the result.

Accepts~

`bus` is a `rule`.

`vex` is an `edge`.

`sab` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  glue
      ~/  %glue
      |*  bus=rule
      ~/  %fun
      |*  [vex=edge sab=rule]
      (plug vex ;~(pfix bus sab))
<

Examples~
>
    > `[@ud @tas @tas]`(scan "200|mal|bon" ;~((glue bar) dem sym sym))
    [200 %mal %bon]
    
    > `[@ud @t @tas]`(scan "200|;|bon" ;~((glue bar) dem mic sym))
    [200 ';' %bon]
<


------------------------------------------------------------------------------
LESS                                                                  *++less*

Parse unless

Parsing composer: if an `edge` `vex` reflects a success, fail. Otherwise,
connect `vex` with the following `rule`.

Accepts~

`vex` is an `edge`.

`sab` is a `rule`.

Produces~

An `edge`.

Source~
>
    ++  less
      |*  [vex=edge sab=rule]
      ?~  q.vex
        =+  roq=(sab)
        [p=(last p.vex p.roq) q=q.roq]
      (fail +<.sab)
<

Examples~
>
    > (scan "sas-/lo" (star ;~(less lus bar prn)))
    "sas-/lo"
    
    > (scan "sas-/l+o" (star ;~(less lus bar prn)))
    ! {1 8}
    ! exit
    
    > (scan "sas|-/lo" (star ;~(less lus bar prn)))
    ! {1 5}
    ! exit
<


------------------------------------------------------------------------------
PFIX                                                                  *++pfix*

Discard first rule

Parsing composer: connects an `edge` `vex` with two subsequent `rule`s,
ignoring the result of the first and producing the result of the second.

Accepts~

`vex` is an `edge`.

`sab` is a `rule`.

Produces~

An `edge`.

Source~
>
    ++  pfix
      ~/  %pfix
      |*  sam=[vex=edge sab=rule]
      %.  sam
      (comp |*([a=* b=*] b))
<

Examples~
>
    > `@t`(scan "%him" ;~(pfix cen sym))
    'him'
    
    > (scan "+++10" ;~(pfix (star lus) dem))
    10
<


------------------------------------------------------------------------------
PLUG                                                                  *++plug*

Parse to tuple

Parsing composer: connects an `edge` `vex` with a following `rule` `sab`,
producing a cell of both the results. See also: the monad applicator `;~` for
a more detailed explanation.

Accepts~

`vex` is an `edge`.

`sab` is a `rule`.

Produces~

An `edge`.

Source~
>
    ++  plug
      ~/  %plug
      |*  [vex=edge sab=rule]
      ?~  q.vex
        vex
      =+  yit=(sab q.u.q.vex)
      =+  yur=(last p.vex p.yit)
      ?~  q.yit
        [p=yur q=q.yit]
      [p=yur q=[~ u=[p=[p.u.q.vex p.u.q.yit] q=q.u.q.yit]]]
<

Examples~
>
    > (scan "1..20" ;~(plug dem dot dot dem))
    [1 '.' '.' 20]
<


------------------------------------------------------------------------------
POSE                                                                  *++pose*

Parse options

Parsing composer: if `vex` reflects a failure, connect it with the following
rule `sab`. See also: the monad applicator `;~`

Accepts~

`vex` is an `edge`.

`sab` is a `rule`.

Produces~

An `edge`.

Source~
>
    ++  pose
      ~/  %pose
      |*  [vex=edge sab=rule]
      ?~  q.vex
        =+  roq=(sab)
        [p=(last p.vex p.roq) q=q.roq]
      vex
<

Examples~
>
    > `@t`(scan "+" ;~(pose lus tar cen))
    '+'
    
    > `@t`(scan "*" ;~(pose lus tar cen))
    '*'
    
    > `@t`(scan "%" ;~(pose lus tar cen))
    '%'
    
    > `@t`(scan "-" ;~(pose lus tar cen))
    ! {1 1}
    ! exit
<


------------------------------------------------------------------------------
SFIX                                                                  *++sfix*

Discard second rule

Parsing composer: connects `edge` `vex` with two subsequent `rule`s returning
the result of the first and discarding the result of the second.

Accepts~

`vex` is an `edge`.

`sab` is a `rule`.

Produces~

An `edge`.

Source~
>
    ++  sfix
      ~/  %sfix
      |*  sam=[vex=edge sab=rule]
      %.  sam
      (comp |*([a=* b=*] a))
<

Examples~
>
    > `@t`(scan "him%" ;~(sfix sym cen))
    'him'
    
    > (scan "10+++" ;~(sfix dem (star lus)))
    q=10
<


------------------------------------------------------------------------------
SIMU                                                                  *++simu*

First and second

Parsing composer: if an `edge` `vex` reflects a failure, fail. Otherwise,
connect `vex` with the following `rule`.

Accepts~

`vex` is an `edge`.

`sab` is a `rule`.

Produces~

An `edge`.

Source~
>
    ++  simu
      |*  [vex=edge sab=rule]
      ?~  q.vex
        vex
      =+  roq=(sab)
      roq
<

Examples~
>
    > (scan "~zod" scat:vast)
    [%dtzy p=%p q=0]
    
    > (scan "%zod" scat:vast)
    [%dtzz p=%tas q=6.582.138]
    
    > (scan "%zod" ;~(simu cen scat:vast))
    [%dtzz p=%tas q=6.582.138]
    
    > (scan "~zod" ;~(simu cen scat:vast))
    ! {1 1}
    ! exit
<



==============================================================================
 4f: Parsing Rule-Builders                                                                         

------------------------------------------------------------------------------
BASS                                                                  *++bass*

Parser modifier: LSB ordered `list` as atom of a `base`.

Accepts~

`wuc` is an atom.

`tyd` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  bass
      |*  [wuc=@ tyd=rule]
      %+  cook
        |=  waq=(list @)
        %+  roll
          waq
        =|([p=@ q=@] |.((add p (mul wuc q))))
      tyd
<

Examples~
>
    > (scan "123" (bass 10 (star dit)))
    q=123
    > (scan "123" (bass 8 (star dit)))
    q=83
    > `@ub`(scan "123" (bass 8 (star dit)))
    0b101.0011
<


------------------------------------------------------------------------------
BOSS                                                                  *++boss*

Parser modifier: LSB

Ordered `list` as atom of a `base`.

Accepts~

`wuc` is an atom.

`tyd` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  boss
      |*  [wuc=@ tyd=rule]
      %+  cook
        |=  waq=(list @)
        %+  reel
          waq
        =|([p=@ q=@] |.((add p (mul wuc q))))
      tyd
<

Examples~
>
    > (scan "123" (boss 10 (star dit)))
    321
    
    > `@t`(scan "bam" (boss 256 (star alp)))
    'bam'
    
    > `@ux`(scan "bam" (boss 256 (star alp)))
    0x6d.6162
<


------------------------------------------------------------------------------
COLD                                                                  *++cold*

Replace with constant

Parser modifier. Accepts a `rule` `sef` and produces a parser that produces a
constant `cus`, assuming `sef` is successful.

Accepts~

`cus` is a constant noun.

`sef` is a `rule`.

Produces~

An `edge`.

Source~
>
    ++  cold
      ~/  %cold
      |*  [cus=* sef=rule]
      ~/  %fun
      |=  tub=nail
      =+  vex=(sef tub)
      ?~  q.vex
        vex
      [p=p.vex q=[~ u=[p=cus q=q.u.q.vex]]]
<

Examples~
>
    > ((cold %foo (just 'a')) [[1 1] "abc"])
    [p=[p=1 q=2] q=[~ u=[p=%foo q=[p=[p=1 q=2] q="bc"]]]]
    
    > ((cold %foo (just 'a')) [[1 1] "bc"])
    [p=[p=1 q=1] q=~]
<


------------------------------------------------------------------------------
COOK                                                                  *++cook*

Apply gate

Parser modifier. Produces a parser that takes a (successful) result of a
`rule` `sef` and slams it through `poq`.

Accepts~

`poq` is a gate.

`sef` is a `rule`.

Produces~

An `rule`.

Source~
>
    ++  cook
      ~/  %cook
      |*  [poq=gate sef=rule]
      ~/  %fun
      |=  tub=nail
      =+  vex=(sef tub)
      ?~  q.vex
        vex
      [p=p.vex q=[~ u=[p=(poq p.u.q.vex) q=q.u.q.vex]]]
<

Examples~
>
    > ((cook ,@ud (just 'a')) [[1 1] "abc"])
    [p=[p=1 q=2] q=[~ u=[p=97 q=[p=[p=1 q=2] q="bc"]]]]
    
    > ((cook ,@tas (just 'a')) [[1 1] "abc"])
    [p=[p=1 q=2] q=[~ u=[p=%a q=[p=[p=1 q=2] q="bc"]]]]
    
    > ((cook |=(a=@ +(a)) (just 'a')) [[1 1] "abc"])
    [p=[p=1 q=2] q=[~ u=[p=98 q=[p=[p=1 q=2] q="bc"]]]]
    
    > ((cook |=(a=@ `@t`+(a)) (just 'a')) [[1 1] "abc"])
    [p=[p=1 q=2] q=[~ u=[p='b' q=[p=[p=1 q=2] q="bc"]]]]
<


------------------------------------------------------------------------------
EASY                                                                  *++easy*

Always parse

Parser generator. Produces a parser that succeeds with given noun `huf`
without consuming any text.

Accepts~

`huf` is a noun.

Produces~

A `rule`.

Source~
>
    ++  easy
      ~/  %easy
      |*  huf=*
      ~/  %fun
      |=  tub=nail
      ^-  (like _huf)
      [p=p.tub q=[~ u=[p=huf q=tub]]]
<

Examples~
>
    > ((easy %foo) [[1 1] "abc"])
    [p=[p=1 q=1] q=[~ [p=%foo q=[p=[p=1 q=1] q="abc"]]]]
    
    > ((easy %foo) [[1 1] "bc"])
    [p=[p=1 q=1] q=[~ [p=%foo q=[p=[p=1 q=1] q="bc"]]]]
    
    > ((easy 'a') [[1 1] "bc"])
    [p=[p=1 q=1] q=[~ [p='a' q=[p=[p=1 q=1] q="bc"]]]]
<


------------------------------------------------------------------------------
FUSS                                                                  *++fuss*

Has A or B?

If string `sic` is parsed: `%.y`. If string `non` is parsed: `%.n`. Otherwise,
fail.

Accepts~

`sic` is a `@t`.

`non` is a `@t`.

Produces~

A `rule`.

Source~
>
    ++  fuss
      |=  [sic=@t non=@t]
      ;~(pose (cold %& (jest sic)) (cold %| (jest non)))
<

Examples~
>
    > (rash 'foo' (fuss 'foo' 'bar'))
    %.y
    
    > (rash 'bar' (fuss 'foo' 'bar'))
    %.n
    
    > (rash 'baz' (fuss 'foo' 'bar'))
    {1 3}
    syntax error
<


------------------------------------------------------------------------------
FULL                                                                  *++full*

Parse to end

Parser modifier. Accepts a `rule` `sef`, and produces a parser that succeeds
only when the `tape` of `tub` is fully consumed using `sef`.

Accepts~

`sef` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  full
      |*  sef=rule
      |=  tub=nail
      =+  vex=(sef tub)
      ?~(q.vex vex ?:(=(~ q.q.u.q.vex) vex [p=p.vex q=~]))
<

Examples~
>
    > ((full (just 'a')) [[1 1] "ab"])
    [p=[p=1 q=2] q=~]
    
    > ((full (jest 'ab')) [[1 1] "ab"])
    [p=[p=1 q=3] q=[~ u=[p='ab' q=[p=[p=1 q=3] q=""]]]]
    
    > ((full ;~(plug (just 'a') (just 'b'))) [[1 1] "ab"])
    [p=[p=1 q=3] q=[~ u=[p=['a' 'b'] q=[p=[p=1 q=3] q=""]]]]
<


------------------------------------------------------------------------------
FUNK                                                                  *++funk*

Add to tape

Parser modifier: prepend text to `tape` before applying parser.

Accepts~

`pre` is a `tape`

`sef` is a `rule`

Produces~

A `rule`.

Source~
>
    ++  funk
      |*  [pre=tape sef=rule]
      |=  tub=nail
      (sef p.tub (weld pre q.tub))
<

Examples~
>
    > ((funk "abc prefix-" (jest 'abc')) [[1 1] "to be parsed"])
    [p=[p=1 q=4] q=[~ [p='abc' q=[p=[p=1 q=4] q=" prefix-to be parsed"]]]]
    
    > ((funk "parse" (just 'a')) [[1 4] " me"])
    [p=[p=1 q=4] q=~]
<


------------------------------------------------------------------------------
HERE                                                                  *++here*

Place-based apply

Parser modifier. Similar to `++cook` in that it produces a parser that takes a
(successful) result of `sef` and slams it through `hez`. `hez` accepts a
`pint` `a` and a noun `b`, which is what the parser parsed.

Accepts~

`hez` is a gate.

`sef` is a `rule`

Produces~

A `rule`.

Source~
>
    ++  here
      ~/  %here
      =+  [hez=|=([a=pint b=*] [a b]) sef=*rule]
      |@
      ++  $
        ~/  %fun
        |=  tub=nail
        =+  vex=(sef tub)
        ?~  q.vex
          vex
        [p=p.vex q=[~ u=[p=(hez [p.tub p.q.u.q.vex] p.u.q.vex) q=q.u.q.vex]]]
      --
<

Examples~
>
    > (scan "abc" (star alf))
    "abc"
    
    > (scan "abc" (here |*(^ +<) (star alf)))
    [[[p=1 q=1] p=1 q=4] "abc"]
    
    > (scan "abc" (star (here |*(^ +<) alf)))
    ~[[[[p=1 q=1] p=1 q=2] ~~a] [[[p=1 q=2] p=1 q=3] ~~b] [[[p=1 q=3] p=1 q=4] ~~c]]
<

------------------------------------------------------------------------------
INDE                                                                  *++inde*

Indentation block

Apply `rule` to indented block starting at current column number, omitting the
leading whitespace.

Accepts~

`sef` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  inde  |*  sef=rule
      |=  nail  ^+  (sef)
      =+  [har tap]=[p q]:+<
      =+  lev=(fil 3 (dec q.har) ' ')
      =+  eol=(just `@t`10)
      =+  =-  roq=((star ;~(pose prn ;~(sfix eol (jest lev)) -)) har tap)
          ;~(simu ;~(plug eol eol) eol)
      ?~  q.roq  roq
      =+  vex=(sef har(q 1) p.u.q.roq)
      =+  fur=p.vex(q (add (dec q.har) q.p.vex))
      ?~  q.vex  vex(p fur)
      =-  vex(p fur, u.q -)
      :+  &3.vex
        &4.vex(q.p (add (dec q.har) q.p.&4.vex))
      =+  res=|4.vex
      |-  ?~  res  |4.roq
      ?.  =(10 -.res)  [-.res $(res +.res)]
      (welp [`@t`10 (trip lev)] $(res +.res))
<

Examples~
>
    > `tape`(scan "   foo\0a   bar" ;~(pfix ace ace ace (inde (star ;~(pose prn (just '\0a'))))))
    "foo\0abar"
<

Discussion~

Note the amount of indentation whitespace to be stripped from the beginning of
each line is determined by the value of `q` (the column) in the `hair` when
`++inde` is first called. This means something like the `pfix` expression in
the example above is necessary to set the level of indentation. Additionally,
the `rule` given to `++inde` must consume the whole line including the line
ending.


------------------------------------------------------------------------------
IFIX                                                                  *++ifix*

Infix

Parser modifier: surround with pair of `rule`s, the output of which is
discarded.

Accepts~

`fel` is a pair of `rule`s.

`hof` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  ifix
      |*  [fel=[rule rule] hof=rule]
      ~!  +<
      ~!  +<:-.fel
      ~!  +<:+.fel
      ;~(pfix -.fel ;~(sfix hof +.fel))
<

Examples~
>
    > (scan "-40-" (ifix [hep hep] dem))
    40
    
    > (scan "4my4" (ifix [dit dit] (star alf)))
    "my"
<


------------------------------------------------------------------------------
JEST                                                                  *++jest*

Match a cord

Match and consume a cord.

Accepts~

`daf` is a `@t`.

Produces~

A `rule`.

Source~
>
    ++  jest
      |=  daf=@t
      |=  tub=nail
      =+  fad=daf
      |-  ^-  (like @t)
      ?:  =(`@`0 daf)
        [p=p.tub q=[~ u=[p=fad q=tub]]]
      ?:  |(?=(~ q.tub) !=((end 3 daf) i.q.tub))
        (fail tub)
      $(p.tub (lust i.q.tub p.tub), q.tub t.q.tub, daf (rsh 3 daf))
<

Examples~
>
    > ((jest 'abc') [[1 1] "abc"])
    [p=[p=1 q=4] q=[~ [p='abc' q=[p=[p=1 q=4] q=""]]]]
    
    > (scan "abc" (jest 'abc'))
    'abc'
    
    > (scan "abc" (jest 'acb'))
    ! {1 2}
    ! 'syntax-error'
    ! exit
    
    > ((jest 'john doe') [[1 1] "john smith"])
    [p=[p=1 q=6] q=~]
    
    > ((jest 'john doe') [[1 1] "john doe"])
    [p=[p=1 q=9] q=[~ [p='john doe' q=[p=[p=1 q=9] q=""]]]]
<


------------------------------------------------------------------------------
JUST                                                                  *++just*

Match a char

Match and consume a single character.

Accepts~

`daf` is a `char`

Produces~

A `rule`.

Source~
>
    ++  just
      ~/  %just
      |=  daf=char
      ~/  %fun
      |=  tub=nail
      ^-  (like char)
      ?~  q.tub
        (fail tub)
      ?.  =(daf i.q.tub)
        (fail tub)
      (next tub)
<

Examples~
>
    > ((just 'a') [[1 1] "abc"])
    [p=[p=1 q=2] q=[~ [p='a' q=[p=[p=1 q=2] q="bc"]]]]
    
    > (scan "abc" (just 'a'))
    ! {1 2}
    ! 'syntax-error'
    ! exit
    
    > (scan "a" (just 'a'))
    'a'
    
    > (scan "%" (just '%'))
    '%'
<


------------------------------------------------------------------------------
KNEE                                                                  *++knee*

Recursive parsers

Used for recursive parsers, which would otherwise be infinite when compiled.

Accepts~

`gar` is a noun.

`sef` is a gate that accepts a `rule`

Produces~

A `rule`.

Source~
>
    ++  knee
      =|  [gar=* sef=_|.(*rule)]
      |@  ++  $
            |=  tub=nail
            ^-  (like _gar)
            ((sef) tub)
      --
<

Examples~
>
    > |-(;~(plug prn ;~(pose $ (easy ~))))
    ! rest-loop
    ! exit
    
    > |-(;~(plug prn ;~(pose (knee *tape |.(^$)) (easy ~))))
    < 1.obo
      [ c=c=tub=[p=[p=@ud q=@ud] q=""]
          b
        < 1.bes
          [ c=tub=[p=[p=@ud q=@ud] q=""]
            b=<1.tnv [tub=[p=[p=@ud q=@ud] q=""] <1.ktu [daf=@tD <414.fvk 101.jzo 1.ypj %164>]>]>
            a=<1.fvg [tub=[p=[p=@ud q=@ud] q=""] <1.khu [[les=@ mos=@] <414.fvk 101.jzo 1.ypj %164>]>]>
            v=<414.fvk 101.jzo 1.ypj %164>
          ]
        >
          a
        ... 450 lines omitted ...
      ]
    >
    
    > (scan "abcd" |-(;~(plug prn ;~(pose (knee *tape |.(^$)) (easy ~)))))
    ['a' "bcd"]
<


------------------------------------------------------------------------------
MASK                                                                  *++mask*

Match char

Parser generator. Matches the next character if it is in a list of characters.

Accepts~

`bud` is a list of `char`

Produces~

A `rule`.

Source~
>
    ++  mask
      ~/  %mask
      |=  bud=(list char)
      ~/  %fun
      |=  tub=nail
      ^-  (like char)
      ?~  q.tub
        (fail tub)
      ?.  (lien bud |=(a=char =(i.q.tub a)))
        (fail tub)
      (next tub)
<

Examples~
>
    > (scan "a" (mask "cba"))
    'a'
    
    > ((mask "abc") [[1 1] "abc"])
    [p=[p=1 q=2] q=[~ [p='a' q=[p=[p=1 q=2] q="bc"]]]]
    
    > ((mask "abc") [[1 1] "bbc"])
    [p=[p=1 q=2] q=[~ [p='b' q=[p=[p=1 q=2] q="bc"]]]]
    
    > ((mask "abc") [[1 1] "dbc"])
    [p=[p=1 q=1] q=~]
<


------------------------------------------------------------------------------
MORE                                                                  *++more*

Parse list with delimiter

Parser modifier: Parse a list of matches using a delimiter `rule`.

Accepts~

`bus` is a `rule`.

`fel` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  more
      |*  [bus=rule fel=rule]
      ;~(pose (most bus fel) (easy ~))
<

Examples~
>
    > (scan "" (more ace dem))
    ~
    
    > (scan "40 20" (more ace dem))
    [40 [i=20 t=~]]
    
    > (scan "40 20 60 1 5" (more ace dem))
    [40 [i=20 t=~[60 1 5]]]
<


------------------------------------------------------------------------------
MOST                                                                  *++most*

Parse list of at least one match

Parser modifier: parse a `list` of at least one match using a delimiter
`rule`.

Accepts~

`bus` is a `rule`.

`fel` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  most
      |*  [bus=rule fel=rule]
      ;~(plug fel (star ;~(pfix bus fel)))
<

Examples~
>
    > (scan "40 20" (most ace dem))
    [40 [i=20 t=~]]
    
    > (scan "40 20 60 1 5" (most ace dem))
    [40 [i=20 t=~[60 1 5]]]
    
    > (scan "" (most ace dem))
    ! {1 1}
    ! exit
<


------------------------------------------------------------------------------
NEXT                                                                  *++next*

Consume char

Consume any character, producing it as a result.

Accepts~

`tub` is a `nail`

Produces~

An `edge`.

Source~
>
    ++  next
      |=  tub=nail
      ^-  (like char)
      ?~  q.tub
        (fail tub)
      =+  zac=(lust i.q.tub p.tub)
      [zac [~ i.q.tub [zac t.q.tub]]]
<

Examples~
>
    > (next [[1 1] "ebc"])
    [p=[p=1 q=2] q=[~ [p='e' q=[p=[p=1 q=2] q="bc"]]]]
    
    > (next [[1 1] "john jumps jones"])
    [p=[p=1 q=2] q=[~ [p='j' q=[p=[p=1 q=2] q="ohn jumps jones"]]]]
<


------------------------------------------------------------------------------
PERK                                                                  *++perk*

Parse cube fork

Given `a`, a list of `@tas`, match any one in the list and produce it. Note
the list should not be a `list` type, but just a null-terminated cell like
`~[%foo %bar %baz]`. The type produced will be a union of the items in the
given list, so you can use a `?-` expression on the output.

Accepts~

`a` is a `(pole @tas)`.

Produces~

A `rule`.

Source~
>
    ++  perk
      |*  a=(pole @tas)
      ?~  a  fail
      ;~  pose
        (cold -.a (jest -.a))
        $(a +.a)
      ==
<

Examples~
>
    > (scan "foo" (perk ~[%foo %bar]))
    %foo
    
    > (scan "bar" (perk ~[%foo %bar]))
    %bar
    
    > (scan "baz" (perk ~[%foo %bar]))
    {1 3}
    syntax error
<


------------------------------------------------------------------------------
PLUS                                                                  *++plus*

List of at least one match.

Parser modifier: parse `list` of at least one match.

Accepts~

`fel` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  plus  |*(fel=rule ;~(plug fel (star fel)))          ::
<

Examples~
>
    > (scan ">>>>" (cook lent (plus gar)))
    4
    
    > (scan "-  - " (plus ;~(pose ace hep)))
    ['-' [i=' ' t=~[' ' '-' ' ']]]
    
    > `tape`(scan "-  - " (plus ;~(pose ace hep)))
    "-  - "
    
    > `(pole ,@t)`(scan "-  - " (plus ;~(pose ace hep)))
    ['-' [' ' [' ' ['-' [' ' ~]]]]]
<


------------------------------------------------------------------------------
PUNT                                                                  *++punt*

Unitized parse

Either successfully apply `rule` `a` and produce a `unit` of the result, or
produce `~`.

Accepts~

`a` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  punt  |*([a=rule] ;~(pose (stag ~ a) (easy ~)))
<

Example~
>
    > ((punt (jest 'foo')) 1^1 "foo")
    [p=[p=1 q=4] q=[~ u=[p=[~ 'foo'] q=[p=[p=1 q=4] q=~]]]]
    
    > ((punt (jest 'foo')) 1^1 "bar")
    [p=[p=1 q=1] q=[~ [p=~ q=[p=[p=1 q=1] q="bar"]]]]
<


------------------------------------------------------------------------------
SEAR                                                                  *++sear*

Conditional `cook`

Conditional `cook`. Slams the result through a gate that produces a unit; if
that unit is empty, fail.

Accepts~

`pyq` is a gate that produces a `unit`.

`sef` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  sear
      |*  [pyq=$-(* (unit)) sef=rule]
      |=  tub=nail
      =+  vex=(sef tub)
      ?~  q.vex
        vex
      =+  gey=(pyq p.u.q.vex)
      ?~  gey
        [p=p.vex q=~]
      [p=p.vex q=[~ u=[p=u.gey q=q.u.q.vex]]]
<

Examples~
>
    > ((sear |=(a=* ?@(a (some a) ~)) (just 'a')) [[1 1] "abc"])
    [p=[p=1 q=2] q=[~ u=[p=97 q=[p=[p=1 q=2] q="bc"]]]]
    
    > ((sear |=(* ~) (just 'a')) [[1 1] "abc"])
    [p=[p=1 q=2] q=~]
<


------------------------------------------------------------------------------
SHIM                                                                  *++shim*

Char in range

Match characters (`char`) within a range.

Accepts~

`les` is an atom.

`mos` is an atom.

Produces~

A `rule`.

Source~
>
    ++  shim
      ~/  %shim
      |=  [les=@ mos=@]
      ~/  %fun
      |=  tub=nail
      ^-  (like char)
      ?~  q.tub
        (fail tub)
      ?.  ?&((gte i.q.tub les) (lte i.q.tub mos))
        (fail tub)
      (next tub)
<

Examples~
>
    > `tape`(rash 'abc' (plus (shim 'a' 'z')))
    "abc"
    
    > `tape`(rash 'ABC' (plus (shim 'a' 'z')))
    {1 1}
    syntax error
<


------------------------------------------------------------------------------
SLUG                                                                  *++slug*

Use gate to parse delimited list

Parser modifier: By composing with a gate, parse a delimited `list` of
matches.

Accepts~

`raq` is a binary gate.

`bus` is a `rule`.

`fel` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  slug
      |*  raq=_=>(~ |*([a=* b=*] [a b]))
      |*  [bus=rule fel=rule]
      ;~((comp raq) fel (stir +<+.raq raq ;~(pfix bus fel)))
<

Examples~
>
    > (scan "20+5+110" ((slug add) lus dem))
    135
    
    > `@t`(scan "a b c" ((slug |=(a=[@t @t] (cat 3 a))) ace alp))
    'abc'
<


------------------------------------------------------------------------------
STAG                                                                  *++stag*

Add label

Add a label to an `edge` parsed by a `rule`.

Accepts~

`gob` is a noun.

`sef` is a rule.

Produces~

A `rule`.

Source~
>
    ++  stag
      ~/  %stag
      |*  [gob=* sef=rule]
      ~/  %fun
      |=  tub=nail
      =+  vex=(sef tub)
      ?~  q.vex
        vex
      [p=p.vex q=[~ u=[p=[gob p.u.q.vex] q=q.u.q.vex]]]
<

Examples~
>
    > (rash 'abc' (stag %foo (jest 'abc')))
    [%foo 'abc']
<


------------------------------------------------------------------------------
STAR                                                                  *++star*

List of matches

Parser modifier: parse `list` of matches.

Accepts~

`fel` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  star
      |*  fel=rule
      (stir `(list _(wonk *fel))`~ |*([a=* b=*] [a b]) fel)
<

Examples~
>
    > (scan "aaaaa" (just 'a'))
    ! {1 2}
    ! 'syntax-error'
    ! exit
    
    > (scan "aaaaa" (star (just 'a')))
    "aaaaa"
    
    > (scan "abcdef" (star (just 'a')))
    ! {1 2}
    ! 'syntax-error'
    ! exit
    
    > (scan "abcabc" (star (jest 'abc')))
    <|abc abc|>
    
    > (scan "john smith" (star (shim 0 200)))
    "john smith"
<


------------------------------------------------------------------------------
STET                                                                  *++stet*

Add faces

Add faces `[p q]` to range-parser pairs in a list. Typically used in
combination with `++stew`.

Accepts~

`leh` is a list of range-parsers.

Produces~

A `(list [p=?(@ [@ @]) q=rule])`.

Source~
>
    ++  stet
      |*  leh=(list [?(@ [@ @]) rule])
      |-
      ?~  leh
        ~
      [i=[p=-.i.leh q=+.i.leh] t=$(leh t.leh)]
<

Examples~
>
    > =rule %-  stew
            %-  stet
            %-  limo
            :~
              [['a' 'z'] (cook |=(a=@ (sub a 32)) alp)]
              [['A' 'Z'] (cook |=(a=@ (add a 32)) alp)]
            ==
    
    > `tape`(rash 'fooBARbaz' (star rule))
    "FOObarBAZ"
<


------------------------------------------------------------------------------
STEW                                                                  *++stew*

Switch by first char

Parser generator. From an associative `list` of characters or character ranges
to `rule`s, construct a `map`, and parse `tape`s only with `rule`s associated
with a range that the `tape`'s first character falls in.

Accepts~

`leh` is a `(list [p=?(@ [@ @]) q=rule])`, where `p` is a `char` or `char`
range.

Produces~

A `rule`.

Source~
>
    ++  stew                                                ::  switch by first char
      ~/  %stew
      |*  leh=(list [p=?(@ [@ @]) q=rule])                  ::  char+range keys
      =+  ^=  wor                                           ::  range complete lth
          |=  [ort=?(@ [@ @]) wan=?(@ [@ @])]
          ?@  ort
            ?@(wan (lth ort wan) (lth ort -.wan))
          ?@(wan (lth +.ort wan) (lth +.ort -.wan))
      =+  ^=  hel                                           ::  build parser map
          =+  hel=`(tree _?>(?=(^ leh) i.leh))`~
          |-  ^+  hel
          ?~  leh
            ~
          =+  yal=$(leh t.leh)
          |-  ^+  hel
          ?~  yal
            [i.leh ~ ~]
          ?:  (wor p.i.leh p.n.yal)
            =+  nuc=$(yal l.yal)
            ?>  ?=(^ nuc)
            ?:  (mor p.n.yal p.n.nuc)
              [n.yal nuc r.yal]
            [n.nuc l.nuc [n.yal r.nuc r.yal]]
          =+  nuc=$(yal r.yal)
          ?>  ?=(^ nuc)
          ?:  (mor p.n.yal p.n.nuc)
            [n.yal l.yal nuc]
          [n.nuc [n.yal l.yal l.nuc] r.nuc]
      ~%  %fun  ..^$  ~
      |=  tub=nail
      ?~  q.tub
        (fail tub)
      |-
      ?~  hel
        (fail tub)
      ?:  ?@  p.n.hel
            =(p.n.hel i.q.tub)
          ?&((gte i.q.tub -.p.n.hel) (lte i.q.tub +.p.n.hel))
        ::  (q.n.hel [(lust i.q.tub p.tub) t.q.tub])
        (q.n.hel tub)
      ?:  (wor i.q.tub p.n.hel)
        $(hel l.hel)
      $(hel r.hel)
<

Examples~
>
    > =rule %-  stew
            %-  stet
            %-  limo
            :~
              [['a' 'z'] (cook |=(a=@ (sub a 32)) alp)]
              [['A' 'Z'] (cook |=(a=@ (add a 32)) alp)]
            ==
    
    > `tape`(rash 'fooBARbaz' (star rule))
    "FOObarBAZ"
<


------------------------------------------------------------------------------
STIR                                                                  *++stir*

Parse repeatedly

Parse with `rule` as many times as possible, and fold over results with a
binary gate.

Accepts~

`rud` is a noun.

`raq` is a gate that takes two nouns and produces a cell.

`fel` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  stir
      ~/  %stir
      |*  [rud=* raq=_=>(~ |*([a=* b=*] [a b])) fel=rule]
      ~/  %fun
      |=  tub=nail
      ^-  (like _rud)
      ::
      ::  lef: successful interim parse results (per .fel)
      ::  wag: initial accumulator (.rud in .tub at farthest success)
      ::
      =+  ^=  [lef wag]
        =|  lef=(list _(fel tub))
        |-  ^-  [_lef (pair hair [~ u=(pair _rud nail)])]
        =+  vex=(fel tub)
        ?~  q.vex
          :-  lef
          [p.vex [~ rud tub]]
        $(lef [vex lef], tub q.u.q.vex)
      ::
      ::  fold .lef into .wag, combining results with .raq
      ::
      %+  roll  lef
      |=  _[vex=(fel tub) wag=wag]  :: q.vex is always (some)
      ^+  wag
      :-  (last p.vex p.wag)
      [~ (raq p.u.+.q.vex p.u.q.wag) q.u.q.wag]
<

Examples~
>
    > (scan "abc" (stir *@ add prn))
    294
    
    > (roll "abc" add)
    294
<


------------------------------------------------------------------------------
STUN                                                                  *++stun*

Parse several times

Parse bounded number of times.

Accepts~

`lig` is a cell of atoms (`[@ @]`) indicating the bounds.

`fel` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  stun
      ~/  %stun
      |*  [lig=[@ @] fel=rule]
      |=  tub=nail
      ^-  (like (list _(wonk (fel))))
      ?:  =(0 +.lig)
        [p.tub [~ ~ tub]]
      =+  vex=(fel tub)
      ?~  q.vex
        ?:  =(0 -.lig)
          [p.vex [~ ~ tub]]
        vex
      =+  ^=  wag  %=  $
                     -.lig  ?:(=(0 -.lig) 0 (dec -.lig))
                     +.lig  ?:(=(0 +.lig) 0 (dec +.lig))
                     tub  q.u.q.vex
                   ==
      ?~  q.wag
        wag
      [p.wag [~ [p.u.q.vex p.u.q.wag] q.u.q.wag]]
<

Examples~
>
    > ((stun [5 10] prn) [1 1] "aquickbrownfoxran")
    [p=[p=1 q=11] q=[~ [p="aquickbrow" q=[p=[p=1 q=11] q="nfoxran"]]]]
    
    > ((stun [5 10] prn) [1 1] "aquickbro")
    [p=[p=1 q=10] q=[~ [p="aquickbro" q=[p=[p=1 q=10] q=""]]]]
    
    > ((stun [5 10] prn) [1 1] "aqui")
    [p=[p=1 q=5] q=~]
<



==============================================================================
 4g: Parsing Outside Caller                                                                         

------------------------------------------------------------------------------
RASH                                                                  *++rash*

Parse or crash

Parse a cord with a given `rule` and crash if the `cord` isn't entirely
parsed.

Accepts~

`naf` is an atom.

`sab` is a `rule`.

Produces~

The value of the parse result, or crash.

Source~
>
    ++  rash  |*([naf=@ sab=rule] (scan (trip naf) sab))
<

Examples~
>
    > (rash 'I was the world in which I walked, and what I saw' (star (shim 0 200)))
    "I was the world in which I walked, and what I saw"
    
    > (rash 'abc' (just 'a'))
    ! {1 2}
    ! 'syntax-error'
    ! exit
    
    > (rash 'abc' (jest 'abc'))
    'abc'
    
    > (rash 'abc' (jest 'ab'))
    ! {1 3}
    ! 'syntax-error'
    ! exit
<


------------------------------------------------------------------------------
ROSE                                                                  *++rose*

Parse to each

Parse `tape` `los` with `rule` `sab`, producing an `(each @ud (unit *))`. If
`los` was not fully consumed, the result is `%.n` and `p` contains the column
number before failure occurred. If `los` was fully consumed, the result is
`%.y` and `p` contains either `sab`'s result in a `unit`, or a null `unit` if
parsing failed.

Accepts~

`los` is a `tape`.

`sab` is a `rule`.

Produces~

`(each @ud (unit *))`, where the `*` is whatever type the `rule` produces.

Source~
>
    ++  rose  |*  [los=tape sab=rule]
              =+  vex=(sab [[1 1] los])
              =+  len=(lent los)
              ?.  =(+(len) q.p.vex)  [%| p=(dec q.p.vex)]
              ?~  q.vex
                [%& p=~]
              [%& p=[~ u=p.u.q.vex]]
<

Examples~
>
    > (rose "!" zap)
    [%.y p=[~ u='!']]
    
    > (rose "?" zap)
    [%.n p=0]
    
    > (rose "!?" zap)
    [%.n p=1]
    
    > (rose "!" ;~(plug zap fail))
    [%.y p=~]
<


------------------------------------------------------------------------------
RUSH                                                                  *++rush*

Parse or null

Parse an atom with a given rule and produce null if the cord isn't entirely
parsed.

Accepts~

`naf` is an atom.

`sab` is a rule.

Produces~

The value of the parse result, or null.

Source~
>
    ++  rush  |*([naf=@ sab=rule] (rust (trip naf) sab))
<

Examples~
>
    > (rush 'I was the world in which I walked, and what I saw' (star (shim 0 200)))
    [~ "I was the world in which I walked, and what I saw"]
    
    > (rush 'abc' (just 'a'))
    ~
    
    > (rush 'abc' (jest 'abc'))
    [~ 'abc']
    
    > (rush 'abc' (jest 'ac'))
    ~
    
    > (rush 'abc' (jest 'ab'))
    ~
<


------------------------------------------------------------------------------
RUST                                                                  *++rust*

Parse tape or null

Parse a `tape` with a given `rule` and produce null if the `tape` isn't
entirely parsed.

Accepts~

`los` is a `tape`.

`sab` is a `rule`.

Produces~

A `(unit *)`, where `*` is the type produced by `sab`.

Source~
>
    ++  rust  |*  [los=tape sab=rule]
              =+  vex=((full sab) [[1 1] los])
              ?~(q.vex ~ [~ u=p.u.q.vex])
<

Examples~
>
    > (rust "I was the world in which I walked, and what I saw" (star (shim 0 200)))
    [~ "I was the world in which I walked, and what I saw"]
    
    > (rust "Or heard or felt came not but from myself;" (star (shim 0 200)))
    [~ "Or heard or felt came not but from myself;"]
    
    > (rust "And there I found myself more truly and more strange." (jest 'And there I'))
    ~
<


------------------------------------------------------------------------------
SCAN                                                                  *++scan*

Parse tape or crash

Parse a `tape` with a given `rule` and crash if the `tape` isn't entirely
parsed.

Accepts~

`los` is a `tape`.

`sab` is a `rule`.

Produces~

Either a `tape` or a crash.

Source~
>
    ++  scan  |*  [los=tape sab=rule]
              =+  vex=((full sab) [[1 1] los])
              ?~  q.vex
                ~_  (show [%m '{%d %d}'] p.p.vex q.p.vex ~)
                ~_(leaf+"syntax error" !!)
              p.u.q.vex
<

Examples~
>
    > (scan "I was the world in which I walked, and what I saw" (star (shim 0 200)))
    "I was the world in which I walked, and what I saw"
    
    > (scan "Or heard or felt came not but from myself;" (star (shim 0 200)))
    "Or heard or felt came not but from myself;"
    
    > (scan "And there I found myself more truly and more strange." (jest 'And there I'))
    ! {1 12}
    ! 'syntax-error'
    ! exit
<



==============================================================================
 4h: Parsing ASCII Glyphs                                                                         

------------------------------------------------------------------------------
ACE                                                                  *++ace*

Parse space

Parses ASCII character 32, space.

Source~
>
    ++  ace  (just ' ')
<

Examples~
>
    > (scan " " ace)
    ' '
<


------------------------------------------------------------------------------
BAR                                                                  *++bar*

Parse vertical bar

Parses ASCII character 124, the vertical bar.

Source~
>
    ++  bar  (just '|')
<

Examples~
>
    > (scan "|" bar)
    '|'
<


------------------------------------------------------------------------------
BAS                                                                  *++bas*

Parse backslash

Parses ASCII character 92, the backslash. Note the extra `\` in the calling of
`bas` with `just` is to escape the escape character, `\`.

Source~
>
    ++  bas  (just '\\')
<

Examples~
>
    > (scan "\\" bas)
    '\\'
<


------------------------------------------------------------------------------
BUC                                                                  *++buc*

Parse dollar sign

Parses ASCII character 36, the dollar sign.

Source~
>
    ++  buc  (just '$')
<

Examples~
>
    > (scan "$" buc)
    '$'
<


------------------------------------------------------------------------------
CAB                                                                  *++cab*

Parse underscore

Parses ASCII character 95, the underscore.

Source~
>
    ++  cab  (just '_')
<

Examples~
>
    > (scan "_" cab)
    '_'
<


------------------------------------------------------------------------------
CEN                                                                  *++cen*

Parses percent sign

Parses ASCII character 37, the percent sign.

Source~
>
    ++  cen  (just '%')
<

Examples~
>
    > (scan "%" cen)
    '%'
<


------------------------------------------------------------------------------
COL                                                                  *++col*

Parse colon

Parses ASCII character 58, the colon

Source~
>
    ++  col  (just ':')
<

Examples~
>
    > (scan ":" col)
    ':'
<


------------------------------------------------------------------------------
COM                                                                  *++com*

Parse comma

Parses ASCII character 44, the comma.

Source~
>
    ++  com  (just ',')
<

Examples~
>
    > (scan "," com)
    ','
<


------------------------------------------------------------------------------
DOQ                                                                  *++doq*

Parse double quote

Parses ASCII character 34, the double quote.

Source~
>
    ++  doq  (just '"')
<

Examples~
>
    > (scan "\"" doq)
    '"'
<


------------------------------------------------------------------------------
DOT                                                                  *++dot*

Parse period

Parses ASCII character 46, the period.

Source~
>
    ++  dot  (just '.')
<

Examples~
>
    > (scan "." dot)
    '.'
<


------------------------------------------------------------------------------
FAS                                                                  *++fas*

Parse forward slash

Parses ASCII character 47, the forward slash.

Source~
>
    ++  fas  (just '/')
<

Examples~
>
    > (scan "/" fas)
    '/'
<


------------------------------------------------------------------------------
GAL                                                                  *++gal*

Parse less-than sign

Parses ASCII character 60, the less-than sign.

Source~
>
    ++  gal  (just '<')
<

Examples~
>
    > (scan "<" gal)
    '<'
<


------------------------------------------------------------------------------
GAR                                                                  *++gar*

Parse greater-than sign

Parses ASCII character 62, the greater-than sign.

Source~
>
    ++  gar  (just '>')
<

Examples~
>
    > (scan ">" gar)
    '>'
<


------------------------------------------------------------------------------
HAX                                                                  *++hax*

Parse number sign

Parses ASCII character 35, the number sign.

Source~
>
    ++  hax  (just '#')
<

Examples~
>
    > (scan "#" hax)
    '#'
<


------------------------------------------------------------------------------
HEP                                                                  *++hep*

Parse hyphen

Parses ASCII character 45, the hyphen.

Source~
>
    ++  hep  (just '-')
<

Examples~
>
    > (scan "-" hep)
    '-'
<


------------------------------------------------------------------------------
KEL                                                                  *++kel*

Parse left curley bracket

Parses ASCII character 123, the left curly bracket. Note that `{` (`kel`)
opens a Hoon expression for Hoon string interpolation. To parse it, therefore,
it must be escaped.

Source~
>
    ++  kel  (just '{')
<

Examples~
>
    > (scan "\{" kel)
    '{'
<


------------------------------------------------------------------------------
KER                                                                  *++ker*

Parse right curley bracket

Parses ASCII character 125, the right curly bracket.

Source~
>
    ++  ker  (just '}')
<

Examples~
>
    > (scan "}" ker)
    '}'
<


------------------------------------------------------------------------------
KET                                                                  *++ket*

Parse caret

Parses ASCII character 94, the caret.

Source~
>
    ++  ket  (just '^')
<

Examples~
>
    > (scan "^" ket)
    '^'
<


------------------------------------------------------------------------------
LUS                                                                  *++lus*

Parse plus sign

Parses ASCII character 43, the plus sign.

Source~
>
    ++  lus  (just '+')
<

Examples~
>
    > (scan "+" lus)
    '+'
<


------------------------------------------------------------------------------
MIC                                                                  *++mic*

Parse semicolon

Parses ASCII character 59, the semicolon.

Source~
>
    ++  mic  (just ';')
<

Examples~
>
    > (scan ";" mic)
    ';'
<


------------------------------------------------------------------------------
PAL                                                                  *++pal*

Parse left parenthesis

Parses ASCII character 40, the left parenthesis.

Source~
>
    ++  pal  (just '(')
<

Examples~
>
    > (scan "(" pal)
    '('
<


------------------------------------------------------------------------------
PAM                                                                  *++pam*

Parse ampersand

Parses ASCII character 38, the ampersand.

Source~
>
    ++  pam  (just '&')
<

Examples~
>
    > (scan "&" pam)
    '&'
<


------------------------------------------------------------------------------
PAR                                                                  *++par*

Parse right parenthesis

Parses ASCII character 41, the right parenthesis.

Source~
>
    ++  par  (just ')')
<

Examples~
>
    > (scan ")" par)
    ')'
<


------------------------------------------------------------------------------
PAT                                                                  *++pat*

Parse "at" sign

Parses ASCII character 64, the "at" sign.

Source~
>
    ++  pat  (just '@')
<

Examples~
>
    > (scan "@" pat)
    '@'
<


------------------------------------------------------------------------------
SEL                                                                  *++sel*

Parse left square bracket

Parses ASCII character 91, the left square bracket.

Source~
>
    ++  sel  (just '[')
<

Examples~
>
    > (scan "[" sel)
    '['
<


------------------------------------------------------------------------------
SER                                                                  *++ser*

Parse right square bracket

Parses ASCII character 93, the right square bracket.

Source~
>
    ++  ser  (just ']')
<

Examples~
>
    > (scan "]" ser)
    ']'
<


------------------------------------------------------------------------------
SIG                                                                  *++sig*

Parse tilde

Parses ASCII character 126, the tilde.

Source~
>
    ++  sig  (just '~')
<

Examples~
>
    > (scan "~" sig)
    '~'
<


------------------------------------------------------------------------------
SOQ                                                                  *++soq*

Parse single quote

Parses ASCII character 39, soq. Note the `\` in the example is to escape the
soq because soq delimits a `cord`.

Source~
>
    ++  soq  (just '\'')
<

Examples~
>
    > (scan "'" soq)
    '\''
<


------------------------------------------------------------------------------
TAR                                                                  *++tar*

Parse asterisk

Parses ASCII character 42, the asterisk.

Source~
>
    ++  tar  (just '*')
<

Examples~
>
    > (scan "*" tar)
    '*'
<


------------------------------------------------------------------------------
TIC                                                                  *++tic*

Parse backtick

Parses ASCII character 96, the backtick.

Source~
>
    ++  tic  (just '`')
<

Examples~
>
    > (scan "`" tic)
    '`'
<


------------------------------------------------------------------------------
TIS                                                                  *++tis*

Parse equals sign

Parses ASCII character 61, the equals sign.

Source~
>
    ++  tis  (just '=')
<

Examples~
>
    > (scan "=" tis)
    '='
<


------------------------------------------------------------------------------
WUT                                                                  *++wut*

Parses question mark

Parses ASCII character 63, the question mark.

Source~
>
    ++  wut  (just '?')
<

Examples~
>
    > (scan "?" wut)
    '?'
<


------------------------------------------------------------------------------
ZAP                                                                  *++zap*

Exclamation point

Parses ASCII character 33, the exclamation point zap.

Source~
>
    ++  zap  (just '!')
<

Examples~
>
    > (scan "!" zap)
    '!'
<



==============================================================================
 4i: Parsing Useful Idioms                                                                         

------------------------------------------------------------------------------
ALF                                                                  *++alf*

Alphabetic characters

Parse alphabetic characters, both upper and lowercase.

Source~
>
    ++  alf  ;~(pose low hig)
<

Examples~
>
    > (scan "a" alf)
    'a'
    
    > (scan "A" alf)
    'A'
    
    > `tape`(scan "AaBbCc" (star alf))
    "AaBbCc"
<


------------------------------------------------------------------------------
ALN                                                                  *++aln*

Alphanumeric characters

Parse alphanumeric characters - both alphabetic characters and numbers.

Source~
>
    ++  aln  ;~(pose low hig nud)
<

Examples~
>
    > (scan "0" aln)
    '0'
    
    > `tape`(scan "alf42" (star aln))
    "alf42"
<


------------------------------------------------------------------------------
ALP                                                                  *++alp*

Alphanumeric and `-`

Parse alphanumeric strings and hep, "-".

Source~
>
    ++  alp  ;~(pose low hig nud hep)
<

Examples~
>
    > (scan "7" alp)
    '7'
    
    > (scan "s" alp)
    's'
    
    > `tape`(scan "123abc-" (star alp))
    "123abc-"
<


------------------------------------------------------------------------------
BET                                                                  *++bet*

Axis syntax `-`, `+`

Parse the hep and lus axis syntax.

Source~
>
    ++  bet  ;~(pose (cold 2 hep) (cold 3 lus))
<

Examples~
>
    > (scan "-" bet)
    2
    
    > (scan "+" bet)
    3
<


------------------------------------------------------------------------------
BIN                                                                  *++bin*

Binary to atom

Parse a tape of binary (0s and 1s) and produce its atomic representation.

Source~
>
    ++  bin  (bass 2 (most gon but))
<

Examples~
>
    > (scan "0000" bin)
    0
    
    > (scan "0001" bin)
    1
    
    > (scan "0010" bin)
    2
    
    > (scan "100000001111" bin)
    2.063
<


------------------------------------------------------------------------------
BUT                                                                  *++but*

Binary digit

Parse a single binary digit.

Source~
>
    ++  but  (cook |=(a=@ (sub a '0')) (shim '0' '1'))
<

Examples~
>
    > (scan "0" but)
    0
    
    > (scan "1" but)
    1
    
    > (scan "01" but)
    ! {1 2}
    ! 'syntax-error'
    ! exit
    
    > (scan "01" (star but))
    ~[0 1]
<


------------------------------------------------------------------------------
CIT                                                                  *++cit*

Octal digit

Parse a single octal digit.

Source~
>
    ++  cit  (cook |=(a=@ (sub a '0')) (shim '0' '7'))
<

Examples~
>
    > (scan "1" cit)
    1
    > (scan "7" cit)
    7
    > (scan "8" cit)
    ! {1 1}
    ! 'syntax-error'
    ! exit
    > (scan "60" (star cit))
    ~[6 0]
<


------------------------------------------------------------------------------
DEM                                                                  *++dem*

Decimal to atom

Parse a decimal number to an atom.

Source~
>
    ++  dem  (bass 10 (most gon dit))
<

Examples~
>
    > (scan "7" dem)
    7
    
    > (scan "42" dem)
    42
    
    > (scan "150000000" dem)
    150.000.000
    
    > (scan "12456" dem)
    12.456
<


------------------------------------------------------------------------------
DIT                                                                  *++dit*

Decimal digit

Parse a single decimal digit.

Source~
>
    ++  dit  (cook |=(a=@ (sub a '0')) (shim '0' '9'))
<

Examples~
>
    > (scan "7" dit)
    7
    
    > (scan "42" (star dit))
    ~[4 2]
    
    > (scan "26000" (star dit))
    ~[2 6 0 0 0]
<


------------------------------------------------------------------------------
DOG                                                                  *++dog*

`.` optional gap

Dot followed by an optional gap, used with numbers.

Source~
>
    ++  dog  ;~(plug dot gay)
<

Examples~
>
    > (scan "." dog)
    ['.' ~]
    
    > (scan "a.        " ;~(pfix alf dog))
    ['.' ~]
<


------------------------------------------------------------------------------
DOF                                                                  *++dof*

`-` optional gap

Hep followed by an optional gap, used with `@p` & `@q` syntax.

Source~
>
    ++  dof  ;~(plug hep gay)
<

Examples~
>
    > (scan "-" dof)
    ['-' ~]
    
    > (scan "-     " dof)
    ['-' ~]
<


------------------------------------------------------------------------------
DOH                                                                  *++doh*

`@p` separator

Phonetic base phrase separator

Source~
>
    ++  doh  ;~(plug ;~(plug hep hep) gay)
<

Examples~
>
    > (scan "--" doh)
    [['-' '-'] ~]
    
    > (scan "--     " doh)
    [['-' '-'] ~]
<


------------------------------------------------------------------------------
DUN                                                                  *++dun*

`--` to `~`

Parse phep, `--`, to null, `~`.

Source~
>
    ++  dun  (cold ~ ;~(plug hep hep))
<

Examples~
>
    > (scan "--" dun)
    ~
<


------------------------------------------------------------------------------
DUZ                                                                  *++duz*

`==` to `~`

Parse stet, `==`, to null `~`.

Source~
>
    ++  duz  (cold ~ ;~(plug tis tis))
<

Examples~
>
    > (scan "==" duz)
    ~
<


------------------------------------------------------------------------------
GAH                                                                  *++gah*

Newline or ' '

Whitespace component, either newline or space.

Source~
>
    ++  gah  (mask [`@`10 ' ' ~])
<

Examples~
>
    > `tape`(scan " \0a \0a" (star gah))
    " \0a \0a"
<


------------------------------------------------------------------------------
GAP                                                                  *++gap*

Plural whitespace

Separates tall runes

Source~
>
    ++  gap  (cold ~ ;~(plug gaq (star ;~(pose vul gah))))
<

Examples~
>
    > `tape`(scan " \0a \0a" gap)
    ""
    
    > (scan "\0a   \0a XYZ" ;~(pfix gap (jest 'XYZ')))
    'XYZ'
<


------------------------------------------------------------------------------
GAQ                                                                  *++gaq*

End of line

Two spaces, a newline, or comment.

Source~
>
    ++  gaq  ;~  pose
                 (just `@`10)
                 ;~(plug gah ;~(pose gah vul))
                 vul
             ==
<

Examples~
>
    > (scan "123\0a" ;~(sfix dem gaq))
    123
    
    > (scan "123 :: foo\0a" ;~(sfix dem gaq))
    123
<


------------------------------------------------------------------------------
GAW                                                                  *++gaw*

Classic whitespace

Terran whitespace.

Source~
>
    ++  gaw  (cold ~ (star ;~(pose vul gah)))
<

Examples~
>
    > (scan "  \0a  :: foo  \0a" gaw)
    ~
    
    > (scan "  " gaw)
    ~
    
    > (scan "\0a" gaw)
    ~
<


------------------------------------------------------------------------------
GAY                                                                  *++gay*

Optional gap

Optional gap.

Source~
>
    ++  gay  ;~(pose gap (easy ~))
<

Examples~
>
    > (scan "  " gay)
    ~
    
    > (scan "     " gay)
    ~
    
    > (scan "\0a" gay)
    ~
    
    > (scan "" gay)
    ~
<


------------------------------------------------------------------------------
GON                                                                  *++gon*

Long numbers

Parse long numbers - Numbers which wrap around the shell with the line

Source~
>
    ++  gon  ;~(pose ;~(plug bas gay fas) (easy ~))
<

Examples~
>
    > 'abc\
      /def'
    'abcdef'
    
    > (scan "\\\0a/" gon)
    ['\\' ~ '/']
<


------------------------------------------------------------------------------
GUL                                                                  *++gul*

Axis syntax `<` or `>`

Parse the axis gal and gar axis syntax.

Source~
>
    ++  gul  ;~(pose (cold 2 gal) (cold 3 gar))
<

Examples~
>
    > (scan "<" gul)
    2
    
    > (scan ">" gul)
    3
<


------------------------------------------------------------------------------
HEX                                                                  *++hex*

Hex to atom

Parse any hexadecimal number to an atom.

Source~
>
    ++  hex  (bass 16 (most gon hit))
<

Examples~
>
    > (scan "a" hex)
    10
    
    > (scan "A" hex)
    10
    
    > (scan "2A" hex)
    42
    
    > (scan "1ee7" hex)
    7.911
    
    > (scan "1EE7" hex)
    7.911
    
    > (scan "1EE7F7" hex)
    2.025.463
    
    > `@ux`(scan "1EE7F7" hex)
    0x1e.e7f7
<


------------------------------------------------------------------------------
HIG                                                                  *++hig*

Uppercase

Parse a single uppercase letter.

Source~
>
    ++  hig  (shim 'A' 'Z')
<

Examples~
>
    > (scan "G" hig)
    'G'
    
    > (scan "ABCDEFGHIJKLMNOPQRSTUVWXYZ" (star hig))
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
<


------------------------------------------------------------------------------
HIT                                                                  *++hit*

Hex digits

Parse a single hexadecimal digit.

Source~
>
    ++  hit  ;~  pose
               dit
               (cook |=(a=char (sub a 87)) (shim 'a' 'f'))
               (cook |=(a=char (sub a 55)) (shim 'A' 'F'))
             ==
<

Examples~
>
    > (scan "a" hit)
    10
    
    > (scan "A" hit)
    10
    
    > (scan "2A" (star hit))
    ~[2 10]
<


------------------------------------------------------------------------------
INY                                                                  *++iny*

Indentation block

Apply `rule` to indented block starting at current column number, omitting the
leading whitespace.

Accepts~

`sef` is a `rule`

Produces~

A `rule`.

Source~
>
    ++  iny
      |*  sef=rule
      |=  nail  ^+  (sef)
      =+  [har tap]=[p q]:+<
      =+  lev=(fil 3 (dec q.har) ' ')
      =+  eol=(just `@t`10)
      =+  =-  roq=((star ;~(pose prn ;~(sfix eol (jest lev)) -)) har tap)
          ;~(simu ;~(plug eol eol) eol)
      ?~  q.roq  roq
      =+  vex=(sef har(q 1) p.u.q.roq)
      =+  fur=p.vex(q (add (dec q.har) q.p.vex))
      ?~  q.vex  vex(p fur)
      =-  vex(p fur, u.q -)
      :+  &3.vex
        &4.vex(q.p (add (dec q.har) q.p.&4.vex))
      =+  res=|4.vex
      |-  ?~  res  |4.roq
      ?.  =(10 -.res)  [-.res $(res +.res)]
      (welp [`@t`10 (trip lev)] $(res +.res))
<

Examples~
>
    > `tape`(scan "   foo\0a   bar" ;~(pfix ace ace ace (iny (star ;~(pose prn (just '\0a'))))))
    "foo\0abar"
<

Discussion~

Note the amount of indentation whitespace to be stripped from the beginning of
each line is determined by the value of `q` (the column) in the `hair` when
`++iny` is first called. This means something like the `pfix` expression in
the example above is necessary to set the level of indentation. Additionally,
the `rule` given to `++iny` must consume the whole line including the line
ending.


------------------------------------------------------------------------------
LOW                                                                  *++low*

Lowercase

Parse a single lowercase letter.

Source~
>
    ++  low  (shim 'a' 'z')
<

Examples~
>
    > (scan "g" low)
    'g'
<


------------------------------------------------------------------------------
MES                                                                  *++mes*

Hexbyte

Parse a hexbyte.

Source~
>
    ++  mes  %+  cook
               |=({a/@ b/@} (add (mul 16 a) b))
             ;~(plug hit hit)
<

Examples~
>
    > (scan "2A" mes)
    42
    
    > (scan "42" mes)
    66
<


------------------------------------------------------------------------------
NIX                                                                  *++nix*

Letters and underscore

Parse Letters and `_`.

Source~
>
    ++  nix  (boss 256 (star ;~(pose aln cab)))
<

Examples~
>
    > `@t`(scan "as_me" nix)
    'as_me'
<


------------------------------------------------------------------------------
NUD                                                                  *++nud*

Numeric

Parse a numeric character - A number.

Source~
>
    ++  nud  (shim '0' '9')
<

Examples~
>
    > (scan "0" nud)
    '0'
    
    > (scan "7" nud)
    '7'
<


------------------------------------------------------------------------------
PRN                                                                  *++prn*

Printable character

Parse any printable character.

Source~
>
    ++  prn  ;~(less (just `@`127) (shim 32 256))
<

Examples~
>
    > (scan "h" prn)
    'h'
    
    > (scan "!" prn)
    '!'
    
    > (scan "\01" prn)
    ! {1 1}
    ! exit
<


------------------------------------------------------------------------------
QAT                                                                  *++qat*

Chars in blockcord

Parse a single character contained in a mult-line cord block.

Source~
>
    ++  qat  ;~  pose
                 prn
                 ;~(less ;~(plug (just `@`10) soz) (just `@`10))
             ==
<

Examples~
>
    > ^-  tape
      %+  scan
        "'''\0aabc\0adef\0aghi\0a'''"
      %+  ifix
        :-  ;~(plug soz (just `@`10))
        ;~(plug (just `@`10) soz)
      (star qat)
    "abc\0adef\0aghi"
<


------------------------------------------------------------------------------
QIT                                                                  *++qit*

Chars in cord

Parse an individual character to its cord atom representation. Escaped
characters are converted to the value they represent.

Source~
>
    ++  qit  ;~  pose                                       ::  chars in a cord
                 ;~(less bas soq prn)
                 ;~(pfix bas ;~(pose bas soq mes))          ::  escape chars
             ==
<

Examples~
>
    > (scan "%" qit)
    '%'
    
    > `tape`(scan "cord" (star qit))
    "cord"
    
    > `tape`(scan "\\0a" (star qit))
    "\0a"
<


------------------------------------------------------------------------------
QUT                                                                  *++qut*

Cord

Parse single-soq cord with `\{gap}/` anywhere in the middle, or triple-single
quote (aka triple-soq) cord, between which must be in an indented block.

Source~
>
    ++  qut  ;~  simu  soq
               ;~  pose
                 ;~  less  soz
                   (ifix [soq soq] (boss 256 (more gon qit)))
                 ==
                 =+  hed=;~(pose ;~(plug (plus ace) vul) (just '\0a'))
                 %-  iny  %+  ifix
                   :-  ;~(plug soz hed)
                   ;~(plug (just '\0a') soz)
                 (boss 256 (star qat))
               ==
             ==
<

Examples~
>
    > `@t`(scan "'cord'" qut)
    'cord'
    
    > `@t`(scan "'''\0aabc\0adef\0a'''" qut)
    'abc\0adef'
<


------------------------------------------------------------------------------
SOZ                                                                  *++soz*

Delimiting `'''`

Parse a triple-single quote, used for multiline strings.

Source~
>
    ++  soz  ;~(plug soq soq soq)
<

Examples~
>
    > (scan "'''" soz)
    ['\'' '\'' '\'']
<


------------------------------------------------------------------------------
SYM                                                                  *++sym*

Term

A term: a lowercase letter, followed by letters, numbers, or `-`.

Source~
>
    ++  sym
      %+  cook
        |=(a=tape (rap 3 ^-((list @) a)))
      ;~(plug low (star ;~(pose nud low hep)))
<

Examples~
>
    > `term`(scan "sam-2" sym)
    %sam-2
<


------------------------------------------------------------------------------
MIXED-CASE-SYMBOL                                                                  *++mixed-case-symbol*

Mixed-case term

The same as `++sym` but allowing uppercase letters.

Source~
>
    ++  mixed-case-symbol
      %+  cook
        |=(a=tape (rap 3 ^-((list @) a)))
      ;~(plug alf (star alp))
<

Examples~
>
    > `term`(scan "sAm-2" mixed-case-symbol)
    %sAm-2
<


------------------------------------------------------------------------------
VEN                                                                  *++ven*

`+>-` axis syntax

Axis syntax parser

Source~
>
    ++  ven  ;~  (comp |=([a=@ b=@] (peg a b)))
               bet
               =+  hom=`?`|
               |=  tub=nail
               ^-  (like @)
               =+  vex=?:(hom (bet tub) (gul tub))
               ?~  q.vex
                 [p.tub [~ 1 tub]]
               =+  wag=$(p.tub p.vex, hom !hom, tub q.u.q.vex)
               ?>  ?=(^ q.wag)
               [p.wag [~ (peg p.u.q.vex p.u.q.wag) q.u.q.wag]]
             ==
<

Examples~
>
    > (scan "->+" ven)
    11
    
    > (scan "->+<-" ven)
    44
<


------------------------------------------------------------------------------
VIT                                                                  *++vit*

Base64 digit

Parse a standard base64 digit.

Source~
>
    ++  vit
      ;~  pose
        (cook |=(a=@ (sub a 65)) (shim 'A' 'Z'))
        (cook |=(a=@ (sub a 71)) (shim 'a' 'z'))
        (cook |=(a=@ (add a 4)) (shim '0' '9'))
        (cold 62 (just '-'))
        (cold 63 (just '+'))
      ==
<

Examples~
>
    > (scan "C" vit)
    2
    
    > (scan "c" vit)
    28
    
    > (scan "2" vit)
    54
    
    > (scan "-" vit)
    62
<


------------------------------------------------------------------------------
VUL                                                                  *++vul*

Comments to null

Parse comments and produce a null. Note that a comment must be ended with a
newline character.

Source~
>
    ++  vul  %+  cold   ~
             ;~  plug  col  col
               (star prn)
               (just `@`10)
             ==
<

Examples~
>
    > (scan "::this is a comment \0a" vul)
    ~
    
    > (scan "::this is a comment " vul)
    ! {1 21}
    ! exit
<



==============================================================================
 4j: Parsing Bases and Base Digits                                                                         

------------------------------------------------------------------------------
AB                                                                  *++ab*

Primitive parser engine

A core containing numeric parser primitives.

Source~
>
    ++  ab
      |%
<

Examples~
>
    > ab
    <36.ecc 414.gly 100.xkc 1.ypj %164>
<


`++bix:ab`~

Parse hex pair

Parsing `rule`. Parses a pair of base-16 digits. Used in escapes.

Source~
>
    ++  bix  (bass 16 (stun [2 2] six))
<

Examples~
>
    > (scan "07" bix:ab)
    7
    > (scan "51" bix:ab)
    81
    > (scan "a3" bix:ab)
    163
<


`++fem:ab`~

Parse base58check char

Parse a single base58check character.

Source~
>
    ++  fem  (sear |=(a=@ (cha:fa a)) aln)
<

Examples~
>
    > (scan "6" fem:ab)
    5
    
    > (scan "Z" fem:ab)
    32
    
    > (scan "j" fem:ab)
    42
<


`++haf:ab`~

Parse non-doz phonetic pair

Parsing `rule`. Parses an atom of aura `@pE`, a phrase of two bytes encoded
phonetically. If the leading syllable is `doz` (`0`), parsing will fail.

Source~
>
    ++  haf  (bass 256 ;~(plug tep tiq (easy ~)))
<

Examples~
>
    > `@p`(scan "sampel" haf:ab)
    ~sampel
    
    > `@p`(scan "dozpel" haf:ab)
    {1 4}
    syntax error
<


`++hef:ab`~

Parse non-dozzod phonetic pair

Parsing `rule`. Parses an atom of aura `@pE` without leading `~` or `.~`, a
phrase of two bytes encoded phonetically. If it's `dozzod`, parsing will fail.

Source~
>
    ++  hef  %+  sear  |=(a=@ ?:(=(a 0) ~ (some a)))
             %+  bass  256
             ;~(plug tip tiq (easy ~))
<

Examples~
>
    > `@p`(scan "sampel" hef:ab)
    ~sampel
    
    > `@p`(scan "dozpel" hef:ab)
    ~pel
    
    > `@p`(scan "dozzod" hef:ab)
    {1 7}
    syntax error
<


`++hif:ab`~

Parse phonetic pair

Parsing `rule`. Parses an atom of aura `@pE`, without leading `~` or `.~`. A
phrase of two bytes encoded phonetically.

Source~
>
    ++  hif  (boss 256 ;~(plug tip tiq (easy ~)))
<

Examples~
>
    > `@p`(scan "doznec" hif:ab)
    ~nec
    
    > `@p`(scan "pittyp" hif:ab)
    ~pittyp
<


`++hof:ab`~

Parse 2-4 @q phonetic pairs

Parsing `rule`. Parses an atom of aura `@q` (non-scrambled `@p`), without
leading `~` or `.~`, of between two and four phrases.

Source~
>
    ++  hof  (bass 0x1.0000 ;~(plug hef (stun [1 3] ;~(pfix hep hif))))
<

Example~
>
    > `@q`(scan "sampel-palnet" hof:ab)
    .~sampel-palnet
    
    > `@q`(scan "sampel-sampel-palnet" hof:ab)
    .~sampel-sampel-palnet
    
    > `@q`(scan "sampel-sampel-sampel-palnet" hof:ab)
    .~sampel-sampel-sampel-palnet
<


`++huf:ab`~

Parse 1-4 @q phonetic pairs

Parsing `rule`. Parses an atom of aura `@q` (non-scrambled `@p`), without
leading `~` or `.~`, of between one and four phrases.

Source~
>
    ++  huf  (bass 0x1.0000 ;~(plug hef (stun [0 3] ;~(pfix hep hif))))
<

Examples~
>
    > `@q`(scan "sampel" huf:ab)
    .~sampel
    
    > `@q`(scan "sampel-palnet" huf:ab)
    .~sampel-palnet
    
    > `@q`(scan "sampel-sampel-palnet" huf:ab)
    .~sampel-sampel-palnet
    
    > `@q`(scan "sampel-sampel-sampel-palnet" huf:ab)
    .~sampel-sampel-sampel-palnet
<


`++hyf:ab`~

Parse four @q phonetic pairs

Parsing `rule`. Parses an atom of aura `@q` (non-scrambled `@p`), without
leading `~` or `.~`, of exactly four phrases.

Source~
>
    ++  hyf  (bass 0x1.0000 ;~(plug hif (stun [3 3] ;~(pfix hep hif))))
<

Examples~
>
    > `@q`(scan "sampel-sampel-sampel-palnet" hyf:ab)
    .~sampel-sampel-sampel-palnet
<


`++pev:ab`~

Parse 1-5 @uv base-32 chars

Parsing `rule`. Parses one to five `@uv` base-32 digits without the leading
`0v` or leading zeros.

Source~
>
    ++  pev  (bass 32 ;~(plug sev (stun [0 4] siv)))
<

Examples~
>
    > `@uv`(scan "du3ja" pev:ab)
    0vdu3ja
    
    > `@uv`(scan "3ja" pev:ab)
    0v3ja
    
    > `@uv`(scan "a" pev:ab)
    0va
<


`++pew:ab`~

Parse 1-5 @uw base-64 chars

Parsing `rule`. Parses one to five `@uw` base-64 digits without the leading
`0w` or leading zeros.

Source~
>
    ++  pew  (bass 64 ;~(plug sew (stun [0 4] siw)))
<

Examples~
>
    > `@uw`(scan "6U0gP" pew:ab)
    0w6U0gP
    
    > `@uw`(scan "gP" pew:ab)
    0wgP
    
    > `@uw`(scan "P" pew:ab)
    0wP
<


`++piv:ab`~

Parse 5 @uv base-32 chars

Parsing `rule`. Parses exactly five `@uv` base-32 digits without the leading
`0v` or leading zeros.

Source~
>
    ++  piv  (bass 32 (stun [5 5] siv))
<

Examples~
>
    > `@uv`(scan "du3ja" piv:ab)
    0vdu3ja
    
    > `@uv`(scan "u3ja" piv:ab)
    {1 5}
    syntax error
<


`++piw:ab`~

Parse 5 @uw base-64 chars

Parsing `rule`. Parses exactly five `@uw` base-64 digits without the leading
`0w` or leading zeros.

Source~
>
    ++  piw  (bass 64 (stun [5 5] siw))
<

Examples~
>
    > `@uw`(scan "6U0gP" piw:ab)
    0w6U0gP
    
    > `@uw`(scan "U0gP" piw:ab)
    {1 5}
    syntax error
<


`++qeb:ab`~

Parse 1-4 binary digits

Parsing `rule`. Parses a binary number of up to 4 digits in length without a
leading zero.

Source~
>
    ++  qeb  (bass 2 ;~(plug seb (stun [0 3] sib)))
<

Examples~
>
    > `@ub`(scan "1010" qeb:ab)
    0b1010
    
    > `@ub`(scan "10" qeb:ab)
    0b10
    
    > `@ub`(scan "1" qeb:ab)
    0b1
    
    > `@ub`(scan "0" qeb:ab)
    {1 1}
    syntax error
<


`++qex:ab`~

Parse 1-4 hex digits

Parsing `rule`. Parses a hexadecimal number of up to 4 digits in length
without a leading zero.

Source~
>
    ++  qex  (bass 16 ;~(plug sex (stun [0 3] hit)))
<

Examples~
>
    > `@ux`(scan "beef" qex:ab)
    0xbeef
    
    > `@ux`(scan "ef" qex:ab)
    0xef
    
    > `@ux`(scan "f" qex:ab)
    0xf
<


`++qib:ab`~

Parse 4 binary

Parsing `rule`. Parses exactly four binary digits - may have leading zeros.

Source~
>
    ++  qib  (bass 2 (stun [4 4] sib))
<

Examples~
>
    > `@ub`(scan "0001" qib:ab)
    0b1
    
    > `@ub`(scan "1001" qib:ab)
    0b1001
    
    > `@ub`(scan "1" qib:ab)
    {1 2}
    syntax error
<


`++qix:ab`~

Parse 4 hex

Parsing `rule`. Parses exactly four hexadecimal digits - may have leading
zeros.

Source~
>
    ++  qix  (bass 16 (stun [4 4] six))
<

Examples~
>
    > `@ux`(scan "beef" qix:ab)
    0xbeef
    
    > `@ux`(scan "0000" qix:ab)
    0x0
    
    > `@ux`(scan "ef" qix:ab)
    {1 3}
    syntax error
<


`++seb:ab`~

Parse 1

Parsing `rule`. Parses the number 1.

Source~
>
    ++  seb  (cold 1 (just '1'))
<

Examples~
>
    > (scan "1" seb:ab)
    1
    
    > (scan "2" seb:ab)
    {1 1}
    syntax error
<


`++sed:ab`~

Parse decimal

Parsing `rule`. Parses a nonzero decimal digit.

Source~
>
    ++  sed  (cook |=(a=@ (sub a '0')) (shim '1' '9'))
<

Examples~
>
    > (scan "5" sed:ab)
    5
    
    > (scan "0" sed:ab)
    {1 1}
    syntax error
<


`++sev:ab`~

Parse base-32

Parsing `rule`. Parses a nonzero base-32 digit.

Source~
>
    ++  sev  ;~(pose sed sov)
<

Examples~
>
    > `@uv`(scan "2" sev:ab)
    0v2
    
    > `@uv`(scan "j" sev:ab)
    0vj
    
    > `@uv`(scan "0" sev:ab)
    {1 1}
    syntax error
<


`++sew:ab`~

Parse base-64

Parsing `rule`. Parses a nonzero base-64 digit.

Source~
>
    ++  sew  ;~(pose sed sow)
<

Examples~
>
    > `@uw`(scan "I" sew:ab)
    0wI
    
    > `@uw`(scan "2" sew:ab)
    0w2
    
    > `@uw`(scan "0" sew:ab)
    {1 1}
    syntax error
<


`++sex:ab`~

Parse hex

Parsing `rule`. Parses a non-zero hexadecimal digit.

Source~
>
    ++  sex  ;~(pose sed sox)
<

Examples~
>
    > `@ux`(scan "a" sex:ab)
    0xa
    
    > `@ux`(scan "2" sex:ab)
    0x2
    
    > `@ux`(scan "0" sex:ab)
    {1 1}
    syntax error
<


`++sib:ab`~

Parse binary

Parsing `rule`. Parses a binary digit.

Source~
>
    ++  sib  (cook |=(a=@ (sub a '0')) (shim '0' '1'))
<

Examples~
>
    > `@ub`(scan "1" sib:ab)
    0b1
    
    > `@ub`(scan "0" sib:ab)
    0b0
<


`++sid:ab`~

Parse decimal

Parsing `rule`. Parses a decimal digit.

Source~
>
    ++  sid  (cook |=(a=@ (sub a '0')) (shim '0' '9'))
<

Examples~
>
    > (scan "5" sid:ab)
    5
    
    > (scan "0" sid:ab)
    0
<


`++siv:ab`~

Parse base-32

Parsing `rule`. Parses a base-32 digit.

Source~
>
    ++  siv  ;~(pose sid sov)
<

Examples~
>
    > `@uv`(scan "r" siv:ab)
    0vr
    
    > `@uv`(scan "5" siv:ab)
    0v5
    
    > `@uv`(scan "0" siv:ab)
    0v0
<


`++siw:ab`~

Parse base-64

Parsing `rule`. Parses a base-64 digit.

Source~
>
    ++  siw  ;~(pose sid sow)
<

Examples~
>
    > `@uw`(scan "M" siw:ab)
    0wM
    
    > `@uw`(scan "0" siw:ab)
    0w0
    
    > `@uw`(scan "c" siw:ab)
    0wc
<


`++six:ab`~

Parse hex

Parsing `rule`. Parses a hexadecimal digit.

Source~
>
    ++  six  ;~(pose sid sox)
<

Examples~
>
    > `@ux`(scan "e" six:ab)
    0xe
    
    > `@ux`(scan "0" six:ab)
    0x0
<


`++sov:ab`~

Parse @uv base-32 letter

Parsing `rule`. Parses a `@uv` base-32 letter (but not a number).

Source~
>
    ++  sov  (cook |=(a=@ (sub a 87)) (shim 'a' 'v'))
<

Examples~
>
    > `@uv`(scan "c" sov:ab)
    0vc
    
    > `@uv`(scan "j" sov:ab)
    0vj
    
    > `@uv`(scan "5" sov:ab)
    {1 1}
    syntax error
<


`++sow:ab`~

Parse @uw base-64 letter/symbol

Parsing `rule`. Parses a base-64 letter/symbol (but not number).

Source~
>
    ++  sow  ;~  pose
               (cook |=(a=@ (sub a 87)) (shim 'a' 'z'))
               (cook |=(a=@ (sub a 29)) (shim 'A' 'Z'))
               (cold 62 (just '-'))
               (cold 63 (just '~'))
             ==
<

Examples~
>
    > `@uw`(scan "M" sow:ab)
    0wM
    
    > `@uw`(scan "5" sow:ab)
    {1 1}
    syntax error
<


`++sox:ab`~

Parse hex letter

Parsing `rule`. Parses a hexadecimal letter (but not number).

Source~
>
    ++  sox  (cook |=(a=@ (sub a 87)) (shim 'a' 'f'))
<

Examples~
>
    > `@ux`(scan "e" sox:ab)
    0xe
    
    > `@ux`(scan "5" sox:ab)
    {1 1}
    syntax error
<


`++ted:ab`~

Parse 1-999 decimal

Parsing `rule`. Parses a decimal number of up to 3 digits without a leading
zero.

Source~
>
    ++  ted  (bass 10 ;~(plug sed (stun [0 2] sid)))
<

Examples~
>
    > (scan "214" ted:ab)
    214
    
    > (scan "2" ted:ab)
    2
    
    > (scan "2161" ted:ab)
    {1 4}
    syntax error
<


`++tep:ab`~

Parse non-doz leading phonetic byte

Parsing `rule`. Parses the leading phonetic byte , which represents a
syllable. Fails if it is `doz`.

Source~
>
    ++  tep  (sear |=(a=@ ?:(=(a 'doz') ~ (ins:po a))) til)
<

Examples~
>
    > (scan "sam" tep:ab)
    4
    
    > (scan "wic" tep:ab)
    99
<


`++tip:ab`~

Leading phonetic byte

Parsing `rule`. Parses the leading phonetic byte, which represents a syllable.

Source~
>
    ++  tip  (sear |=(a=@ (ins:po a)) til)
<

Examples~
>
    > (scan "doz" tip:ab)
    0
    
    > (scan "pit" tip:ab)
    242
<


`++tiq:ab`~

Trailing phonetic syllable

Parsing `rule`. Parses the trailing phonetic byte, which represents a
syllable.

Source~
>
    ++  tiq  (sear |=(a=@ (ind:po a)) til)
<

Examples~
>
    > (scan "zod" tiq:ab)
    0
    > (scan "nec" tiq:ab)
    1
<


`++tid:ab`~

Parse 3 decimal digits

Parsing `rule`. Parses exactly three decimal digits.

Source~
>
    ++  tid  (bass 10 (stun [3 3] sid))
<

Examples~
>
    > (scan "013" tid:ab)
    13
    
    > (scan "999" tid:ab)
    999
    
    > (scan "99" tid:ab)
    {1 3}
    syntax error
<


`++til:ab`~

Parse 3 lowercase

Parsing `rule`. Parses exactly three lowercase letters.

Source~
>
    ++  til  (boss 256 (stun [3 3] low))
<

Examples~
>
    > `@t`(scan "mer" til:ab)
    'mer'
    
    > `@t`(scan "me" til:ab)
    {1 3}
    syntax error
<


`++urs:ab`~

Parse knot characters

Parsing rule. Parses characters from an atom of the knot aura `@ta`.

Source~
>
    ++  urs  %+  cook
               |=(a=tape (rap 3 ^-((list @) a)))
             (star ;~(pose nud low hep dot sig cab))
<

Examples~
>
    > `@ta`(scan "asa-lom_tak" urs:ab)
    ~.asa-lom_tak
<


`++urt:ab`~

Parse knot without underscores

Parsing `rule`. Parses all characters of the knot aura `@ta` except for cab,
`_`.

Source~
>
    ++  urt  %+  cook
               |=(a=tape (rap 3 ^-((list @) a)))
             (star ;~(pose nud low hep dot sig))
<

Examples~
>
    > `@ta`(scan "asa-lom.t0k" urt:ab)
    ~.asa-lom.t0k
<


`++voy:ab`~

Parse bas, soq, or bix

Parsing `rule`. Parses an escaped backslash, single quote, or hex pair byte.

Source~
>
    ++  voy  ;~(pfix bas ;~(pose bas soq bix))
<

Examples~
>
    > (scan "\\\\" voy:ab)
    '\\'
    
    > (scan "\\'" voy:ab)
    '\''
    
    > (scan "\\0a" voy:ab)
    '\0a'
<


------------------------------------------------------------------------------
AG                                                                  *++ag*

Top-level atom parser engine

A core containing top-level atom parsers.

Source~
>
    ++  ag
      |%
<


`++ape:ag`~

Parse 0 or rule

Parser modifier. Parses 0 or the sample rule `fel`.

Accepts~

`fel` is a `rule`.

Produces~

A `rule`.

Source~
>
    ++  ape  |*(fel=rule ;~(pose (cold 0 (just '0')) fel))
<

Examples~
>
    > (scan "0" (ape:ag (cold 2 (just '2'))))
    0
    
    > (scan "2" (ape:ag (cold 2 (just '2'))))
    2
    
    > (scan "3" (ape:ag (cold 2 (just '2'))))
    {1 1}
    syntax error
<


`++bay:ag`~

Parses binary number

Parsing `rule`. Parses a binary number without a leading zero.

Source~
>
    ++  bay  (ape (bass 16 ;~(plug qeb:ab (star ;~(pfix dog qib:ab)))))
<

Examples~
>
    > `@ub`(scan "101.1100.0011.1010" bay:ag)
    0b101.1100.0011.1010
<


`++bip:ag`~

Parse IPv6

Parsing rule. Parses a `@is`, an IPv6 address.

Source~
>
    ++  bip  =+  tod=(ape qex:ab)
             (bass 0x1.0000 ;~(plug tod (stun [7 7] ;~(pfix dog tod))))
<

Examples~
>
    > `@is`(scan "0.0.ea.3e6c.0.0.0.0" bip:ag)
    .0.0.ea.3e6c.0.0.0.0
<


`++dem:ag`~

Parse decimal with dots

Parsing `rule`. Parses a decimal number that includes dot separators.

Source~
>
    ++  dem  (ape (bass 1.000 ;~(plug ted:ab (star ;~(pfix dog tid:ab)))))
<

Examples~
>
    > (scan "52" dem:ag)
    52
    > (scan "13.507" dem:ag)
    13.507
<


`++dim:ag`~

Parse decimal number

Parsing rule. Parses a decimal number without a leading zero.

Source~
>
    ++  dim  (ape dip)
<

Examples~
>
    > (scan "52" dim:ag)
    52
    
    > (scan "0" dim:ag)
    0
    
    > (scan "13507" dim:ag)
    13.507
    
    > (scan "013507" dim:ag)
    {1 2}
    syntax error
<


`++dum:ag`~

Parse decimal with leading `0`

Parsing rule. Parses a decmial number with leading zeroes.

Source~
>
    ++  dum  (bass 10 (plus sid:ab))
<

Examples~
>
    > (scan "52" dum:ag)
    52
    > (scan "0000052" dum:ag)
    52
    > (scan "13507" dim:ag)
    13.507
<


`++fed:ag`~

Parse phonetic base

Parsing rule. Parses an atom of aura `@p`, the phonetic base.

Source~
>
    ++  fed  %+  cook  fynd:ob
             ;~  pose
               %+  bass  0x1.0000.0000.0000.0000          ::  oversized
                 ;~  plug
                   huf:ab
                   (plus ;~(pfix doh hyf:ab))
                 ==
               hof:ab                                     ::  planet or moon
               haf:ab                                     ::  star
               tiq:ab                                     ::  galaxy
             ==
<

Examples~
>
    > `@p`(scan "zod" fed:ag)
    ~zod
    
    > `@p`(scan "sampel" fed:ag)
    ~sampel
    
    > `@p`(scan "sampel-palnet" fed:ag)
    ~sampel-palnet
    
    > `@p`(scan "sampel-palnet-sampel-palnet" fed:ag)
    ~sampel-palnet-sampel-palnet
    
    > `@p`(scan "tillyn-nillyt-tasfyn-partyv--novweb-talrud-talmud-sonfyr" fed:ag)
    ~tillyn-nillyt-tasfyn-partyv--novweb-talrud-talmud-sonfyr
<


`++feq:ag`~

Parse `@q` phonetic base

Parsing rule. Parses an atom of aura `@q` (an unscrambled `@p`).

Source~
>
    ++  feq  %+  cook  |=(a=(list @) (rep 4 (flop a)))
             ;~  plug
               ;~(pose hif:ab tiq:ab)
               (star ;~(pfix dof hif:ab))
             ==
<

Examples~
>
    > `@q`(scan "sampel" feq:ag)
    .~sampel
    
    > `@q`(scan "sampel-palnet" feq:ag)
    .~sampel-palnet
    
    > `@q`(scan "sampel-sampel-palnet" feq:ag)
    .~sampel-sampel-palnet
    
    > `@q`(scan "sampel-palnet-sampel-palnet" feq:ag)
    .~sampel-palnet-sampel-palnet
    
    > `@q`(scan "sampel-sampel-sampel-sampel-palnet-sampel-palnet" feq:ag)
    .~sampel-sampel-sampel-sampel-palnet-sampel-palnet
<


`++fim:ag`~

Parse base58check

Parse a base58check value, check checksum, and return decoded value sans-
checksum. If the checksum check fails, parsing will fail.

Source~
>
    ++  fim  (sear den:fa (bass 58 (plus fem:ab)))
<

Examples~

With valid checksum:
>
    > (enc:fa 0xdead.beef)
    0xdead.beef.938b.8b0c
    > (c-co:co 0xdead.beef.938b.8b0c)
    "eFGDJSVvRHd"
    > `@ux`(scan "eFGDJSVvRHd" fim:ag)
    0xdead.beef
<

With invalid checksum:
>
    > (c-co:co 0xdead.beef.ffff)
    "2utUWE41U"
    > `@ux`(scan "2utUWE41U" fim:ag)
    {1 10}
    syntax error
<


`++hex:ag`~

Parse hex

Parsing `rule`. Parses a hexadecimal number

Source~
>
    ++  hex  (ape (bass 0x1.0000 ;~(plug qex:ab (star ;~(pfix dog qix:ab)))))
<

Examples~
>
    > `@ux`(scan "4" hex:ag)
    0x4
    
    > `@ux`(scan "1a" hex:ag)
    0x1a
    
    > `@ux`(scan "3.ac8d" hex:ag)
    0x3.ac8d
<


`++lip:ag`~

Parse IPv4 address

Parsing `rule`. Parses an IPv4 address.

Source~
>
    ++  lip  =+  tod=(ape ted:ab)
             (bass 256 ;~(plug tod (stun [3 3] ;~(pfix dog tod))))
<

Examples~
>
    > `@if`(scan "127.0.0.1" lip:ag)
    .127.0.0.1
<


`++mot:ag`~

Parse numerical month

Parse a numerical month (1-12).

Source~
>
    ++  mot  ;~  pose
               ;~  pfix
                 (just '1')
                 (cook |=(a=@ (add 10 (sub a '0'))) (shim '0' '2'))
               ==
               sed:ab
             ==
<

Examples~
>
    > (scan "0" mot:ag)
    {1 1}
    syntax error
    
    > (scan "1" mot:ag)
    1
    
    > (scan "6" mot:ag)
    6
    
    > (scan "12" mot:ag)
    12
    
    > (scan "13" mot:ag)
    {1 2}
    syntax error
<


`++viz:ag`~

Parse Base-32 with dots

Parsing `rule`. Parses a Base-32 number with dot separators.

Source~
>
    ++  viz  (ape (bass 0x200.0000 ;~(plug pev:ab (star ;~(pfix dog piv:ab)))))
<

Examples~
>
    > `@uv`(scan "e2.ol4pm" viz:ag)
    0ve2.ol4pm
<


`++vum:ag`~

Parse base-32 string

Parsing `rule`. Parses a raw base-32 string (without dots).

Source~
>
    ++  vum  (bass 32 (plus siv:ab))
<

Examples~
>
    > `@uv`(scan "e2ol4pm" vum:ag)
    0ve2.ol4pm
<


`++wiz:ag`~

Parse base-64

Parsing `rule`. Parses a base-64 number.

Source~
>
    ++  wiz  (ape (bass 0x4000.0000 ;~(plug pew:ab (star ;~(pfix dog piw:ab)))))
<

Examples~
>
    > `@uw`(scan "e2O.l4Xpm" wiz:ag)
    0we2O.l4Xpm
<


------------------------------------------------------------------------------
MU                                                                  *++mu*

Core used to scramble 16-bit atoms

A door that contains arms that are used to scramble two atoms, `top` and
`bot`. Used especially in the phonetic base to disguise the relationship
between a planet and its star.

Accepts~

`top` is an atom.

`bot` is an atom.

Source~
>
    ++  mu
      |_  [top=@ bot=@]
<


`++zag:mu`~

Add bottom into top

Produces the cell of `top` and `bot` with `top` scrambled to the result of
adding `bot` to `top` modulo 16. Used to scramble the name of a planet.

Accepts~

`top` & `bot` are atoms, and are the sample of `+mu`.

Produces~

A `(pair @ @)`.

Source~
>
    ++  zag  [p=(end 4 (add top bot)) q=bot]
<

Examples~
>
    > `[@ux @ux]`~(zag mu 0x20e0 0x201)
    [0x22e1 0x201]
<


`++zig:mu`~

Subtract bottom from top

The inverse of `++zag`. Produces the cell of `top` and `bot` with `top`
unscrambled. The unscrambled `top` is the sum of the sample `top` and the
16-bit complement of `bot`. Used to unscramble the name of the planet.

Accepts~

`top` & `bot` are atoms, and are the sample of `+mu`.

Produces~

A `(pair @ @)`.

Source~
>
    ++  zig  [p=(end 4 (add top (sub 0x1.0000 bot))) q=bot]
<

Examples~
>
    > `[@ux @ux]`~(zig mu 0x22e1 0x201)
    [0x20e0 0x201]
<


`++zug:mu`~

Concatenate into atom

Produces the concatenation of `top` and `bot`. Used to assemble a planet name.

Accepts~

`top` & `bot` are atoms, and are the sample of `+mu`.

Produces~

An atom.

Source~
>
    ++  zug  (mix (lsh 4 top) bot)
<

Examples~
>
    > `@ux`~(zug mu 0x22e1 0x201)
    0x22e1.0201
<


------------------------------------------------------------------------------
NE                                                                  *++ne*

Digit rendering engine

A door containing arms that render digits at bases 10, 16, 32, and 64.

Accepts~

`tig` is an `atom`.

Source~
>
    ++  ne
      |_  tig=@
<


`++c:ne`~

Render base58check

Render a single base58check character.

Accepts~

`tig` is an `atom`, and is the sample of `+ne`.

Produces~

An atom.

Source~
>
    ++  c  (cut 3 [tig 1] key:fa)
<

Examples~
>
    > `@t`~(c ne 7)
    '8'
    
    > `@t`~(c ne 27)
    'U'
    
    > `@t`~(c ne 57)
    'z'
    
    > `@t`~(c ne 58)
    ''
<


`++d:ne`~

Render decimal

Renders a decimal digit as an atom of an ACII byte value.

Accepts~

`tig` is an `atom`, and is the sample of `+ne`.

Produces~

An atom.

Source~
>
    ++  d  (add tig '0')
<

Examples~
>
    > `@t`~(d ne 7)
    '7'
<


`++x:ne`~

Render hex

Renders a hexadecimal digit as an atom of an ASCII byte value.

Accepts~

`tig` is an `atom`, and is the sample of `+ne`.

Produces~

An atom.

Source~
>
    ++  x  ?:((gte tig 10) (add tig 87) d)
<

Examples~
>
    > `@t`~(x ne 7)
    '7'
    
    > `@t`~(x ne 14)
    'e'
<


`++v:ne`~

Render base-32

Renders a base-32 digit as an atom of an ASCII byte value.

Accepts~

`tig` is an `atom`, and is the sample of `+ne`.

Produces~

An atom.

Source~
>
    ++  v  ?:((gte tig 10) (add tig 87) d)
<

Examples~
>
    > `@t`~(v ne 7)
    '7'
    
    > `@t`~(v ne 14)
    'e'
    
    > `@t`~(v ne 25)
    'p'
<


`++w:ne`~

Render base-64

Renders a base-64 digit as an atom of an ASCII byte value.

Accepts~

`tig` is an `atom`, and is the sample of `+ne`.

Produces~

An atom.

Source~
>
    ++  w  ?:(=(tig 63) '~' ?:(=(tig 62) '-' ?:((gte tig 36) (add tig 29) x)))
<

Examples~
>
    > `@t`~(w ne 7)
    '7'
    
    > `@t`~(w ne 14)
    'e'
    
    > `@t`~(w ne 25)
    'p'
    
    > `@t`~(w ne 52)
    'Q'
    
    > `@t`~(w ne 61)
    'Z'
    
    > `@t`~(w ne 63)
    '~'
    
    > `@t`~(w ne 62)
    '-'
<



==============================================================================
 4k: Atom Printing                                                                         

------------------------------------------------------------------------------
CO                                                                  *++co*

Literal rendering engine

`++co` contains three parts:

- A door that contains arms that operate on the sample coin `lot`.
- A core of rendering idioms.
- A core of additional formatting functions used internally.


Accepts~

`lot` is a `coin`.

Source~

The arm begins with the door:
>
    ++  co
      !:
      ~%  %co  ..co  ~
      =<  |_  lot=coin
<

Then after that the rendering idiom core begins with:
>
    =|  rep=tape
    =<  |%
<

And finally the third core:
>
    |%
<


`++rear:co`~

Prepend & render as tape

Renders a coin `lot` as a tape prepended to the sample tape `rom`.

Accepts~

`lot` is a `coin`, and is the sample of `++co`.

`rom` is a `tape`.

Produces~

A `tape`.

Source~
>
    ++  rear  |=(rom=tape rend(rep rom))
<

Examples~
>
    > (~(rear co %$ %ux 200) "--ha")
    "0xc8--ha"
<


`++rent:co`~

Render as knot

Renders a coin `lot` as a `knot`.

Accepts~

`lot` is a `coin`, and is the sample of `++co`.

Produces~

A `knot`.

Source~
>
    ++  rent  ~+  `@ta`(rap 3 rend)
<

Examples~
>
    > ~(rent co %$ %ux 200)
    ~.0xc8
    
    > `@t`~(rent co %$ %ux 200)
    '0xc8'
<


`++rend:co`~

Render as tape

Renders a coin `lot` as a `tape`.

Accepts~

`lot` is a `coin`, and is the sample of `++co`.

Produces~

A `tape`.

Source~
>
    ++  rend
      ^-  tape
      ~+
      ?:  ?=(%blob -.lot)
        ['~' '0' ((v-co 1) (jam p.lot))]
      ?:  ?=(%many -.lot)
        :-  '.'
        |-  ^-  tape
        ?~   p.lot
          ['_' '_' rep]
        ['_' (weld (trip (wack rent(lot i.p.lot))) $(p.lot t.p.lot))]
      =+  [yed=(end 3 p.p.lot) hay=(cut 3 [1 1] p.p.lot)]
      |-  ^-  tape
      ?+    yed  (z-co q.p.lot)
          %c   ['~' '-' (weld (rip 3 (wood (tuft q.p.lot))) rep)]
          %d
        ?+    hay  (z-co q.p.lot)
            %a
          =+  yod=(yore q.p.lot)
          =?  rep  ?=(^ f.t.yod)  ['.' (s-co f.t.yod)]
          =?  rep  !&(?=(~ f) =(0 h) =(0 m) =(0 s)):t.yod
            =.  rep  ['.' (y-co s.t.yod)]
            =.  rep  ['.' (y-co m.t.yod)]
            ['.' '.' (y-co h.t.yod)]
          =.  rep  ['.' (a-co d.t.yod)]
          =.  rep  ['.' (a-co m.yod)]
          =?  rep  !a.yod  ['-' rep]
          ['~' (a-co y.yod)]
        ::
            %r
          =+  yug=(yell q.p.lot)
          =?  rep  ?=(^ f.yug)  ['.' (s-co f.yug)]
          :-  '~'
          ?:  &(=(0 d.yug) =(0 m.yug) =(0 h.yug) =(0 s.yug))
            ['s' '0' rep]
          =?  rep  !=(0 s.yug)  ['.' 's' (a-co s.yug)]
          =?  rep  !=(0 m.yug)  ['.' 'm' (a-co m.yug)]
          =?  rep  !=(0 h.yug)  ['.' 'h' (a-co h.yug)]
          =?  rep  !=(0 d.yug)  ['.' 'd' (a-co d.yug)]
          +.rep
        ==
      ::
          %f
        ?:  =(& q.p.lot)
          ['.' 'y' rep]
        ?:(=(| q.p.lot) ['.' 'n' rep] (z-co q.p.lot))
      ::
          %n   ['~' rep]
          %i
        ?+  hay  (z-co q.p.lot)
          %f  ((ro-co [3 10 4] |=(a=@ ~(d ne a))) q.p.lot)
          %s  ((ro-co [4 16 8] |=(a=@ ~(x ne a))) q.p.lot)
        ==
      ::
          %p
        =+  sxz=(fein:ob q.p.lot)
        =+  dyx=(met 3 sxz)
        :-  '~'
        ?:  (lte dyx 1)
          (weld (trip (tod:po sxz)) rep)
        =+  dyy=(met 4 sxz)
        =|  imp=@ud
        |-  ^-  tape
        ?:  =(imp dyy)
          rep
        %=  $
          imp  +(imp)
          rep  =/  log  (cut 4 [imp 1] sxz)
               ;:  weld
                 (trip (tos:po (rsh 3 log)))
                 (trip (tod:po (end 3 log)))
                 ?:(=((mod imp 4) 0) ?:(=(imp 0) "" "--") "-")
                 rep
        ==     ==
      ::
          %q
        :+  '.'  '~'
        =;  res=(pair ? tape)
          (weld q.res rep)
        %+  roll
          =*  val  q.p.lot
          ?:(=(0 val) ~[0] (rip 3 val))
        |=  [q=@ s=? r=tape]
        :-  !s
        %+  weld
         (trip (?:(s tod:po tos:po) q))
        ?.(&(s !=(r "")) r ['-' r])
      ::
          %r
        ?+  hay  (z-co q.p.lot)
          %d  ['.' '~' (r-co (rlyd q.p.lot))]
          %h  ['.' '~' '~' (r-co (rlyh q.p.lot))]
          %q  ['.' '~' '~' '~' (r-co (rlyq q.p.lot))]
          %s  ['.' (r-co (rlys q.p.lot))]
        ==
      ::
          %u
        ?:  ?=(%c hay)
          %+  welp  ['0' 'c' (reap (pad:fa q.p.lot) '1')]
          (c-co (enc:fa q.p.lot))
        ::
        =;  gam=(pair tape tape)
          (weld p.gam ?:(=(0 q.p.lot) `tape`['0' ~] q.gam))
        ?+  hay  [~ ((ox-co [10 3] |=(a=@ ~(d ne a))) q.p.lot)]
          %b  [['0' 'b' ~] ((ox-co [2 4] |=(a=@ ~(d ne a))) q.p.lot)]
          %i  [['0' 'i' ~] ((d-co 1) q.p.lot)]
          %x  [['0' 'x' ~] ((ox-co [16 4] |=(a=@ ~(x ne a))) q.p.lot)]
          %v  [['0' 'v' ~] ((ox-co [32 5] |=(a=@ ~(x ne a))) q.p.lot)]
          %w  [['0' 'w' ~] ((ox-co [64 5] |=(a=@ ~(w ne a))) q.p.lot)]
        ==
      ::
          %s
        %+  weld
          ?:((syn:si q.p.lot) "--" "-")
        $(yed 'u', q.p.lot (abs:si q.p.lot))
      ::
          %t
        ?:  =('a' hay)
          ?:  =('s' (cut 3 [2 1] p.p.lot))
            (weld (rip 3 q.p.lot) rep)
          ['~' '.' (weld (rip 3 q.p.lot) rep)]
        ['~' '~' (weld (rip 3 (wood q.p.lot)) rep)]
      ==
<

Examples~
>
    > ~(rend co %$ %ux 200)
    "0xc8"
    
    > ~(rend co %many ~[[%$ ux+200] [%$ p+40]])
    "._0xc8_~~tem__"
    
    > ~(rend co %$ %p 32.819)
    "~lasmev"
    
    > ~(rend co %$ %ux 18)
    "0x12"
    
    > ~(rend co [%$ p=[p=%if q=0x7f00.0001]])
    ".127.0.0.1"
    
    > ~(rend co %many ~[[%$ %ud 20] [%$ %uw 133] [%$ %tas 'sam']])
    "._20_0w25_sam__"
    
    > ~(rend co %blob [1 1])
    "~0ph"
<


`++a-co:co`~

Render decimal

Render `dat` as a decimal integer without separators.

Accepts~

`dat` is an atom.

Produces~

A `tape`

Source~
>
    ++  a-co  |=(dat=@ ((d-co 1) dat))
<

Examples~
>
    > (a-co:co 123.456.789)
    "123456789"
<


`++c-co:co`~

Render base58check

Renders the given `atom` as a base58check `tape`.

Accepts~

An `atom`.

Produces~

A `tape`.

Source~
>
    ++  c-co  (em-co [58 1] |=([? b=@ c=tape] [~(c ne b) c]))
<

Examples~
>
    > (enc:fa 0xdead.beef)
    0xdead.beef.938b.8b0c
    
    > (c-co:co 0xdead.beef.938b.8b0c)
    "eFGDJSVvRHd"
<


`++d-co:co`~

Render decimal with min length

Render `hol` as a decimal integer without separators and with a minimum length
of `min`. If `hol` has less than `min` digits, leading zeros will be added to
make up the difference.

Accepts~

`min` is an atom.

`hol` is an atom.

Produces~

A `tape`.

Source~
>
    ++  d-co  |=(min=@ (em-co [10 min] |=([? b=@ c=tape] [~(d ne b) c])))
<

Examples~
>
    > ((d-co:co 1) 123.456)
    "123456"
    
    > ((d-co:co 9) 123.456)
    "000123456"
<


`++r-co:co`~

Render floating point

Render decimal float `a` as a `tape`.

Accepts~

`a` is a `++dn`.

Produces~

A `tape`.

Source~
>
    ++  r-co
      |=  a=dn
      ?:  ?=([%i *] a)  (weld ?:(s.a "inf" "-inf") rep)
      ?:  ?=([%n *] a)  (weld "nan" rep)
      =;  rep  ?:(s.a rep ['-' rep])
      =/  f  ((d-co 1) a.a)
      =^  e  e.a
        =/  e=@s  (sun:si (lent f))
        =/  sci  :(sum:si e.a e -1)
        ?:  (syn:si (dif:si e.a --3))  [--1 sci]  :: 12000 -> 12e3 e>+2
        ?:  !(syn:si (dif:si sci -2))  [--1 sci]  :: 0.001 -> 1e-3 e<-2
        [(sum:si sci --1) --0] :: 1.234e2 -> '.'@3 -> 123 .4
      =?  rep  !=(--0 e.a)
        :(weld ?:((syn:si e.a) "e" "e-") ((d-co 1) (abs:si e.a)))
      (weld (ed-co e f) rep)
<

Examples~
>
    > `tape`(r-co:co (rlys .3.14))
    "3.14"
    
    > `tape`(r-co:co (rlys .1.681557e-39))
    "1.681557e-39"
<


`++s-co:co`~

Render hex list

Render `esc`, a list of atoms, as hex with a dot before each value. Values
less than two bytes in length will be padded with zeros.

Accepts~

`esc` is a `(list @)`.

Produces~

A `tape`.

Source~
>
    ++  s-co
      |=  esc=(list @)  ^-  tape
      ?~  esc  rep
      ['.' =>(.(rep $(esc t.esc)) ((x-co 4) i.esc))]
<

Examples~
>
    > `tape`(s-co:co ~[0xdead 0xbeef 0xcafe])
    ".dead.beef.cafe"
    
    > `tape`(s-co:co ~[0xa 0xb 0xc])
    ".000a.000b.000c"
    
    > `tape`(s-co:co ~[0xdead.beef])
    ".deadbeef"
<


`++v-co:co`~

Render base-32 with minimum length

Render `hol` as base-32 with a minimum length of `min`. If `hol` is shorter
than `min` it will be padded with zeros.

Accepts~

`min` is a `@ud`.

`hol` is an atom.

Produces~

A `tape`.

Source~
>
    ++  v-co  |=(min=@ (em-co [32 min] |=([? b=@ c=tape] [~(v ne b) c])))
<

Examples~
>
    > `tape`((v-co:co 1) 0v2l7.eiug3.0mbd9)
    "2l7eiug30mbd9"
    
    > `tape`((v-co:co 20) 0v2l7.eiug3.0mbd9)
    "00000002l7eiug30mbd9"
<


`++w-co:co`~

Render base-64 with minimum length

Render `hol` as base-64 with a minimum length of `min`. If `hol` is horter
than `min` it will be padded with zeros.

Accepts~

`min` is a `@ud`.

`hol` is an atom.

Produces~

A `tape`.

Source~
>
    ++  w-co  |=(min=@ (em-co [64 min] |=([? b=@ c=tape] [~(w ne b) c])))
<

Examples~
>
    > `tape`((w-co:co 1) 0w2.OtBSR.pPVeT)
    "2OtBSRpPVeT"
    
    > `tape`((w-co:co 20) 0w2.OtBSR.pPVeT)
    "0000000002OtBSRpPVeT"
<


`++x-co:co`~

Render hex with minimum length

Render `hol` as hex with a minimum length of `min`. If `hol` is horter than
`min` it will be padded with zeros.

Accepts~

`min` is a `@ud`.

`hol` is an atom.

Produces~

A `tape`.

Source~
>
    ++  x-co  |=(min=@ (em-co [16 min] |=([? b=@ c=tape] [~(x ne b) c])))
<

Examples~
>
    > `tape`((x-co:co 1) 0xdead.beef)
    "deadbeef"
    
    > `tape`((x-co:co 20) 0xdead.beef)
    "000000000000deadbeef"
<


`++y-co:co`~

Render decimal with at least two digits

Render `dat` as a decimal with a minimum of two digits. If `dat` is less than
two digits it will be padded with zeros.

Accepts~

`dat` is an atom.

Produces~

A `tape`.

Source~
>
    ++  y-co  |=(dat=@ ((d-co 2) dat))
<

Examples~
>
    > (y-co:co 0)
    "00"
    
    > (y-co:co 1)
    "01"
    
    > (y-co:co 123)
    "123"
    
    > (y-co:co 123.456)
    "123456"
<


`++z-co:co`~

Render '0x'-prefixed hex

Render `dat` as hex with a `0x` prefix.

Accepts~

`dat` is an atom.

Produces~

A `tape`.

Source~
>
    ++  z-co  |=(dat=@ `tape`['0' 'x' ((x-co 1) dat)])
<

Examples~
>
    > (z-co:co 123)
    "0x7b"
    
    > (z-co:co 0xdead.beef)
    "0xdeadbeef"
    
    > (z-co:co 0)
    "0x0"
<


`++em-co:co`~

Render in numeric base

In base `bas`, format `min` digits of `hol` with `par`. This is used
internally by other rendering functions.

- `hol` is processed least-significant digit first.
- All available digits in `hol` will be processed, but `min` digits can exceed
the number available in `hol`
- `par` handles all accumulated output on each call, and can edit it, prepend or
append digits, etc.
- Until `hol` is exhausted, `par`'s sample is `[| digit output]`, subsequently,
it's `[& 0 output]`.


Accepts~

`[bas=@ min=@]`, where `bas` is the numeric base and `min` is the minimum
length.

`par` is a `gate` of `$-([? @ tape] tape)`.

`hol` is an atom.

Produces~

A `tape`.

Source~
>
    ++  em-co
      |=  [[bas=@ min=@] par=$-([? @ tape] tape)]
      |=  hol=@
      ^-  tape
      ?:  &(=(0 hol) =(0 min))
        rep
      =/  [dar=@ rad=@]  (dvr hol bas)
      %=  $
        min  ?:(=(0 min) 0 (dec min))
        hol  dar
        rep  (par =(0 dar) rad rep)
      ==
<

Examples~
>
    > ((em-co:co [16 10] |=([? b=@ c=tape] [~(x ne b) c])) 0xbeef)
    "000000beef"
<


`++ed-co:co`~

Format with decimal place

Format `int` by specifying its size with `exp`, which may be negative. This is
used internally by other rendering functions.

Accepts~

`exp` is a `@s`.

`int` is a `tape`.

Produces~

A `tape`.

Source~
>
    ++  ed-co
      |=  [exp=@s int=tape]  ^-  tape
      =/  [pos=? dig=@u]  [=(--1 (cmp:si exp --0)) (abs:si exp)]
      ?.  pos
        (into (weld (reap +(dig) '0') int) 1 '.')
      =/  len  (lent int)
      ?:  (lth dig len)  (into int dig '.')
      (weld int (reap (sub dig len) '0'))
<

Examples~
>
    > (ed-co:co --3 "100")
    "100"
    
    > (ed-co:co --5 "100")
    "10000"
    
    > (ed-co:co -1 "100")
    "0.0100"
    
    > (ed-co:co -5 "100")
    "0.00000100"
<


`++ox-co:co`~

Format dot-separated digits in numeric base

In base `bas`, format each digit of `hol` with gate `dug`, with '.' separators
every `gop` digits. This is used internally by other rendering functions.

- `hol` is processed least-significant digit first.
- `dug` handles individual digits, output is prepended.
- Every segment but the last is zero-padded to `gop`.


Accepts~

`[bas=@ gop=@]` where `bas` is the numeric base and `gop` is dot separator
frequency.

`dug` is a `gate` of `$-(@ @)`.

`hol` is an atom.

Produces~

A `tape`.

Source~
>
    ++  ox-co
      |=  [[bas=@ gop=@] dug=$-(@ @)]
      %+  em-co
        [(pow bas gop) 0]
      |=  [top=? seg=@ res=tape]
      %+  weld
        ?:(top ~ `tape`['.' ~])
      %.  seg
      %+  em-co(rep res)
        [bas ?:(top 0 gop)]
      |=([? b=@ c=tape] [(dug b) c])
<

Examples~
>
    > ((ox-co:co [2 4] |=(a=@ ~(d ne a))) 0b1011.1101)
    "1011.1101"
    
    > ((ox-co:co [2 1] |=(a=@ ~(d ne a))) 0b1011.1101)
    "1.0.1.1.1.1.0.1"
    
    > ((ox-co:co [2 100] |=(a=@ ~(d ne a))) 0b1011.1101)
    "10111101"
<


`++ro-co:co`~

Format dot-prefixed bloqs in numeric base

In base `bas`, for `buz` bloqs 0 to `dop`, format at least one digit of `hol`,
prefixed with `.`. This is used internally for `@i` address rendering
functions.

Accepts~

`[buz=@ bas=@ dop=@]` where `buz` is the bloq size, `bas` is the numeric base,
and `dop` is the number of bloqs.

`dug` is a `gate` of `$-(@ @)`.

`hol` is an atom.

Produces~

A `tape`.

Source~
>
    ++  ro-co
      |=  [[buz=@ bas=@ dop=@] dug=$-(@ @)]
      |=  hol=@
      ^-  tape
      ?:  =(0 dop)
        rep
      :-  '.'
      =/  pod  (dec dop)
      %.  (cut buz [pod 1] hol)
      %+  em-co(rep $(dop pod))
        [bas 1]
      |=([? b=@ c=tape] [(dug b) c])
<

Examples~
>
    > ((ro-co:co [3 10 4] |=(a=@ ~(d ne a))) .127.0.0.1)
    ".127.0.0.1"
<



==============================================================================
 4l: Atom Parsing                                                                         

------------------------------------------------------------------------------
SO                                                                  *++so*

Coin parser engine

Core containing arms that parse atoms encoded in strings.

Source~
>
    ++  so
      ~%  %so  +  ~
      |%
<


`++bisk:so`~

Parse aura-atom pair

Parsing `rule`. Parses an `@u` of any permitted base, producing a `dime`.

Source~
>
    ++  bisk
      ~+
      ;~  pose
        ;~  pfix  (just '0')
          ;~  pose
            (stag %ub ;~(pfix (just 'b') bay:ag))
            (stag %uc ;~(pfix (just 'c') fim:ag))
            (stag %ui ;~(pfix (just 'i') dim:ag))
            (stag %ux ;~(pfix (just 'x') hex:ag))
            (stag %uv ;~(pfix (just 'v') viz:ag))
            (stag %uw ;~(pfix (just 'w') wiz:ag))
          ==
        ==
        (stag %ud dem:ag)
      ==
<

Examples~
>
    > (scan "25" bisk:so)
    [%ud 25]
    
    > (scan "0x12.6401" bisk:so)
    [%ux 1.205.249]
<


`++crub:so`~

Parse `@da`, `@dr`, `@p`, `@t`

Parsing `rule`. Parses any atom of any of the following auras after a leading
sig: `@da`, `@dr`, `@p`, and `@t`. Produces a `dime`.

Source~
>
    ++  crub
      ~+
      ;~  pose
        (cook |=(det=date `dime`[%da (year det)]) when)
      ::
        %+  cook
          |=  [a=(list [p=?(%d %h %m %s) q=@]) b=(list @)]
          =+  rop=`tarp`[0 0 0 0 b]
          |-  ^-  dime
          ?~  a
            [%dr (yule rop)]
          ?-  p.i.a
            %d  $(a t.a, d.rop (add q.i.a d.rop))
            %h  $(a t.a, h.rop (add q.i.a h.rop))
            %m  $(a t.a, m.rop (add q.i.a m.rop))
            %s  $(a t.a, s.rop (add q.i.a s.rop))
          ==
        ;~  plug
          %+  most
            dot
          ;~  pose
            ;~(pfix (just 'd') (stag %d dim:ag))
            ;~(pfix (just 'h') (stag %h dim:ag))
            ;~(pfix (just 'm') (stag %m dim:ag))
            ;~(pfix (just 's') (stag %s dim:ag))
          ==
          ;~(pose ;~(pfix ;~(plug dot dot) (most dot qix:ab)) (easy ~))
        ==
      ::
        (stag %p fed:ag)
        ;~(pfix dot (stag %ta urs:ab))
        ;~(pfix sig (stag %t urx:ab))
        ;~(pfix hep (stag %c (cook taft urx:ab)))
      ==
<

Examples~
>
    > (scan "1926.5.12" crub:so)
    [p=~.da q=170.141.184.449.747.016.871.285.095.307.149.312.000]
    
    > ;;([%da @da] (scan "1926.5.12" crub:so))
    [%da ~1926.5.12]
    
    > (scan "s10" crub:so)
    [p=~.dr q=184.467.440.737.095.516.160]
    
    > ;;([%dr @dr] (scan "s10" crub:so))
    [%dr ~s10]
    
    > (scan "sampel" crub:so)
    [%p 1.135]
    
    > (scan ".mas" crub:so)
    [%ta 7.561.581]
<


`++nuck:so`~

Top-level coin parser

Parsing `rule`. Switches on the first character and applies the corresponding
`coin` parser.

Source~
>
    ++  nuck
      ~/  %nuck  |=  a=nail  %.  a
      %+  knee  *coin  |.  ~+
      %-  stew
      ^.  stet  ^.  limo
      :~  :-  ['a' 'z']  (cook |=(a=@ta [%$ %tas a]) sym)
          :-  ['0' '9']  (stag %$ bisk)
          :-  '-'        (stag %$ tash)
          :-  '.'        ;~(pfix dot perd)
          :-  '~'        ;~(pfix sig ;~(pose twid (easy [%$ %n 0])))
      ==
<

Examples~
>
    > (scan "~pillyt" nuck:so)
    [%$ p=[p=~.p q=13.184]]
    
    > (scan "0x12" nuck:so)
    [%$ p=[p=~.ux q=18]]
    
    > (scan ".127.0.0.1" nuck:so)
    [%$ p=[p=~.if q=2.130.706.433]]
    
    > (scan "._20_0w25_sam__" nuck:so)
    [ %many
        p
      ~[
        [%$ p=[p=~.ud q=20]]
        [%$ p=[p=~.uw q=133]]
        [%$ p=[p=~.tas q=7.168.371]]
      ]
    ]
<


`++nusk:so`~

Parse coin literal with escapes

Parsing `rule`. Parses a coin literal with escapes.

Source~
>
    ++  nusk
      ~+
      :(sear |=(a=@ta (rush a nuck)) wick urt:ab)
<

Examples~
>
    > ~.asd_a
    ~.asd_a
    
    > ._1_~~.asd~-a__
    [1 ~.asd_a]
    
    > (scan "~~.asd~-a" nusk:so)
    [%$ p=[p=~.ta q=418.212.246.369]]
<


`++perd:so`~

Parsing coin literal without prefixes

Parsing `rule`. Parses a dime or tuple without their respective standard
prefixes.

Source~
>
    ++  perd
      ~+
      ;~  pose
        (stag %$ zust)
        (stag %many (ifix [cab ;~(plug cab cab)] (more cab nusk)))
      ==
<

Examples~
>
    > (scan "y" perd:so)
    [%$ [%f %.y]]
    
    > (scan "n" perd:so)
    [%$ [%f %.n]]
    
    > (scan "_20_x__" perd:so)
    [%many [[%$ p=[p=~.ud q=20]] [i=[%$ p=[p=~.tas q=120]] t=~]]]
<


`++royl:so`~

Parse dime float

Parsing `rule`. Parses a number into a `dime` float.

Source~
>
    ++  royl
      ~+
      ;~  pose
        (stag %rh royl-rh)
        (stag %rq royl-rq)
        (stag %rd royl-rd)
        (stag %rs royl-rs)
      ==
<

Examples~
>
    > (scan "~3.14" royl:so)
    [%rd .~3.14]
    
    > (scan "3.14" royl:so)
    [%rs .3.14]
<


`++royl-rh:so`~

Parse half-precision float

Parsing `rule`. Parses a `@rh`.

Source~
>
    ++  royl-rh  (cook rylh ;~(pfix ;~(plug sig sig) (cook royl-cell royl-rn)))
<

Examples~
>
    > (scan "~~3.14" royl-rh:so)
    .~~3.14
<


`++royl-rq:so`~

Parse quad-precision float

Parsing `rule`. Parses a `@rq`.

Source~
>
    ++  royl-rq  (cook rylq ;~(pfix ;~(plug sig sig sig) (cook royl-cell royl-rn)))
<

Examples~
>
    > (scan "~~~3.14" royl-rq:so)
    .~~~3.14
<


`++royl-rd:so`~

Parse double-precision float

Parsing `rule`. Parses a `@rd`.

Source~
>
    ++  royl-rd  (cook ryld ;~(pfix sig (cook royl-cell royl-rn)))
<

Examples~
>
    > (scan "~3.14" royl-rd:so)
    .~3.14
<


`++royl-rs:so`~

Parse single-precision float

Parsing `rule`. Parses a `@rs`.

Source~
>
    ++  royl-rs  (cook ryls (cook royl-cell royl-rn))
<

Examples~
>
    > (scan "3.14" royl-rs:so)
    .3.14
<


`++royl-rn:so`~

Parse real number

Parsing `rule`. Parses a real number to a `++rn`.

Source~
>
    ++  royl-rn
      =/  moo
        |=  a=tape
        :-  (lent a)
        (scan a (bass 10 (plus sid:ab)))
      ;~  pose
        ;~  plug
          (easy %d)
          ;~(pose (cold | hep) (easy &))
          ;~  plug  dim:ag
            ;~  pose
              ;~(pfix dot (cook moo (plus (shim '0' '9'))))
              (easy [0 0])
            ==
            ;~  pose
              ;~  pfix
                (just 'e')
                ;~(plug ;~(pose (cold | hep) (easy &)) dim:ag)
              ==
              (easy [& 0])
            ==
          ==
        ==
        ::
        ;~  plug
          (easy %i)
          ;~  sfix
            ;~(pose (cold | hep) (easy &))
            (jest 'inf')
          ==
        ==
        ::
        ;~  plug
          (easy %n)
          (cold ~ (jest 'nan'))
        ==
      ==
<

Examples~
>
    > (scan "3.14" royl-rn:so)
    [%d %.y 3 [2 14] [%.y 0]]
    
    > (scan "-3.14e-39" royl-rn:so)
    [%d %.n 3 [2 14] [%.n 39]]
    
    > (scan "3" royl-rn:so)
    [%d %.y 3 [0 0] [%.y 0]]
<


`++royl-cell:so`~

Convert rn to dn

Intermediate parsed float converter. Convert a `++rn` to `++dn`.

Accepts~

A `++rn`.

Produces~

A `++dn`.

Source~
>
    ++  royl-cell
      |=  rn
      ^-  dn
      ?.  ?=([%d *] +<)  +<
      =+  ^=  h
        (dif:si (new:si f.b i.b) (sun:si d.b))
      [%d a h (add (mul c.b (pow 10 d.b)) e.b)]
<

Examples~
>
    > (royl-cell:so (scan "3.14" royl-rn:so))
    [%d s=%.y e=-2 a=314]
    
    > (ryls (royl-cell:so (scan "3.14" royl-rn:so)))
    .3.14
<


`++tash:so`~

Parse signed dime

Parsing `rule`. Parse a `@s` to a `dime`.

Source~
>
    ++  tash
      ~+
      =+  ^=  neg
          |=  [syn=? mol=dime]  ^-  dime
          ?>  =('u' (end 3 p.mol))
          [(cat 3 's' (rsh 3 p.mol)) (new:si syn q.mol)]
      ;~  pfix  hep
        ;~  pose
          (cook |=(a=dime (neg | a)) bisk)
          ;~(pfix hep (cook |=(a=dime (neg & a)) bisk))
        ==
      ==
<

Examples~
>
    > (scan "-20" tash:so)
    [p=~.sd q=39]
    
    > ;;([%sd @sd] (scan "-20" tash:so))
    [%sd -20]
    
    > ;;([%sd @sd] (scan "--20" tash:so))
    [%sd --20]
    
    > ;;([%sx @sx] (scan "--0x2e" tash:so))
    [%sx --0x2e]
<


`++twid:so`~

Parse coins without `~` prefix

Parsing rule. Parses coins after a leading sig, `~`.

Source~
>
    ++  twid
      ~+
      ;~  pose
        %+  stag  %blob
        %+  sear  |=(a=@ (mole |.((cue a))))
        ;~(pfix (just '0') vum:ag)
      ::
        (stag %$ crub)
      ==
<

Examples~
>
    > (scan "zod" twid:so)
    [%$ [%p 0]]
    
    > (scan ".sam" twid:so)
    [%$ [%ta 7.168.371]]
    
    > (scan "0ph" twid:so)
    [%blob [1 1]]
<


`++when:so`~

Parse date

Parsing `rule`. Parse a `@da`-formatted date string (sans the leading `~`) to
a `date`.

Source~
>
    ++  when
      ~+
      ;~  plug
        %+  cook
          |=([a=@ b=?] [b a])
        ;~(plug dim:ag ;~(pose (cold | hep) (easy &)))
        ;~(pfix dot mot:ag)   ::  month
        ;~(pfix dot dip:ag)   ::  day
        ;~  pose
          ;~  pfix
            ;~(plug dot dot)
            ;~  plug
              dum:ag
              ;~(pfix dot dum:ag)
              ;~(pfix dot dum:ag)
              ;~(pose ;~(pfix ;~(plug dot dot) (most dot qix:ab)) (easy ~))
            ==
          ==
          (easy [0 0 0 ~])
        ==
      ==
<

Examples~
>
    > `date`(scan "2000.1.1..12.00.00..ffff" when:so)
    [[a=%.y y=2.000] m=1 t=[d=1 h=12 m=0 s=0 f=~[0xffff]]]
<


`++zust:so`~

Parse dimes from `@i`, `@f`, `@r` or `@q`

Parsing rule. Parses an atom of either `@if` (IP address), `@f` (loobean),
`@r` (floating point) into a `dime`. The `@q` alone requires a leading `~`.

Source~
>
    ++  zust
      ~+
      ;~  pose
        (stag %is bip:ag)
        (stag %if lip:ag)
        royl
        (stag %f ;~(pose (cold & (just 'y')) (cold | (just 'n'))))
        (stag %q ;~(pfix sig feq:ag))
      ==
<

Examples~
>
    > (scan "~sampel" zust:so)
    [%q 1.135]
    
    > (scan "y" zust:so)
    [%f %.y]
    
    > (scan "127.0.0.1" zust:so)
    [%if 2.130.706.433]
    
    > (scan "af.0.0.0.0.e7a5.30d2.7" zust:so)
    [%is 908.651.950.243.594.834.993.091.554.288.205.831]
    
    > (scan "12.09" zust:so)
    [%rs .12.09]
<



==============================================================================
 4m: Formatting Functions                                                                         

------------------------------------------------------------------------------
SCOT                                                                  *++scot*

Render dime as cord

Renders a dime `mol` as a cord.

Accepts~

`mol` is a `dime`.

Produces~

A `cord`.

Source~
>
    ++  scot
      ~/  %scot
      |=(mol=dime ~(rent co %$ mol))
<

Examples~
>
    > (scot %p ~pillyt)
    ~.~pillyt
    
    > `@t`(scot %p ~pillyt)
    '~pillyt'
    
    > `@t`(scot %ux 0x12)
    '0x12'
    
    > `@t`(scot %if .127.0.0.1)
    '.127.0.0.1'
    
    > `@t`(scot %ta ~.asd_a)
    '~.asd_a'
<


------------------------------------------------------------------------------
SCOW                                                                  *++scow*

Render dime as tape

Renders a dime `mol` as a tape.

Accepts~

`mol` is a `dime`.

Produces~

A `tape`.

Source~
>
    ++  scow
      ~/  %scow
      |=(mol=dime ~(rend co %$ mol))
<

Examples~
>
    > (scow %p ~pillyt)
    "~pillyt"
    
    > (scow %ux 0x12)
    "0x12"
    
    > (scow %if .127.0.0.1)
    ".127.0.0.1"
    
    > (scow %ta ~.asd_a)
    "~.asd_a"
<


------------------------------------------------------------------------------
SLAT                                                                  *++slat*

Curried slaw

Produces a `gate` that parses a `knot` `txt` to a `unit` containing the atom
of the aura specified by `mod`. The `unit` will be null if parsing failed.

Accepts~

`mod` is a `knot`.

`txt` is a `cord`.

Produces~

A `(unit @)`.

Source~
>
    ++  slat  |=(mod=@tas |=(txt=@ta (slaw mod txt)))
<

Examples~
>
    > `(unit @p)`((slat %p) '~pillyt')
    [~ ~pillyt]
    
    > `(unit @ux)`((slat %ux) '0x12')
    [~ 0x12]
    
    > `(unit @if)`((slat %if) '.127.0.0.1')
    [~ .127.0.0.1]
    
    > `(unit @ta)`((slat %ta) '~.asd_a')
    [~ ~.asd_a]
<


------------------------------------------------------------------------------
SLAV                                                                  *++slav*

Demand: parse cord with input aura

Parses a cord `txt` to an atom of the aura specificed by `mod`. Crashes if it
fails to parse.

Accepts~

`mod` is a `term`

`txt` is a `knot`.

Produces~

an atom.

Source~
>
    ++  slav  |=([mod=@tas txt=@ta] (need (slaw mod txt)))
<

Examples~
>
    > `@p`(slav %p '~pillyt')
    ~pillyt
    
    > `@p`(slav %p '~pillam')
    ! exit
    
    > `@ux`(slav %ux '0x12')
    0x12
    
    > `@ux`(slav %ux '0b10')
    ! exit
    
    > `@if`(slav %if '.127.0.0.1')
    .127.0.0.1
    
    > `@if`(slav %if '.fe80.0.0.202')
    ! exit
    
    > `@ta`(slav %ta '~.asd_a')
    ~.asd_a
    
    > `@ta`(slav %ta '~~asd-a')
    ! exit
<


------------------------------------------------------------------------------
SLAW                                                                  *++slaw*

Parse cord to input aura

Parses a cord `txt` to a `unit` containing the atom of the aura specified by
`mod`. The `unit` is null if parsing failed.

Accepts~

`mod` is a `term`.

`txt` is a `knot`.

Produces~

A `(unit @)`.

Source~
>
    ++  slaw
      ~/  %slaw
      |=  [mod=@tas txt=@ta]
      ^-  (unit @)
      ?+    mod
          ::  slow fallback case to the full slay
          ::
          =+  con=(slay txt)
          ?.(&(?=([~ %$ @ @] con) =(p.p.u.con mod)) ~ [~ q.p.u.con])
      ::
          %da
        (rush txt ;~(pfix sig (cook year when:so)))
      ::
          %p
        (rush txt ;~(pfix sig fed:ag))
      ::
          %ud
        (rush txt dem:ag)
      ::
          %ux
        (rush txt ;~(pfix (jest '0x') hex:ag))
      ::
          %uv
        (rush txt ;~(pfix (jest '0v') viz:ag))
      ::
          %ta
        (rush txt ;~(pfix ;~(plug sig dot) urs:ab))
      ::
          %tas
        (rush txt sym)
      ==
<

Examples~
>
    > `(unit @p)`(slaw %p '~pillyt')
    [~ ~pillyt]
    
    > `(unit @p)`(slaw %p '~pillam')
    ~
    
    > `(unit @ux)`(slaw %ux '0x12')
    [~ 0x12]
    
    > `(unit @ux)`(slaw %ux '0b10')
    ~
    
    > `(unit @if)`(slaw %if '.127.0.0.1')
    [~ .127.0.0.1]
    
    > `(unit @if)`(slaw %if '.fe80.0.0.202')
    ~
    
    > `(unit @ta)`(slaw %ta '~.asd_a')
    [~ ~.asd_a]
    
    > `(unit @ta)`(slaw %ta '~~asd-a')
    ~
<


------------------------------------------------------------------------------
SLAY                                                                  *++slay*

Parse cord to coin

Parses a cord `txt` to the unit of a `coin`.

Accepts~

`txt` is a `@ta`.

Produces~

A `(unit coin)`.

Source~
>
    ++  slay
      |=  txt=@ta  ^-  (unit coin)
      =+  ^=  vex
          ?:  (gth 0x7fff.ffff txt)                         ::  XX  petty cache
            ~+  ((full nuck:so) [[1 1] (trip txt)])
          ((full nuck:so) [[1 1] (trip txt)])
      ?~  q.vex
        ~
      [~ p.u.q.vex]
<

Examples~
>
    > (slay '~pillyt')
    [~ [%$ p=[p=~.p q=13.184]]]
    
    > (slay '0x12')
    [~ [%$ p=[p=~.ux q=18]]]
    
    > (slay '.127.0.0.1')
    [~ [%$ p=[p=~.if q=2.130.706.433]]]
    
    > (slay '!')
    ~
<


------------------------------------------------------------------------------
SMYT                                                                  *++smyt*

Render path as tank

Renders the path `bon` as a `tank`, which is used for pretty-printing.

Accepts~

`bon` is a `path`.

Produces~

A `tank`.

Source~
>
    ++  smyt
      |=  bon=path  ^-  tank
      :+  %rose  [['/' ~] ['/' ~] ~]
      (turn bon |=(a=@ [%leaf (trip a)]))
<

Examples~
>
    > (smyt %)
    [ %rose
      p=[p="/" q="/" r=""]
        q
      ~[
        [%leaf p="~zod"]
        [%leaf p="base"]
        [%leaf p="~2022.1.6..14.22.14..40bf"]
      ]
    ]
    
    > (smyt /as/les/top)
    [ %rose
      p=[p="/" q="/" r=""]
      q=~[[%leaf p="as"] [%leaf p="les"] [%leaf p="top"]]
    ]
<


------------------------------------------------------------------------------
SPAT                                                                  *++spat*

Render path as cord

Renders a path `pax` as cord.

Accepts~

`pax` is a `path`.

Produces~

A `cord`.

Source~
>
    ++  spat  |=(pax=path (crip (spud pax)))
<

Examples~
>
    > (spat %)
    '/~zod/base/~2022.1.6..14.23.31..e367'
    
    > (spat %/lib)
    '/~zod/base/~2022.1.6..14.23.43..829e/lib'
    
    > (spat /as/les/top)
    '/as/les/top'
<


------------------------------------------------------------------------------
SPUD                                                                  *++spud*

Render path as tape

Renders a path `pax` as tape.

Accepts~

`pax` is a `path`.

Produces~

A `tape`.

Source~
>
    ++  spud  |=(pax=path ~(ram re (smyt pax)))
<

Examples~
>
    > (spud %)
    "/~zod/base/~2022.1.6..14.24.35..cddf"
    
    > (spud %/lib)
    "/~zod/base/~2022.1.6..14.24.43..3efb/lib"
    
    > (spud /as/les/top)
    "/as/les/top"
<


------------------------------------------------------------------------------
STAB                                                                  *++stab*

Parse cord to path

Parses a cord `zep` to a static `path`. Crashes if it fails to parse.

Accepts~

`zep` is a `@t`.

Produces~

A `path`, or crash.

Source~
>
    ++  stab  |=(zep=@t `path`(rash zep stap))
<

Examples~
>
    > (stab '/as/lek/tor')
    /as/lek/tor
<


------------------------------------------------------------------------------
STAP                                                                  *++stap*

Path parser

Parsing `rule`. Parses a `path`, used internally by `++stab`.

Source~
>
    ++  stap
      %+  sear
        |=  p=path
        ^-  (unit path)
        ?:  ?=([~ ~] p)  `~
        ?.  =(~ (rear p))  `p
        ~
      ;~(pfix fas (most fas urs:ab))
<

Examples~
>
    > (scan "/foo/bar/baz" stap)
    /foo/bar/baz
<



==============================================================================
 4n: Virtualization                                                                         

------------------------------------------------------------------------------
MACK                                                                  *++mack*

Nock subject to unit

Accepts a nock subject-formula cell and wraps it into a `unit`. `fol` is pure
nock, meaning that nock `11` operations result in a block, producing a `~`.

Accepts~

`sub` is a subject noun.

`fol` is a formula noun, which is generally a `nock`.

Produces~

The `unit` of a noun.

Source~
>
    ++  mack
      |=  [sub=* fol=*]
      ^-  (unit)
      =/  ton  (mink [sub fol] |~(^ ~))
      ?.(?=(%0 -.ton) ~ `product.ton)
<

Examples~
>
    > (mack [[1 2 3] [0 1]])
    [~ [1 2 3]]
    
    > (mack [41 4 0 1])
    [~ 42]
    
    > (mack [4 0 4])
    ~
    
    > (mack [[[0 2] [1 3]] 4 4 4 4 0 5])
    [~ 6]
    
    > ;;((unit @tas) (mack [[1 %yes %no] 6 [0 2] [0 6] 0 7]))
    [~ %no]
<


------------------------------------------------------------------------------
MINK                                                                  *++mink*

Mock interpreter

Bottom-level mock (virtual nock) interpreter. Produces a `tone`, a nock
computation result. If nock 12 is invoked, `scry` computes on the subject and
produces a `(unit (unit))` result. An empty result becomes a `%1` `tone`,
indicating a block.

Accepts~

`subject` is the subject as a noun.

`formula` is the formula as a noun.

`scry` is an `%iron` gate invoked with nock operator 12.

Produces~

A `tone`.

Source~
>
    ++  mink  !.
      ~/  %mink
      |=  $:  [subject=* formula=*]
              scry=$-(^ (unit (unit)))
          ==
      =|  trace=(list [@ta *])
      |^  ^-  tone
          ?+  formula  [%2 trace]
              [^ *]
            =/  head  $(formula -.formula)
            ?.  ?=(%0 -.head)  head
            =/  tail  $(formula +.formula)
            ?.  ?=(%0 -.tail)  tail
            [%0 product.head product.tail]
          ::
              [%0 axis=@]
            =/  part  (frag axis.formula subject)
            ?~  part  [%2 trace]
            [%0 u.part]
          ::
              [%1 constant=*]
            [%0 constant.formula]
          ::
              [%2 subject=* formula=*]
            =/  subject  $(formula subject.formula)
            ?.  ?=(%0 -.subject)  subject
            =/  formula  $(formula formula.formula)
            ?.  ?=(%0 -.formula)  formula
            %=  $
              subject  product.subject
              formula  product.formula
            ==
          ::
              [%3 argument=*]
            =/  argument  $(formula argument.formula)
            ?.  ?=(%0 -.argument)  argument
            [%0 .?(product.argument)]
          ::
              [%4 argument=*]
            =/  argument  $(formula argument.formula)
            ?.  ?=(%0 -.argument)  argument
            ?^  product.argument  [%2 trace]
            [%0 .+(product.argument)]
          ::
              [%5 a=* b=*]
            =/  a  $(formula a.formula)
            ?.  ?=(%0 -.a)  a
            =/  b  $(formula b.formula)
            ?.  ?=(%0 -.b)  b
            [%0 =(product.a product.b)]
          ::
              [%6 test=* yes=* no=*]
            =/  result  $(formula test.formula)
            ?.  ?=(%0 -.result)  result
            ?+  product.result
                  [%2 trace]
              %&  $(formula yes.formula)
              %|  $(formula no.formula)
            ==
          ::
              [%7 subject=* next=*]
            =/  subject  $(formula subject.formula)
            ?.  ?=(%0 -.subject)  subject
            %=  $
              subject  product.subject
              formula  next.formula
            ==
          ::
              [%8 head=* next=*]
            =/  head  $(formula head.formula)
            ?.  ?=(%0 -.head)  head
            %=  $
              subject  [product.head subject]
              formula  next.formula
            ==
          ::
              [%9 axis=@ core=*]
            =/  core  $(formula core.formula)
            ?.  ?=(%0 -.core)  core
            =/  arm  (frag axis.formula product.core)
            ?~  arm  [%2 trace]
            %=  $
              subject  product.core
              formula  u.arm
            ==
          ::
              [%10 [axis=@ value=*] target=*]
            ?:  =(0 axis.formula)  [%2 trace]
            =/  target  $(formula target.formula)
            ?.  ?=(%0 -.target)  target
            =/  value  $(formula value.formula)
            ?.  ?=(%0 -.value)  value
            =/  mutant=(unit *)
              (edit axis.formula product.target product.value)
            ?~  mutant  [%2 trace]
            [%0 u.mutant]
          ::
              [%11 tag=@ next=*]
            =/  next  $(formula next.formula)
            ?.  ?=(%0 -.next)  next
            :-  %0
            .*  subject
            [11 tag.formula 1 product.next]
          ::
              [%11 [tag=@ clue=*] next=*]
            =/  clue  $(formula clue.formula)
            ?.  ?=(%0 -.clue)  clue
            =/  next
              =?    trace
                  ?=(?(%hunk %hand %lose %mean %spot) tag.formula)
                [[tag.formula product.clue] trace]
              $(formula next.formula)
            ?.  ?=(%0 -.next)  next
            :-  %0
            .*  subject
            [11 [tag.formula 1 product.clue] 1 product.next]
          ::
              [%12 ref=* path=*]
            =/  ref  $(formula ref.formula)
            ?.  ?=(%0 -.ref)  ref
            =/  path  $(formula path.formula)
            ?.  ?=(%0 -.path)  path
            =/  result  (scry product.ref product.path)
            ?~  result
              [%1 product.path]
            ?~  u.result
              [%2 [%hunk product.ref product.path] trace]
            [%0 u.u.result]
          ==
      ::
      ++  frag
        |=  [axis=@ noun=*]
        ^-  (unit)
        ?:  =(0 axis)  ~
        |-  ^-  (unit)
        ?:  =(1 axis)  `noun
        ?@  noun  ~
        =/  pick  (cap axis)
        %=  $
          axis  (mas axis)
          noun  ?-(pick %2 -.noun, %3 +.noun)
        ==
      ::
      ++  edit
        |=  [axis=@ target=* value=*]
        ^-  (unit)
        ?:  =(1 axis)  `value
        ?@  target  ~
        =/  pick  (cap axis)
        =/  mutant
          %=  $
            axis    (mas axis)
            target  ?-(pick %2 -.target, %3 +.target)
          ==
        ?~  mutant  ~
        ?-  pick
          %2  `[u.mutant +.target]
          %3  `[-.target u.mutant]
        ==
      --
<

Examples~
>
    > (mink [20 [4 0 1]] ,~)
    [%0 product=21]
    
    > (mink [[[4 5] [6 14 15]] [0 7]] ,~)
    [%0 product=[14 15]]
    
    > (mink [42 12 [0 1] [1 73]] |=(a=^ ``(add (,[@ @] a))))
    [%0 product=115]
    
    > (mink [0 12 [1 0] [1 0]] |=(* ~))
    [%1 block=0]
    
    > (mink [42 0 2] ,~)
    [%2 trace=~]
<


------------------------------------------------------------------------------
MOCK                                                                  *++mock*

Compute formula on subject with hint

Produces a `toon`, which is either a sucessful, blocked, or crashed result. If
nock 11 is invoked, `gul` computes on the subject and produces a `(unit
(unit))` result. An empty result becomes a `%1` `tune`, indicating a block.

Accepts~

`sub` is the subject as a noun.

`fol` is the formula as a noun.

`gul` is an %iron gate invoked with nock operator 11.

Produces~

The `unit` of a noun.

Source~
>
    ++  mock
      |=  [[sub=* fol=*] gul=$-(^ (unit (unit)))]
      (mook (mink [sub fol] gul))
<

Examples~
>
    > (mock [5 4 0 1] ,~)
    [%0 p=6]
    
    > (mock [0 12 [0 1] [0 1]] |=(* ``999))
    [%0 p=999]
    
    > (mock [42 12 [0 1] [0 1]] |=(* ~))
    [%1 p=42]
    
    > (mock [42 0 2] ,~)
    [%2 p=~]
<


------------------------------------------------------------------------------
MOOK                                                                  *++mook*

Intelligently render crash annotation

Converts a `%2` `tone` nock stack trace to a list of `tank`. Each may be a
`tank`, `cord`, `spot`, or trapped `tank`.

Accepts~

`ton` is a `tone`.

Produces~

A `toon`.

Source~
>
    ++  mook
      |=  ton=tone
      ^-  toon
      ?.  ?=([%2 *] ton)
        ton
      |^  [%2 (turn skip rend)]
      ::
      ++  skip
        ^+  trace.ton
        =/  yel  (lent trace.ton)
        ?.  (gth yel 1.024)  trace.ton
        %+  weld
          (scag 512 trace.ton)
        ^+  trace.ton
        :_  (slag (sub yel 512) trace.ton)
        :-  %lose
        (crip "[skipped {(scow %ud (sub yel 1.024))} frames]")
      ::
      ::  +rend: raw stack frame to tank
      ::
      ::    $%  [%hunk ref=* path]            ::  failed scry ([~ ~])
      ::        [%lose cord]                  ::  skipped frames
      ::        [%hand *]                     ::  mug any
      ::        [%mean $@(cord (trap tank))]  ::  ~_ et al
      ::        [%spot spot]                  ::  source location
      ::    ==
      ::
      ++  rend
        |=  [tag=@ta dat=*]
        ^-  tank
        ?+    tag
        ::
          leaf+"mook.{(rip 3 tag)}"
        ::
            %hunk
          ?@  dat  leaf+"mook.hunk"
          =/  sof=(unit path)  ((soft path) +.dat)
          ?~  sof  leaf+"mook.hunk"
          (smyt u.sof)
        ::
            %lose
          ?^  dat  leaf+"mook.lose"
          leaf+(rip 3 dat)
        ::
            %hand
          leaf+(scow %p (mug dat))
        ::
            %mean
          ?@  dat  leaf+(rip 3 dat)
          =/  mac  (mack dat -.dat)
          ?~  mac  leaf+"####"
          =/  sof  ((soft tank) u.mac)
          ?~  sof  leaf+"mook.mean"
          u.sof
        ::
            %spot
          =/  sof=(unit spot)  ((soft spot) dat)
          ?~  sof  leaf+"mook.spot"
          :+  %rose  [":" ~ ~]
          :~  (smyt p.u.sof)
              =*  l   p.q.u.sof
              =*  r   q.q.u.sof
              =/  ud  |=(a=@u (scow %ud a))
              leaf+"<[{(ud p.l)} {(ud q.l)}].[{(ud p.r)} {(ud q.r)}]>"
          ==
        ==
      --
<

Examples~
>
    > (mook [%0 5 4 5 1])
    [%0 p=[5 4 5 1]]
    
    > (mook [%2 ~[[%hunk %rose ["<" "," ">"] ~[[%leaf "err"]]]]])
    [%2 p=~[[%leaf p="mook.hunk"]]]
    
    > (mook [%2 ~[[%mean |.(>(add 5 6)<)]]])
    [%2 p=~[[%leaf p="11"]]]
    
    > (mook [%2 ~[[%spot /b/repl [1 1]^[1 2]] [%mean |.(!!)]]])
    [ %2
        p
      ~[
        [ %rose
          p=[p=":" q="" r=""]
            q
          [   i
            [ %rose
              p=[p="/" q="/" r=""]
              q=[i=[%leaf p="b"] t=[i=[%leaf p="repl"] t=~]]
            ]
            t=[i=[%leaf p="<[1 1].[1 2]>"] t=~]
          ]
        ]
        [%leaf p="####"]
      ]
    ]
<


------------------------------------------------------------------------------
MOLE                                                                  *++mole*

Typed unitary virtual

Kicks a `trap`, producing its result in a `unit` if successful, or a null
`unit` if it crashed. Unitized version of `++mule`.

Accepts~

`tap` is a `trap`.

Produces~

A `(unit *)`, where the `*` will be the type produced by the expression.

Source~
>
    ++  mole
      ~/  %mole
      |*  tap=(trap)
      ^-  (unit _$:tap)
      =/  mur  (mure tap)
      ?~(mur ~ `$:tap)
<

Examples~
>
    > (mole |.(`@t`(add 50 47)))
    [~ 'a']
    
    > (mole |.(~|('Error!' !!)))
    ~
<


------------------------------------------------------------------------------
MONG                                                                  *++mong*

Slam gate with sample

Produces a `toon` computation result from slamming `gat` with `sam`, using
`gul` to compute or block on nock 11 when applicable.

Accepts~

`gat` is a noun that is generally a `gate`.

`sam` is a sample noun.

`gul` is an `%iron` gate invoked with nock operator 11.

Produces~

A `toon`.

Source~
>
    ++  mong
      |=  [[gat=* sam=*] gul=$-(^ (unit (unit)))]
      ^-  toon
      ?.  ?=([* ^] gat)  [%2 ~]
      (mock [gat(+< sam) %9 2 %0 1] gul)
<

Examples~
>
    > (mong [|=(@ 20) ~] ,~)
    [%0 p=20]
    
    > (mong [|=(@ !!) ~] ,~)
    [%2 p=~]
    
    > (mong [|=(a=@ (add 20 a)) ~] ,~)
    [%0 p=20]
    
    > (mong [|=(a=[@ @] (add 20 -.a)) ~] ,~)
    [%2 p=~]
    
    > (mong [|=(a=[@ @] (add 20 -.a)) [4 6]] ,~)
    [%0 p=24]
    
    > (mong [|=(a=@ .^(* a)) 99] |=(^ ``+<))
    [%0 p=[[140 1.853.189.998] 99]]
    
    > (mong [|=(a=@ .^(@ a)) 99] |=([* a=*] ``+((,@ a))))
    [%0 p=100]
<


------------------------------------------------------------------------------
MULE                                                                  *++mule*

Typed virtual

Kicks a `trap`, producing its results or any errors that occur along the way.
Used to lazily compute stack traces.

Accepts~

`tap` is a `trap`, generally producing a list of `tank`s.

Produces~

An `(each * (list tank))` - `%.y` indicates success and `%.n` indicates a
crash.

Source~
>
    ++  mule
      ~/  %mule
      |*  tap=(trap)
      =/  mud  (mute tap)
      ?-  -.mud
        %&  [%& p=$:tap]
        %|  [%| p=p.mud]
      ==
<

Examples~
>
    > (mule |.((add 1 1)))
    [%.y p=2]
    
    > (mule |.(~|(%error !!)))
    [%.n p=~[[%leaf p="%error"]]]
<


------------------------------------------------------------------------------
MURE                                                                  *++mure*

Untyped unitary virtual

Kicks a `trap`, producing its results in a `unit` which is null if it crashed.
The result is just a noun, no type information is preserved.

Accepts~

A `trap`.

Produces~

A `(unit *)`.

Source~
>
    ++  mure
      |=  tap=(trap)
      ^-  (unit)
      =/  ton  (mink [tap %9 2 %0 1] |=((pair) ``.*(~ [%12 1+p 1+q])))
      ?.(?=(%0 -.ton) ~ `product.ton)
<

Examples~
>
    > (mure |.(~|(%error !!)))
    ~
    
    > (mure |.((add 1 1)))
    [~ 2]
    
    > (mure |.('foo'))
    [~ 7.303.014]
    
    > ((unit @t) (mure |.('foo')))
    [~ 'foo']
<


------------------------------------------------------------------------------
MUTE                                                                  *++mute*

Untyped virtual

Kicks a `trap`, producing its result as a noun or the tanks of any error that
occurs. Similar to `++mule`, but preserves no type information.

Accepts~

`tap` is a `trap`.

Produces~

A `(each * (list tank))`, where `%.y` indicates success and `%.n` indicates
failure.

Source~
>
    ++  mute
      |=  tap=(trap)
      ^-  (each * (list tank))
      =/  ton  (mock [tap %9 2 %0 1] |=((pair) ``.*(~ [%12 1+p 1+q])))
      ?-  -.ton
        %0  [%& p.ton]
      ::
        %1  =/  sof=(unit path)  ((soft path) p.ton)
            [%| ?~(sof leaf+"mute.hunk" (smyt u.sof)) ~]
      ::
        %2  [%| p.ton]
      ==
<

Examples~
>
    > (mute |.(leaf+"hello"))
    [%.y p=[1.717.658.988 104 101 108 108 111 0]]
    
    > (mute |.(!!))
    [%.n p=~]
    
    > (mute |.(~|(%error !!)))
    [%.n p=~[[%leaf p="%error"]]]
    
    > (mute |.((cat 3 'foo' 'bar')))
    [%.y p=125.762.588.864.358]
<


------------------------------------------------------------------------------
SLUM                                                                  *++slum*

Slam a gate on a sample using raw nock, untyped

Slam `gat` with `sam`. Uses a raw `.*` nock expression internally and does not
preserve type information for the result. This will crash if evaluation
crashes.

Examples~
>
    > (slum |=([a=@ b=@] (add a b)) [7 9])
    16
    
    > (slum (cury cat 3) ['foo' 'bar'])
    125.762.588.864.358
    
    > (@t (slum (cury cat 3) ['foo' 'bar']))
    'foobar'
    
    > (slum |=(* !!) 42)
    dojo: hoon expression failed
<


------------------------------------------------------------------------------
SOFT                                                                  *++soft*

Virtual clam

Clam (mold) noun `fud` with `mold` `han`, producing a `unit` of the result.
The `unit` is null if clamming failed. This is curried, so the soft-clamming
gate can be stored and called repeatedly.

Accepts~

`han` is a `mold`.

`fud` is a noun.

Produces~

A `(unit *)`, where the `*` will be the type produced by the mold.

Source~
>
    ++  soft
      |*  han=$-(* *)
      |=(fud=* (mole |.((han fud))))
<

Examples~
>
    > ((soft @t) 97)
    [~ 'a']
    
    > ((soft @t) [1 2])
    ~
    
    > ((soft ,[@ux @ux]) ['a' 'b'])
    [~ [0x61 0x62]]
<



==============================================================================
 4o: Molds                                                                         

------------------------------------------------------------------------------
+$ABEL                                                                  *+$abel*

Original sin: type

Old type, same as the new `type`.

Source~
>
    +$  abel  typo
<

Examples~
>
    > *abel
    #t/*
<


------------------------------------------------------------------------------
+$ALAS                                                                  *+$alas*

Alias list

This is the type used in `%brcb` (`|_` door) `hoon` type for `+*` alias arms.

Source~
>
    +$  alas  (list (pair term hoon))
<


------------------------------------------------------------------------------
+$ATOM                                                                  *+$atom*

Just an atom

This is the same as `@`.

Source~
>
    +$  atom  @
<

Examples~
>
    > *atom
    0
    
    > `atom`'foo'
    7.303.014
<


------------------------------------------------------------------------------
+$AURA                                                                  *+$aura*

'type' of atom

By convention, a short name for a category of atom. `aura` is circularly
defined, with `@ta` being the `aura` of the ASCII subset commonly used in
urbit.

Source~
>
    +$  aura  @ta
<

Examples~

See also: `+$base`, aura reference
>
    > `aura`'ux'
    ~.ux
<


------------------------------------------------------------------------------
+$BASE                                                                  *+$base*

Base type

A base type that nouns are built from. A `base` is either a noun, atom with
aura, cell, boolean, null, or an empty set.

Source~
>
    +$  base            ::  base mold
      $@  $?  %noun     ::  any noun
              %cell     ::  any cell
              %flag     ::  loobean
              %null     ::  ~ == 0
              %void     ::  empty set
          ==            ::
      [%atom p=aura]    ::  atom
<

Examples~
>
    > *base
    %void
    
    > (ream '=|(^ !!)')
    [%tsbr p=[%base p=%cell] q=[%zpzp ~]]
<


------------------------------------------------------------------------------
+$WOOF                                                                  *+$woof*

Simple embed

An atom or some `hoon`.

Source~
>
    +$  woof  $@(@ [~ p=hoon])
<

Examples~
>
    > *woof
    0
    
    > `woof`[~ %base p=%cell]
    [~ p=[%base p=%cell]]
    
    > `woof`'foo'
    7.303.014
<


------------------------------------------------------------------------------
+$CHUM                                                                  *+$chum*

Jet hint information

Jet hint information that must be present in the body of a `~/` or `~%` rune.
A `chum` can optionally contain a kelvin version, jet vendor, and version
number.

Source~
>
    +$  chum  $?  lef=term                                  ::  jet name
                  [std=term kel=@]                          ::  kelvin version
                  [ven=term pro=term kel=@]                 ::  vendor and product
                  [ven=term pro=term ver=@ kel=@]           ::  all of the above
              ==                                            ::
<

Examples~
>
    > `chum`'hi'
    lef=%hi
    
    > (ream '~/(%lob.314 !!)')
    [%sgfs p=[std=%lob kel=314] q=[%zpzp ~]]
<


------------------------------------------------------------------------------
+$COIL                                                                  *+$coil*

Tuple of core information

Variance `p`, subject type `q`, and `r`: optional compiled nock, and arms.
Used as an intermediate step during compilation and converted to a core.

Source~
>
    +$  coil  $:  p=garb                               ::  name, wet=dry, vary
                  q=type                               ::  context
                  r=(pair seminoun (map term tome))    ::  chapters
              ==                                       ::
<


------------------------------------------------------------------------------
+$GARB                                                                  *+$garb*

Core metadata

A triple of an optional name, polarity (wet/dry), and variance (`%iron`, etc).

Source~
>
    +$  garb  (trel (unit term) poly vair)
<


------------------------------------------------------------------------------
+$POLY                                                                  *+$poly*

Polarity

Whether a core is wet or dry.

Source~
>
    +$  poly  ?(%wet %dry)
<


------------------------------------------------------------------------------
+$FOOT                                                                  *+$foot*

Cases of arms by variance model.

Source~
>
    +$  foot  $%  [%dry p=hoon]    ::  dry arm, geometric
                  [%wet p=hoon]    ::  wet arm, generic
              ==
<


------------------------------------------------------------------------------
+$LINK                                                                  *+$link*

Lexical segment

Used for documentation.

Source~
>
    +$  link                               ::  lexical segment
              $%  [%chat p=term]           ::  |chapter
                  [%cone p=aura q=atom]    ::  %constant
                  [%frag p=term]           ::  .leg
                  [%funk p=term]           ::  +arm
              ==
<


------------------------------------------------------------------------------
+$CRIB                                                                  *+$crib*

Summary and details

Summary and details for documentation.

Source~
>
    +$  crib  [summary=cord details=(list sect)]
<


------------------------------------------------------------------------------
+$HELP                                                                  *+$help*

Documentation

Source~
>
    +$  help  [links=(list link) =crib]
<


------------------------------------------------------------------------------
+$LIMB                                                                  *+$limb*

Wing element

Reference into subject by tree address or name.

Source~
>
    +$  limb  $@  term                                      ::  wing element
              $%  [%& p=axis]                               ::  by geometry
                  [%| p=@ud q=(unit term)]                  ::  by name
              ==                                            ::
<

Examples~
>
    > (ream '^^$')
    [%wing p=~[[%.n p=2 q=[~ %$]]]]
<


------------------------------------------------------------------------------
+$NULL                                                                  *+$null*

Null, nil, etc

Just `~`.

Source~
>
    +$  null  ~
<

Examples~
>
    > *null
    ~
<


------------------------------------------------------------------------------
+$ONYX                                                                  *+$onyx*

Arm activation

Source~
>
    +$  onyx  (list (pair type foot))
<


------------------------------------------------------------------------------
+$OPAL                                                                  *+$opal*

Wing match

Arm or leg of a wing.

Source~
>
    +$  opal                                            ::  limb match
              $%  [%& p=type]                           ::  leg
                  [%| p=axis q=(set [p=type q=foot])]   ::  arm
              ==                                        ::
<


------------------------------------------------------------------------------
+$PICA                                                                  *+$pica*

Prose or code

A `(pair ? cord)`. If `%.y` it's prose and if `%.n` it's code. Used in
documentation.

Source~
>
    +$  pica  (pair ? cord)
<


------------------------------------------------------------------------------
+$PALO                                                                  *+$palo*

Wing trace, match

A `$vein` and a `$opal`.

Source~
>
    +$  palo  (pair vein opal)
<


------------------------------------------------------------------------------
+$PLAT                                                                  *+$plat*

%hoon, %type, %nock or %tank

Source~
>
    +$  plat
              $?  %hoon
                  %type
                  %nock
                  %tank
              ==
<


------------------------------------------------------------------------------
+$POCK                                                                  *+$pock*

Changes

Source~
>
    +$  pock  (pair axis nock)
<


------------------------------------------------------------------------------
+$PORT                                                                  *+$port*

Successful wing match

Source~
>
    +$  port  (each palo (pair type nock))
<


------------------------------------------------------------------------------
+$SPEC                                                                  *+$spec*

Structure definition AST.

Source~
>
    +$  spec                                                ::  structure definition
              $~  [%base %null]                             ::
              $%  [%base p=base]                            ::  base type
                  [%dbug p=spot q=spec]                     ::  set debug
                  [%leaf p=term q=@]                        ::  constant atom
                  [%like p=wing q=(list wing)]              ::  reference
                  [%loop p=term]                            ::  hygienic reference
                  [%made p=(pair term (list term)) q=spec]  ::  annotate synthetic
                  [%make p=hoon q=(list spec)]              ::  composed spec
                  [%name p=term q=spec]                     ::  annotate simple
                  [%over p=wing q=spec]                     ::  relative to subject
              ::                                            ::
                  [%bcgr p=spec q=spec]                     ::  $>, filter: require
                  [%bcbc p=spec q=(map term spec)]          ::  $$, recursion
                  [%bcbr p=spec q=hoon]                     ::  $|, verify
                  [%bccb p=hoon]                            ::  $_, example
                  [%bccl p=[i=spec t=(list spec)]]          ::  $:, tuple
                  [%bccn p=[i=spec t=(list spec)]]          ::  $%, head pick
                  [%bcdt p=spec q=(map term spec)]          ::  $., read-write core
                  [%bcgl p=spec q=spec]                     ::  $<, filter: exclude
                  [%bchp p=spec q=spec]                     ::  $-, function core
                  [%bckt p=spec q=spec]                     ::  $^, cons pick
                  [%bcls p=stud q=spec]                     ::  $+, standard
                  [%bcfs p=spec q=(map term spec)]          ::  $/, write-only core
                  [%bcmc p=hoon]                            ::  $;, manual
                  [%bcpm p=spec q=hoon]                     ::  $&, repair
                  [%bcsg p=hoon q=spec]                     ::  $~, default
                  [%bctc p=spec q=(map term spec)]          ::  $`, read-only core
                  [%bcts p=skin q=spec]                     ::  $=, name
                  [%bcpt p=spec q=spec]                     ::  $@, atom pick
                  [%bcwt p=[i=spec t=(list spec)]]          ::  $?, full pick
                  [%bczp p=spec q=(map term spec)]          ::  $!, opaque core
              ==                                            ::
<

Examples~
>
    > *spec
    [%base p=%null]
    
    > `spec`[%bccl ~[leaf+ud+1 leaf+ud+2]]
    [%bccl p=[i=[%leaf p=%ud q=1] t=~[[%leaf p=%ud q=2]]]]
<


------------------------------------------------------------------------------
+$TENT                                                                  *+$tent*

Model builder

Source~
>
    +$  tent
              $%  [%| p=wing q=tent r=(list spec)]    ::  ~(p q r...)
                  [%& p=(list wing)]                  ::  a.b:c.d
              ==                                      ::
<


------------------------------------------------------------------------------
+$TIKI                                                                  *+$tiki*

Test case

This is used when compiling `?-` expressions and similar.

Source~
>
    +$  tiki                                                ::  test case
              $%  [%& p=(unit term) q=wing]                 ::  simple wing
                  [%| p=(unit term) q=hoon]                 ::  named wing
              ==                                            ::
<


------------------------------------------------------------------------------
+$SKIN                                                                  *+$skin*

Texture

This type is used for faces and similar by the compiler.

Source~
>
    +$  skin                             ::  texture
              $@  =term                  ::  name/~[term %none]
              $%  [%base =base]          ::  base match
                  [%cell =skin =skin]    ::  pair
                  [%dbug =spot =skin]    ::  trace
                  [%leaf =aura =atom]    ::  atomic constant
                  [%help =help =skin]    ::  describe
                  [%name =term =skin]    ::  apply label
                  [%over =wing =skin]    ::  relative to
                  [%spec =spec =skin]    ::  cast to
                  [%wash depth=@ud]      ::  strip faces
              ==                         ::
<


------------------------------------------------------------------------------
+$TOME                                                                  *+$tome*

Core chapter

This type is used by the compiler for the contents of arms in cores.

Source~
>
    +$  tome  (pair what (map term hoon))
<


------------------------------------------------------------------------------
+$TOPE                                                                  *+$tope*

Topographic type

Describes the structure of a noun.

Source~
>
    +$  tope              ::  topographic type
      $@  $?  %&          ::  cell or atom
              %|          ::  atom
          ==              ::
      (pair tope tope)    ::  cell
<

Examples~
>
    > *tope
    %.n
    
    > `tope`[%| %&]
    [p=%.n q=%.y]
<


------------------------------------------------------------------------------
HOOT                                                                  *++hoot*

Hoon tools

Container core for internally-used XML structure types. XML structure types
you'd typically use directly are defined in Standard Library section 5e.

Source~
>
    ++  hoot
      |%
<


`+$beer:hoot`~

Simple embed

Either a tape element or interpolated hoon expression in an XML attribute.

Source~
>
    +$  beer  $@(char [~ p=hoon])
<


`+$mane:hoot`~

XML name+space

XML tag name and optional namespace.

Source~
>
    +$  mane  $@(@tas [@tas @tas])
<

Examples~
>
    > (en-xml:html ;foo;)
    "<foo></foo>"
    
    > (en-xml:html ;foo_bar;)
    "<foo:bar></foo:bar>"
    
    > `manx:hoot`;foo_bar;
    [g=[n=[%foo %bar] a=~] c=~]
    
    > `mane:hoot`n.g:`manx`;foo_bar;
    [%foo %bar]
    
    > `mane:hoot`n.g:`manx:hoot`;foo;
    %foo
<


`+$manx:hoot`~

Dynamic XML node

An XML element which may contain text, attributes, and other elements.

`g` is a `$marx:hoot` (a tag) and `c` is a `$marl:hoot` (its contents).

Source~
>
    +$  manx  $~([[%$ ~] ~] [g=marx c=marl])
<

Examples~
>
    > *manx:hoot
    [g=[n=%$ a=~] c=~
    
    > `manx:hoot`;foo;
    [g=[n=%foo a=~] c=~]
    
    > (en-xml:html `manx:hoot`;foo;)
    "<foo></foo>"
    
    > =a ^-  manx:hoot
         ;foo
           ;bar: abc
           ;baz
             ;xxx: hello
           ==
         ==
    
    > a
    [ g=[n=%foo a=~]
        c
      ~[
        [ g=[n=%bar a=~]
          c=~[[g=[n=%$ a=~[[n=%$ v="abc"]]] c=~]]
        ]
        [ g=[n=%baz a=~]
            c
          ~[
            [ g=[n=%xxx a=~]
              c=~[[g=[n=%$ a=~[[n=%$ v="hello"]]] c=~]]
            ]
          ]
        ]
      ]
    ]
    
    > (en-xml:html a)
    "<foo><bar>abc</bar><baz><xxx>hello</xxx></baz></foo>"
<


`+$marl:hoot`~

Dynamic XML nodes

A list of XML nodes - maybe with interpolation and recursion. See
`$tuna:hoot`.

Source~
>
    +$  marl  (list tuna)
<

Examples~
>
    > *marl
    ~
    
    > ^-  marl:hoot
      ;=
        ;foo: abc
        ;bar: def
      ==
    ~[
      [g=[n=%foo a=~] c=~[[g=[n=%$ a=~[[n=%$ v=~['a' 'b' 'c']]]] c=~]]]
      [g=[n=%bar a=~] c=~[[g=[n=%$ a=~[[n=%$ v=~['d' 'e' 'f']]]] c=~]]]
    ]
    
    > %-  en-xml:html
      ;baz
        ;=
          ;foo: abc
          ;bar: def
        ==
      ==
    "<baz><foo>abc</foo><bar>def</bar></baz>"
<


`+$mart:hoot`~

Dynamic XML attributes

A list of atributes for an XML tag. For each list item, `n` is a `$mane:hoot`
(an attribute name with optional namespace) and `v` is a `(list beer:hoot)`
(the attribute itself, maybe with interpolated hoon).

Source~
>
    +$  mart  (list [n=mane v=(list beer)])
<

Examples~
>
    > *mart:hoot
    ~
    
    > `manx:hoot`;foo.bar;
    [g=[n=%foo a=~[[n=%class v=~['b' 'a' 'r']]]] c=~]
    
    > `mart:hoot`a.g:`manx:hoot`;foo.bar;
    ~[[n=%class v=~['b' 'a' 'r']]]
    
    > (en-xml:html ;foo.bar;)
    "<foo class=\"bar\"></foo>"
<


`+$marx:hoot`~

Dynamic XML tag

An XML tag with optional attributes. `n` is a `$mane:hoot` (the tag name with
optional namespace) and `a` is a `$mart:hoot` (any XML attributes).

Source~
>
    +$  marx  $~([%$ ~] [n=mane a=mart])
<

Examples~
>
    > `manx:hoot`;foo.bar;
    [g=[n=%foo a=~[[n=%class v=~['b' 'a' 'r']]]] c=~]
    
    > `marx:hoot`g:`manx:hoot`;foo.bar;
    [n=%foo a=~[[n=%class v=~['b' 'a' 'r']]]]
    
    > (en-xml:html ;foo.bar;)
    "<foo class=\"bar\"></foo>"
<


`+$mare:hoot`~

Node or nodes

If `%.y`, a `$manx:hoot` (single XML node). If `%.n`, a `$marl:hoot` (list of
XML nodes).

Source~
>
    +$  mare  (each manx marl)
<

Examples~
>
    > *mare:hoot
    [%.y p=[g=[n=%$ a=~] c=~]]
    
    > `mare:hoot`[%.y ;foo.bar;]
    [%.y p=[g=[n=%foo a=~[[n=%class v=~['b' 'a' 'r']]]] c=~]]
    
    > `mare:hoot`[%.n ~[;foo.bar; ;baz;]]
    [%.n p=~[[g=[n=%foo a=~[[n=%class v=~['b' 'a' 'r']]]] c=~] [g=[n=%baz a=~] c=~]]]
<


`+$maru:hoot`~

Interpolation or nodes

If `%.y`, a `$tuna:hoot`. If `%.n`, a `$marl:hoot`.

Source~
>
    +$  maru  (each tuna marl)
<


`+$tuna:hoot`~

Maybe interpolation

Kinds of nodes. Either an ordinary `$manx:hoot`, or else a plain tape, a
`$marl:hoot`, or a function call.

Source~
>
    +$  tuna
        $~  [[%$ ~] ~]
        $^  manx
        $:  ?(%tape %manx %marl %call)
            p=hoon
        ==
<


------------------------------------------------------------------------------
+$HOON                                                                  *+$hoon*

Hoon AST

See the Rune section of the Hoon reference for details of what many of these
relate to.

Source~
>
    +$  hoon                                                ::
      $~  [%zpzp ~]
      $^  [p=hoon q=hoon]                                   ::
      $%                                                    ::
        [%$ p=axis]                                         ::  simple leg
      ::                                                    ::
        [%base p=base]                                      ::  base spec
        [%bust p=base]                                      ::  bunt base
        [%dbug p=spot q=hoon]                               ::  debug info in trace
        [%eror p=tape]                                      ::  assembly error
        [%hand p=type q=nock]                               ::  premade result
        [%note p=note q=hoon]                               ::  annotate
        [%fits p=hoon q=wing]                               ::  underlying ?=
        [%knit p=(list woof)]                               ::  assemble string
        [%leaf p=(pair term @)]                             ::  symbol spec
        [%limb p=term]                                      ::  take limb
        [%lost p=hoon]                                      ::  not to be taken
        [%rock p=term q=*]                                  ::  fixed constant
        [%sand p=term q=*]                                  ::  unfixed constant
        [%tell p=(list hoon)]                               ::  render as tape
        [%tune p=$@(term tune)]                             ::  minimal face
        [%wing p=wing]                                      ::  take wing
        [%yell p=(list hoon)]                               ::  render as tank
        [%xray p=manx:hoot]                                 ::  ;foo; templating
      ::                                            ::::::  cores
        [%brbc sample=(lest term) body=spec]                ::  |$
        [%brcb p=spec q=alas r=(map term tome)]             ::  |_
        [%brcl p=hoon q=hoon]                               ::  |:
        [%brcn p=(unit term) q=(map term tome)]             ::  |%
        [%brdt p=hoon]                                      ::  |.
        [%brkt p=hoon q=(map term tome)]                    ::  |^
        [%brhp p=hoon]                                      ::  |-
        [%brsg p=spec q=hoon]                               ::  |~
        [%brtr p=spec q=hoon]                               ::  |*
        [%brts p=spec q=hoon]                               ::  |=
        [%brpt p=(unit term) q=(map term tome)]             ::  |@
        [%brwt p=hoon]                                      ::  |?
      ::                                            ::::::  tuples
        [%clcb p=hoon q=hoon]                               ::  :_ [q p]
        [%clkt p=hoon q=hoon r=hoon s=hoon]                 ::  :^ [p q r s]
        [%clhp p=hoon q=hoon]                               ::  :- [p q]
        [%clls p=hoon q=hoon r=hoon]                        ::  :+ [p q r]
        [%clsg p=(list hoon)]                               ::  :~ [p ~]
        [%cltr p=(list hoon)]                               ::  :* p as a tuple
      ::                                            ::::::  invocations
        [%cncb p=wing q=(list (pair wing hoon))]            ::  %_
        [%cndt p=hoon q=hoon]                               ::  %.
        [%cnhp p=hoon q=hoon]                               ::  %-
        [%cncl p=hoon q=(list hoon)]                        ::  %:
        [%cntr p=wing q=hoon r=(list (pair wing hoon))]     ::  %*
        [%cnkt p=hoon q=hoon r=hoon s=hoon]                 ::  %^
        [%cnls p=hoon q=hoon r=hoon]                        ::  %+
        [%cnsg p=wing q=hoon r=(list hoon)]                 ::  %~
        [%cnts p=wing q=(list (pair wing hoon))]            ::  %=
      ::                                            ::::::  nock
        [%dtkt p=spec q=hoon]                               ::  .^  nock 11
        [%dtls p=hoon]                                      ::  .+  nock 4
        [%dttr p=hoon q=hoon]                               ::  .*  nock 2
        [%dtts p=hoon q=hoon]                               ::  .=  nock 5
        [%dtwt p=hoon]                                      ::  .?  nock 3
      ::                                            ::::::  type conversion
        [%ktbr p=hoon]                                      ::  ^|  contravariant
        [%ktdt p=hoon q=hoon]                               ::  ^.  self-cast
        [%ktls p=hoon q=hoon]                               ::  ^+  expression cast
        [%kthp p=spec q=hoon]                               ::  ^-  structure cast
        [%ktpm p=hoon]                                      ::  ^&  covariant
        [%ktsg p=hoon]                                      ::  ^~  constant
        [%ktts p=skin q=hoon]                               ::  ^=  label
        [%ktwt p=hoon]                                      ::  ^?  bivariant
        [%kttr p=spec]                                      ::  ^*  example
        [%ktcl p=spec]                                      ::  ^:  filter
      ::                                            ::::::  hints
        [%sgbr p=hoon q=hoon]                               ::  ~|  sell on trace
        [%sgcb p=hoon q=hoon]                               ::  ~_  tank on trace
        [%sgcn p=chum q=hoon r=tyre s=hoon]                 ::  ~%  general jet hint
        [%sgfs p=chum q=hoon]                               ::  ~/  function j-hint
        [%sggl p=$@(term [p=term q=hoon]) q=hoon]           ::  ~<  backward hint
        [%sggr p=$@(term [p=term q=hoon]) q=hoon]           ::  ~>  forward hint
        [%sgbc p=term q=hoon]                               ::  ~$  profiler hit
        [%sgls p=@ q=hoon]                                  ::  ~+  cache=memoize
        [%sgpm p=@ud q=hoon r=hoon]                         ::  ~&  printf=priority
        [%sgts p=hoon q=hoon]                               ::  ~=  don't duplicate
        [%sgwt p=@ud q=hoon r=hoon s=hoon]                  ::  ~?  tested printf
        [%sgzp p=hoon q=hoon]                               ::  ~!  type on trace
      ::                                            ::::::  miscellaneous
        [%mcts p=marl:hoot]                                 ::  ;=  list templating
        [%mccl p=hoon q=(list hoon)]                        ::  ;:  binary to nary
        [%mcfs p=hoon]                                      ::  ;/  [%$ [%$ p ~] ~]
        [%mcgl p=spec q=hoon r=hoon s=hoon]                 ::  ;<  bind
        [%mcsg p=hoon q=(list hoon)]                        ::  ;~  kleisli arrow
        [%mcmc p=spec q=hoon]                               ::  ;;  normalize
      ::                                            ::::::  compositions
        [%tsbr p=spec q=hoon]                               ::  =|  push bunt
        [%tscl p=(list (pair wing hoon)) q=hoon]            ::  =:  q w= p changes
        [%tsfs p=skin q=hoon r=hoon]                        ::  =/  typed variable
        [%tsmc p=skin q=hoon r=hoon]                        ::  =;  =/(q p r)
        [%tsdt p=wing q=hoon r=hoon]                        ::  =.  r with p as q
        [%tswt p=wing q=hoon r=hoon s=hoon]                 ::  =?  conditional =.
        [%tsgl p=hoon q=hoon]                               ::  =<  =>(q p)
        [%tshp p=hoon q=hoon]                               ::  =-  =+(q p)
        [%tsgr p=hoon q=hoon]                               ::  =>  q w=subject p
        [%tskt p=skin q=wing r=hoon s=hoon]                 ::  =^  state machine
        [%tsls p=hoon q=hoon]                               ::  =+  q w=[p subject]
        [%tssg p=(list hoon)]                               ::  =~  hoon stack
        [%tstr p=(pair term (unit spec)) q=hoon r=hoon]     ::  =*  new style
        [%tscm p=hoon q=hoon]                               ::  =,  overload p in q
      ::                                            ::::::  conditionals
        [%wtbr p=(list hoon)]                               ::  ?|  loobean or
        [%wthp p=wing q=(list (pair spec hoon))]            ::  ?-  pick case in q
        [%wtcl p=hoon q=hoon r=hoon]                        ::  ?:  if=then=else
        [%wtdt p=hoon q=hoon r=hoon]                        ::  ?.  ?:(p r q)
        [%wtkt p=wing q=hoon r=hoon]                        ::  ?^  if p is a cell
        [%wtgl p=hoon q=hoon]                               ::  ?<  ?:(p !! q)
        [%wtgr p=hoon q=hoon]                               ::  ?>  ?:(p q !!)
        [%wtls p=wing q=hoon r=(list (pair spec hoon))]     ::  ?+  ?-  w=default
        [%wtpm p=(list hoon)]                               ::  ?&  loobean and
        [%wtpt p=wing q=hoon r=hoon]                        ::  ?@  if p is atom
        [%wtsg p=wing q=hoon r=hoon]                        ::  ?~  if p is null
        [%wthx p=skin q=wing]                               ::  ?#  if q matches p
        [%wtts p=spec q=wing]                               ::  ?=  if q matches p
        [%wtzp p=hoon]                                      ::  ?!  loobean not
      ::                                            ::::::  special
        [%zpcm p=hoon q=hoon]                               ::  !,
        [%zpgr p=hoon]                                      ::  !>
        [%zpgl p=spec q=hoon]                               ::  !<
        [%zpmc p=hoon q=hoon]                               ::  !;
        [%zpts p=hoon]                                      ::  !=
        [%zppt p=(list wing) q=hoon r=hoon]                 ::  !@
        [%zpwt p=$@(p=@ [p=@ q=@]) q=hoon]                  ::  !?
        [%zpzp ~]                                           ::  !!
      ==                                                    ::
<

Examples~
>
    > *hoon
    [%zpzp ~]
    
    > `hoon`(ream '|=([a=@ b=@] [b a])')
    [ %brts
        p
      [ %bccl
          p
        [ i=[%bcts p=term=%a q=[%base p=[%atom p=~.]]]
          t=~[[%bcts p=term=%b q=[%base p=[%atom p=~.]]]]
        ]
      ]
      q=[%cltr p=~[[%wing p=~[%b]] [%wing p=~[%a]]]]
    ]
<


------------------------------------------------------------------------------
+$TYRE                                                                  *+$tyre*

List, term hoon

Associative list of `term` `hoon`, used in jet hint processing.

Source~
>
    +$  tyre  (list [p=term q=hoon])                        ::
<


------------------------------------------------------------------------------
+$TYKE                                                                  *+$tyke*

List of 'maybe' hoons

List of `unit` `hoon`, or gaps left to be inferred, in `path` parsing. When
you use a path such as `/=base=/gen/code` the path is in fact a `tyke`, where
the `=` are inferred from your current path.

Source~
>
    +$  tyke  (list (unit hoon))
<


------------------------------------------------------------------------------
+$NOCK                                                                  *+$nock*

Virtual nock.

See the Nock documentation for details.

Source~
>
    +$  nock  $^  [p=nock q=nock]                      ::  autocons
              $%  [%1 p=*]                             ::  constant
                  [%2 p=nock q=nock]                   ::  compose
                  [%3 p=nock]                          ::  cell test
                  [%4 p=nock]                          ::  increment
                  [%5 p=nock q=nock]                   ::  equality test
                  [%6 p=nock q=nock r=nock]            ::  if, then, else
                  [%7 p=nock q=nock]                   ::  serial compose
                  [%8 p=nock q=nock]                   ::  push onto subject
                  [%9 p=@ q=nock]                      ::  select arm and fire
                  [%10 p=[p=@ q=nock] q=nock]          ::  edit
                  [%11 p=$@(@ [p=@ q=nock]) q=nock]    ::  hint
                  [%12 p=nock q=nock]                  ::  grab data from sky
                  [%0 p=@]                             ::  axis select
              ==                                       ::
<

Examples~
>
    > !=([+(.) 20 -<])
    [[4 0 1] [1 20] 0 4]
    
    > (nock !=([+(.) 20]))
    [p=[%4 p=[%0 p=1]] q=[%1 p=20]]
<


------------------------------------------------------------------------------
+$NOTE                                                                  *+$note*

Type annotation

Used for documentation.

Source~
>
    +$  note                                             ::  type annotation
              $%  [%help p=help]                         ::  documentation
                  [%know p=stud]                         ::  global standard
                  [%made p=term q=(unit (list wing))]    ::  structure
              ==                                         ::
<


------------------------------------------------------------------------------
+$TYPE                                                                  *+$type*

Hoon type type

Source~
>
    +$  type  $~  %noun                                ::
              $@  $?  %noun                            ::  any nouns
                      %void                            ::  no noun
                  ==                                   ::
              $%  [%atom p=term q=(unit @)]            ::  atom / constant
                  [%cell p=type q=type]                ::  ordered pair
                  [%core p=type q=coil]                ::  object
                  [%face p=$@(term tune) q=type]       ::  namespace
                  [%fork p=(set type)]                 ::  union
                  [%hint p=(pair type note) q=type]    ::  annotation
                  [%hold p=type q=hoon]                ::  lazy evaluation
              ==                                       ::
<

Examples~
>
    > `type`[%cell [%atom %ud ~] [%atom %ud ~]]
    #t/[@ud @ud]
<


------------------------------------------------------------------------------
+$TONY                                                                  *+$tony*

`$tone` done right

An intermediate Nock computation result. Similar to a `$toon` but without a
rendered stack trace.

Source~
>
    +$  tony                               ::  ++tone done right
              $%  [%0 p=tine q=*]          ::  success
                  [%1 p=(set)]             ::  blocks
                  [%2 p=(list [@ta *])]    ::  error ~_s
              ==                           ::
<


------------------------------------------------------------------------------
+$TINE                                                                  *+$tine*

Partial noun

Source~
>
    +$  tine                            ::  partial noun
              $@  ~                     ::  open
              $%  [%& p=tine q=tine]    ::  half-blocked
                  [%| p=(set)]          ::  fully blocked
              ==                        ::
<


------------------------------------------------------------------------------
+$TOOL                                                                  *+$tool*

Type decoration

Source~
>
    +$  tool  $@(term tune)
<


------------------------------------------------------------------------------
+$TUNE                                                                  *+$tune*

Complex

Source~
>
    +$  tune                                  ::  complex
              $~  [~ ~]                       ::
              $:  p=(map term (unit hoon))    ::  aliases
                  q=(list hoon)               ::  bridges
              ==                              ::
<


------------------------------------------------------------------------------
+$TYPO                                                                  *+$typo*

Old type

Same as `$type`

Source~
>
    +$  typo  type
<


------------------------------------------------------------------------------
+$VASE                                                                  *+$vase*

Type-value pair

Typed data. A `$vase` is used wherever typed data is explicitly worked with.

Source~
>
    +$  vase  [p=type q=*]
<

Examples~
>
    > *vase
    [#t/* q=0]
    
    > !>([2 2])
    [#t/[@ud @ud] q=[2 2]]
    
    > !>('foo')
    [#t/@t q=7.303.014]
<


------------------------------------------------------------------------------
+$VISE                                                                  *+$vise*

Old vase

Same as a `$vase`.

Source~
>
    +$  vise  [p=typo q=*]
<


------------------------------------------------------------------------------
+$VIAL                                                                  *+$vial*

co/contra/in/bi

Covariant, contravariant, invariant, bivariant.

Source~
>
    +$  vial  ?(%read %rite %both %free)
<


------------------------------------------------------------------------------
+$VAIR                                                                  *+$vair*

in/contra/bi/co

Core variance.

- `%gold` - invariant payload.
- `%iron` - contravariant sample.
- `%lead` - bivariant sample.
- `%zinc` - covariant sample.


See the Hoon School lesson on type polymorphism for more details.

Source~
>
    +$  vair  ?(%gold %iron %lead %zinc)
<


------------------------------------------------------------------------------
+$VEIN                                                                  *+$vein*

Search trace

Noun search trace.

Source~
>
    +$  vein  (list (unit axis))
<


------------------------------------------------------------------------------
+$SECT                                                                  *+$sect*

Paragraph

Used in documentation.

Source~
>
    +$  sect  (list pica)
<


------------------------------------------------------------------------------
+$WHIT                                                                  *+$whit*

Documentation

Source~
>
    +$  whit                                                ::
              $:  lab=(unit term)                           ::  label
                  boy=(unit (pair cord (list sect)))        ::  body
                  def=(map term (pair cord (list sect)))    ::  definitions
                  use=(set term)                            ::  defs used
              ==                                            ::
<


------------------------------------------------------------------------------
+$WHAT                                                                  *+$what*

Help slogan/section

Source~
>
    +$  what  (unit (pair cord (list sect)))
<


------------------------------------------------------------------------------
+$WING                                                                  *+$wing*

Search path

Address in subject. A `$wing` is a path to a value in the subject. A term
alone is the trivial case of a `$wing`.

Source~
>
    +$  wing  (list limb)
<

Examples~
>
    > (ream 'a.+.c')
    [%wing p=~[%a [%.y p=3] %c]]
    
    > (wing +:(ream 'a.+.c'))
    ~[%a [%.y p=3] %c]
<


------------------------------------------------------------------------------
+$BLOCK                                                                  *+$block*

Abstract identity of resource awaited

Source~
>
    +$  block
      path
<


------------------------------------------------------------------------------
+$RESULT                                                                  *+$result*

Internal interpreter result

Source~
>
    +$  result
      $@(~ seminoun)
<


------------------------------------------------------------------------------
+$THUNK                                                                  *+$thunk*

Fragment constructor

Source~
>
    +$  thunk
      $-(@ud (unit noun))
<


------------------------------------------------------------------------------
+$DOSS                                                                  *+$doss*

Profiling

Source~
>
    +$  doss
      $:  mon=moan               ::  sample count
          hit=(map term @ud)     ::  hit points
          cut=(map path hump)    ::  cut points
      ==
<


------------------------------------------------------------------------------
+$MOAN                                                                  *+$moan*

Profiling: sample metric

Source~
>
    +$  moan         ::  sample metric
      $:  fun=@ud    ::  samples in C
          noc=@ud    ::  samples in nock
          glu=@ud    ::  samples in glue
          mal=@ud    ::  samples in alloc
          far=@ud    ::  samples in frag
          coy=@ud    ::  samples in copy
          euq=@ud    ::  samples in equal
      ==             ::
<


------------------------------------------------------------------------------
+$HUMP                                                                  *+$hump*

Profiling

Source~
>
    +$  hump
      $:  mon=moan              ::  sample count
          out=(map path @ud)    ::  calls out of
          inn=(map path @ud)    ::  calls into
      ==
<



==============================================================================
 5a: Compiler Utilities                                                                         

These functions are used internally by the compiler. They should not be used
directly and are only listed here for completeness.

------------------------------------------------------------------------------
MUSK                                                                  *++musk*

Nock with block set

Source~

This function is extremely large, please refer to `hoon.hoon` for the source.


------------------------------------------------------------------------------
BOOL                                                                  *++bool*

Make loobean

Source~
>
    ++  bool  `type`(fork [%atom %f `0] [%atom %f `1] ~)
<


------------------------------------------------------------------------------
CELL                                                                  *++cell*

Make `%cell` type

Source~
>
    ++  cell
      ~/  %cell
      |=  [hed=type tal=type]
      ^-  type
      ?:(=(%void hed) %void ?:(=(%void tal) %void [%cell hed tal]))
<


------------------------------------------------------------------------------
CORE                                                                  *++core*

Make `%core` type

Source~
>
    ++  core
      ~/  %core
      |=  [pac=type con=coil]
      ^-  type
      ?:(=(%void pac) %void [%core pac con])
<


------------------------------------------------------------------------------
HINT                                                                  *++hint*

Make `%hint` type

Source~
>
    ++  hint
      |=  [p=(pair type note) q=type]
      ^-  type
      ?:  =(%void q)  %void
      ?:  =(%noun q)  %noun
      [%hint p q]
<


------------------------------------------------------------------------------
FACE                                                                  *++face*

Make `%face` type

Source~
>
    ++  face
      ~/  %face
      |=  [giz=$@(term tune) der=type]
      ^-  type
      ?:  =(%void der)
        %void
      [%face giz der]
<


------------------------------------------------------------------------------
FORK                                                                  *++fork*

Make `%fork` type

Source~
>
    ++  fork
      ~/  %fork
      |=  yed=(list type)
      =|  lez=(set type)
      |-  ^-  type
      ?~  yed
        ?~  lez  %void
        ?:  ?=([* ~ ~] lez)  n.lez
        [%fork lez]
      %=    $
          yed  t.yed
          lez
        ?:  =(%void i.yed)  lez
        ?:  ?=([%fork *] i.yed)  (~(uni in lez) p.i.yed)
        (~(put in lez) i.yed)
      ==
<


------------------------------------------------------------------------------
COVE                                                                  *++cove*

Extract [0 *] axis

Source~
>
    ++  cove
      |=  nug=nock
      ?-    nug
          [%0 *]   p.nug
          [%11 *]  $(nug q.nug)
          *        ~_(leaf+"cove" !!)
      ==
<


------------------------------------------------------------------------------
COMB                                                                  *++comb*

Combine two formulas

Source~
>
    ++  comb
      ~/  %comb
      |=  [mal=nock buz=nock]
      ^-  nock
      ?:  ?&(?=([%0 *] mal) !=(0 p.mal))
        ?:  ?&(?=([%0 *] buz) !=(0 p.buz))
          [%0 (peg p.mal p.buz)]
        ?:  ?=([%2 [%0 *] [%0 *]] buz)
          [%2 [%0 (peg p.mal p.p.buz)] [%0 (peg p.mal p.q.buz)]]
        [%7 mal buz]
      ?:  ?=([^ [%0 %1]] mal)
        [%8 p.mal buz]
      ?:  =([%0 %1] buz)
        mal
      [%7 mal buz]
<


------------------------------------------------------------------------------
COND                                                                  *++cond*

`?:` compile

Source~
>
    ++  cond
      ~/  %cond
      |=  [pex=nock yom=nock woq=nock]
      ^-  nock
      ?-  pex
        [%1 %0]  yom
        [%1 %1]  woq
        *        [%6 pex yom woq]
      ==
<


------------------------------------------------------------------------------
CONS                                                                  *++cons*

Make formula cell

Source~
>
    ++  cons
      ~/  %cons
      |=  [vur=nock sed=nock]
      ^-  nock
      ::  this optimization can remove crashes which are essential
      ::
      ::  ?:  ?=([[%0 *] [%0 *]] +<)
      ::  ?:  ?&(=(+(p.vur) p.sed) =((div p.vur 2) (div p.sed 2)))
      ::    [%0 (div p.vur 2)]
      ::  [vur sed]
      ?:  ?=([[%1 *] [%1 *]] +<)
        [%1 p.vur p.sed]
      [vur sed]
<


------------------------------------------------------------------------------
FITZ                                                                  *++fitz*

Aura compatibility

Source~
>
    ++  fitz
      ~/  %fitz
      |=  [yaz=term wix=term]
      =+  ^=  fiz
          |=  mot=@ta  ^-  [p=@ q=@ta]
          =+  len=(met 3 mot)
          ?:  =(0 len)
            [0 %$]
          =+  tyl=(rsh [3 (dec len)] mot)
          ?:  &((gte tyl 'A') (lte tyl 'Z'))
            [(sub tyl 64) (end [3 (dec len)] mot)]
          [0 mot]
      =+  [yoz=(fiz yaz) wux=(fiz wix)]
      ?&  ?|  =(0 p.yoz)
              =(0 p.wux)
              &(!=(0 p.wux) (lte p.wux p.yoz))
          ==
          |-  ?|  =(%$ p.yoz)
                  =(%$ p.wux)
                  ?&  =((end 3 p.yoz) (end 3 p.wux))
                      $(p.yoz (rsh 3 p.yoz), p.wux (rsh 3 p.wux))
                  ==
              ==
      ==
<


------------------------------------------------------------------------------
FLAN                                                                  *++flan*

Loobean &

Source~
>
    ++  flan
      ~/  %flan
      |=  [bos=nock nif=nock]
      ^-  nock
      ?:  =(bos nif)  bos
      ?:  =([%0 0] bos)  nif
      ?:  =([%0 0] nif)  bos
      ?-    bos
          [%1 %1]   bos
          [%1 %0]   nif
          *
        ?-    nif
            [%1 %1]   nif
            [%1 %0]   bos
            *       [%6 bos nif [%1 1]]
        ==
      ==
<


------------------------------------------------------------------------------
FLIP                                                                  *++flip*

Loobean negation

Source~
>
    ++  flip
      ~/  %flip
      |=  dyr=nock
      ?:  =([%0 0] dyr)  dyr
      [%6 dyr [%1 1] [%1 0]]
<


------------------------------------------------------------------------------
FLOR                                                                  *++flor*

Loobean |

Source~
>
    ++  flor
      ~/  %flor
      |=  [bos=nock nif=nock]
      ^-  nock
      ?:  =(bos nif)  bos
      ?:  =([%0 0] bos)  nif
      ?:  =([%0 0] nif)  bos
      ?-  bos
          [%1 %1]   nif
          [%1 %0]   bos
          *
        ?-  nif
            [%1 %1]   bos
            [%1 %0]   nif
            *         [%6 bos [%1 0] nif]
        ==
      ==
<


------------------------------------------------------------------------------
HIKE                                                                  *++hike*

Compiler utility

Source~
>
    ++  hike
      ~/  %hike
      |=  [a=axis pac=(list (pair axis nock))]
      |^  =/  rel=(map axis nock)  (roll pac insert)
          =/  ord=(list axis)      (sort ~(tap in ~(key by rel)) gth)
          |-  ^-  nock
          ?~  ord
            [%0 a]
          =/  b=axis  i.ord
          =/  c=nock  (~(got by rel) b)
          =/  d=nock  $(ord t.ord)
          [%10 [b c] d]
      ::
      ++  contains
        |=  [container=axis contained=axis]
        ^-  ?
        =/  big=@    (met 0 container)
        =/  small=@  (met 0 contained)
        ?:  (lte small big)  |
        =/  dif=@  (sub small big)
        =(container (rsh [0 dif] contained))
      ::
      ++  parent
        |=  a=axis
        `axis`(rsh 0 a)
      ::
      ++  sibling
        |=  a=axis
        ^-  axis
        ?~  (mod a 2)
          +(a)
        (dec a)
      ::
      ++  insert
        |=  [e=[axe=axis fol=nock] n=(map axis nock)]
        ^-  (map axis nock)
        ?:  =/  a=axis  axe.e
            |-  ^-  ?
            ?:  =(1 a)  |
            ?:  (~(has by n) a)
              &
            $(a (parent a))
          ::  parent already in
          n
        =.  n
          ::  remove children
          %+  roll  ~(tap by n)
          |=  [[axe=axis fol=nock] m=_n]
          ?.  (contains axe.e axe)  m
          (~(del by m) axe)
        =/  sib  (sibling axe.e)
        =/  un   (~(get by n) sib)
        ?~  un   (~(put by n) axe.e fol.e)
        ::  replace sibling with parent
        %=  $
          n  (~(del by n) sib)
          e  :-  (parent sib)
             ?:  (gth sib axe.e)
               (cons fol.e u.un)
             (cons u.un fol.e)
        ==
      --
<


------------------------------------------------------------------------------
JOCK                                                                  *++jock*

Compiler utility

Source~
>
    ++  jock
      |=  rad=?
      |=  lot=coin  ^-  hoon
      ?-    -.lot
          ~
        ?:(rad [%rock p.lot] [%sand p.lot])
      ::
          %blob
        ?:  rad
          [%rock %$ p.lot]
        ?@(p.lot [%sand %$ p.lot] [$(p.lot -.p.lot) $(p.lot +.p.lot)])
      ::
          %many
        [%cltr (turn p.lot |=(a=coin ^$(lot a)))]
      ==
<


------------------------------------------------------------------------------
LOOK                                                                  *++look*

Compiler utility

Source~
>
    ++  look
      ~/  %look
      |=  [cog=term dab=(map term hoon)]
      =+  axe=1
      |-  ^-  (unit [p=axis q=hoon])
      ?-  dab
          ~  ~
      ::
          [* ~ ~]
        ?:(=(cog p.n.dab) [~ axe q.n.dab] ~)
      ::
          [* ~ *]
        ?:  =(cog p.n.dab)
          [~ (peg axe 2) q.n.dab]
        ?:  (gor cog p.n.dab)
          ~
        $(axe (peg axe 3), dab r.dab)
      ::
          [* * ~]
        ?:  =(cog p.n.dab)
          [~ (peg axe 2) q.n.dab]
        ?:  (gor cog p.n.dab)
          $(axe (peg axe 3), dab l.dab)
        ~
      ::
          [* * *]
        ?:  =(cog p.n.dab)
          [~ (peg axe 2) q.n.dab]
        ?:  (gor cog p.n.dab)
          $(axe (peg axe 6), dab l.dab)
        $(axe (peg axe 7), dab r.dab)
      ==
<


------------------------------------------------------------------------------
LOOT                                                                  *++loot*

Compiler utility

Source~
>
    ++  loot
      ~/  %loot
      |=  [cog=term dom=(map term tome)]
      =+  axe=1
      |-  ^-  (unit [p=axis q=hoon])
      ?-  dom
          ~  ~
      ::
          [* ~ ~]
        %+  bind  (look cog q.q.n.dom)
        |=((pair axis hoon) [(peg axe p) q])
      ::
          [* ~ *]
        =+  yep=(look cog q.q.n.dom)
        ?^  yep
          [~ (peg (peg axe 2) p.u.yep) q.u.yep]
        $(axe (peg axe 3), dom r.dom)
      ::
          [* * ~]
        =+  yep=(look cog q.q.n.dom)
        ?^  yep
          [~ (peg (peg axe 2) p.u.yep) q.u.yep]
        $(axe (peg axe 3), dom l.dom)
      ::
          [* * *]
        =+  yep=(look cog q.q.n.dom)
        ?^  yep
          [~ (peg (peg axe 2) p.u.yep) q.u.yep]
        =+  pey=$(axe (peg axe 6), dom l.dom)
        ?^  pey  pey
        $(axe (peg axe 7), dom r.dom)
      ==
<



==============================================================================
 5b: Macro Expansion                                                                         

These functions are used internally by the compiler. They should not be used
directly and are only listed here for completeness.

------------------------------------------------------------------------------
AH                                                                  *++ah*

Tiki engine

Source~
>
    ++  ah
      |_  tik=tiki
      ++  blue
        |=  gen=hoon
        ^-  hoon
        ?.  &(?=(%| -.tik) ?=(~ p.tik))  gen
        [%tsgr [%$ 3] gen]
      ::
      ++  teal
        |=  mod=spec
        ^-  spec
        ?:  ?=(%& -.tik)  mod
        [%over [%& 3]~ mod]
      ::
      ++  tele
        |=  syn=skin
        ^-  skin
        ?:  ?=(%& -.tik)  syn
        [%over [%& 3]~ syn]
      ::
      ++  gray
        |=  gen=hoon
        ^-  hoon
        ?-  -.tik
          %&  ?~(p.tik gen [%tstr [u.p.tik ~] [%wing q.tik] gen])
          %|  [%tsls ?~(p.tik q.tik [%ktts u.p.tik q.tik]) gen]
        ==
      ::
      ++  puce
        ^-  wing
        ?-  -.tik
          %&  ?~(p.tik q.tik [u.p.tik ~])
          %|  [[%& 2] ~]
        ==
      ::
      ++  wthp  |=  opt=(list (pair spec hoon))
                %+  gray  %wthp
                [puce (turn opt |=([a=spec b=hoon] [a (blue b)]))]
      ++  wtkt  |=([sic=hoon non=hoon] (gray [%wtkt puce (blue sic) (blue non)]))
      ++  wtls  |=  [gen=hoon opt=(list (pair spec hoon))]
                %+  gray  %wtls
                [puce (blue gen) (turn opt |=([a=spec b=hoon] [a (blue b)]))]
      ++  wtpt  |=([sic=hoon non=hoon] (gray [%wtpt puce (blue sic) (blue non)]))
      ++  wtsg  |=([sic=hoon non=hoon] (gray [%wtsg puce (blue sic) (blue non)]))
      ++  wthx  |=(syn=skin (gray [%wthx (tele syn) puce]))
      ++  wtts  |=(mod=spec (gray [%wtts (teal mod) puce]))
      --
    ::
<


------------------------------------------------------------------------------
AX                                                                  *++ax*

Spec engine

Source~

This core is very large, refer to `hoon.hoon` for the source.


------------------------------------------------------------------------------
AP                                                                  *++ap*

Hoon engine

Source~

This core is very large, refer to `hoon.hoon` for the source.



==============================================================================
 5c: Compiler Backend & Prettyprinter                                                                         

------------------------------------------------------------------------------
UT                                                                  *++ut*

Hoon compiler backend

Source~

This core is too large to include here, refer to `hoon.hoon` for the source.


------------------------------------------------------------------------------
US                                                                  *++us*

Pretty-printer backend

Source~

This core is too large to include here, refer to `hoon.hoon` for the source.


------------------------------------------------------------------------------
CAIN                                                                  *++cain*

Tank pretty-print

Pretty-print a `vase` as a `tank` using `++deal`. This is the same as
`++sell`.

Accepts~

A `vase`.

Produces~

A `tank`.

Source~
>
    ++  cain  sell
<

Examples~
>
    > (cain !>(['foo' 'bar']))
    [%rose p=[p=" " q="[" r="]"] q=~[[%leaf p="'foo'"] [%leaf p="'bar'"]]]
<


------------------------------------------------------------------------------
NOAH                                                                  *++noah*

Tape pretty-print

Pretty-print a `vase` as a `tape`. This is the same as `++text`.

Accepts~

A `vase`.

Produces~

A `tape`.

Source~
>
    ++  noah  text
<

Examples~
>
    > (noah !>(['foo' 'bar']))
    "['foo' 'bar']"
<


------------------------------------------------------------------------------
ONAN                                                                  *++onan*

Vise to vase

Convert a `vise` (old `vase`) to the new `vase`. This is the same as `++seer`.

Accepts~

A `vise`.

Produces~

A `vase`.

Source~
>
    ++  onan  seer
<

Examples~
>
    > (onan `vise`!>(['foo' 'bar']))
    [#t/[@t @t] q=[7.303.014 7.496.034]]
<


------------------------------------------------------------------------------
LEVI                                                                  *++levi*

Type nests or crash

Check if type `b` nests under type `a`. Produces `%.y` if it nests and crashes
if it does not.

Accepts~

`a` is a `type`.

`b` is a `type`.

Produces~

A `?`.

Source~
>
    ++  levi
      |=  [a=type b=type]
      (~(nest ut a) & b)
<

Examples~
>
    > (levi -:!>('foo') -:!>(%foo))
    %.y
    
    > (levi -:!>(%foo) -:!>('foo'))
    -need.%foo
    -have.@t
    nest-fail
<


------------------------------------------------------------------------------
TEXT                                                                  *++text*

Tape pretty-print

Pretty print vase `vax` as a `tape`.

Accepts~

`vax` is a `vase`.

Produces~

A `tape`.

Source~
>
    ++  text
      |=  vax=vase  ^-  tape
      ~(ram re (sell vax))
<

Examples~
>
    > (text !>(['foo' 'bar']))
    "['foo' 'bar']"
<


------------------------------------------------------------------------------
SEEM                                                                  *++seem*

Promote typo

Convert `typo` (old type) to the new `type`.

Accepts~

`toy` is a `typo`.

Produces~

A `type`.

Source~
>
    ++  seem  |=(toy=typo `type`toy)
<

Examples~
>
    > (seem -:!>('foo'))
    #t/@t
<


------------------------------------------------------------------------------
SEER                                                                  *++seer*

Promote vise

Convert a `vise` (old `vase`) to the new `vase`.

Accepts~

`vix` is a `vise`.

Produces~

A `vase`.

Source~
>
    ++  seer  |=(vix=vise `vase`vix)
<

Examples~
>
    > (seer !>('foo'))
    [#t/@t q=7.303.014]
<


------------------------------------------------------------------------------
SELL                                                                  *++sell*

Pretty-print vase to a tank

Pretty-print vase `vax` to a `tank` using `++deal:us`.

Accepts~

`vax` is a `vase`.

Produces~

A `tank`.

Source~
>
    ++  sell
      ~/  %sell
      |=  vax=vase
      ^-  tank
      ~|  %sell
      (~(deal us p.vax) q.vax)
<

Examples~
>
    > (sell !>(['foo' 'bar']))
    [%rose p=[p=" " q="[" r="]"] q=~[[%leaf p="'foo'"] [%leaf p="'bar'"]]]
<


------------------------------------------------------------------------------
SKOL                                                                  *++skol*

Pretty-print type to tank

Pretty-print type `typ` to a `tank` using `++duck:ut`.

Accepts~

`typ` is a `type`.

Produces~

A `tank`.

Source~
>
    ++  skol
      |=  typ=type
      ^-  tank
      ~(duck ut typ)
<

Examples~
>
    > (skol -:!>(['foo' 'bar']))
    [%rose p=[p=" " q="[" r="]"] q=~[[%leaf p="@t"] [%leaf p="@t"]]]
<


------------------------------------------------------------------------------
SLAM                                                                  *++slam*

Slam a gate

Slam `gat`, a gate in a `vase`, with `sam`, a sample in a `vase`. Produces a
`vase` containing the result.

Accepts~

`gat` is a gate in a `vase`.

`sam` is a noun in a `vase`.

Produces~

A `vase`.

Source~
>
    ++  slam
      |=  [gat=vase sam=vase]  ^-  vase
      =+  :-  ^=  typ  ^-  type
              [%cell p.gat p.sam]
          ^=  gen  ^-  hoon
          [%cnsg [%$ ~] [%$ 2] [%$ 3] ~]
      =+  gun=(~(mint ut typ) %noun gen)
      [p.gun (slum q.gat q.sam)]
<

Examples~
>
    > (slam !>(|=([a=@ud b=@ud] [b a])) !>([1 2]))
    [#t/[@ud @ud] q=[2 1]]
<


------------------------------------------------------------------------------
SLAB                                                                  *++slab*

Test if contains

States whether you can access named wing `cog` in type `typ` using access
method `way`.

Accepts~

`way` is a `?(%read %rite %both)` (A `$vial` without `%free`). This represents
the access method (read, write, or both read and write).

`cog` is a `@tas`, the name of a wing.

`typ` is a `type`.

Produces~

A `?`.

Source~
>
    ++  slab
      |=  [way=?(%read %rite %both) cog=@tas typ=type]
      ?=  [%& *]
      (~(fond ut typ) way ~[cog])
<
>
    > =au |=(a=@ +(a))
    > (slab %read %a -:!>(au))
    %.y
    > (slab %rite %a -:!>(au))
    %.y
    > (slab %both %a -:!>(au))
    %.y
    
    > (slab %both %blah -:!>(au))
    %.n
    
    > =fe ^|(|=(a=@ +(a)))
    > (slab %read %a -:!>(fe))
    %.n
    > (slab %rite %a -:!>(fe))
    %.y
    > (slab %both %a -:!>(fe))
    %.n
<


------------------------------------------------------------------------------
SLAP                                                                  *++slap*

Untyped vase `.*`

Compile hoon `gen` with subject `vax` using `.*`, producing a `vase` of the
result.

Accepts~

`vax` is a noun in a `vase`, and is the subject.

`gen` is some `hoon`.

Produces~

A `vase`.

Source~
>
    ++  slap
      |=  [vax=vase gen=hoon]  ^-  vase
      =+  gun=(~(mint ut p.vax) %noun gen)
      [p.gun .*(q.vax q.gun)]
<

Examples~
>
    > (slap !>(b='foo') (ream '|=(a=@t [a b])'))
    [#t/<1.qgm [a=@t b=@t]> q=[[[0 6] 0 7] 0 7.303.014]]
    
    > !<($-(@t [@t @t]) (slap !>(b='foo') (ream '|=(a=@t [a b])')))
    <1|xpg [@t @t @t @t]>
    
    > (!<($-(@t [@t @t]) (slap !>(b='foo') (ream '|=(a=@t [a b])'))) 'bar')
    ['bar' 'foo']
<


------------------------------------------------------------------------------
SLOG                                                                  *++slog*

Deify printf

Prints stack trace `a` if the stack trace isn't null, then produces the other
input. `+slog` first takes `a`, producing a gate. The gate then takes some
hoon.

Accepts~

`a` is a `tang`, and is the sample of `+slog`.

`(slog a)` takes some `hoon`.

Produces~

The result of the hoon given to `(slog a)`, with `a` printed to the terminal.

Source~
>
    ++  slog
      =|  pri=@
      |=  a=tang  ^+  same
      ?~(a same ~>(%slog.[pri i.a] $(a t.a)))
<

Examples~
>
    foo
    > ((slog leaf+"foo" ~) (add 1 1))
    2
<

Discussion~

`slog` is intended to be put in the middle of a bunch of chained function
calls that string a piece of data through them, so that an error message will
be printed if there's one to print.


------------------------------------------------------------------------------
MEAN                                                                  *++mean*

Crash and printf

Ends the program and prints `a`, a tracing error message.

Accepts~

`a` is a `tang`.

Produces~

A crash, with `a` printed to the terminal.

Source~
>
    ++  mean
      |=  a=tang
      ^+  !!
      ?~  a  !!
      ~_(i.a $(a t.a))
<

Examples~
>
    > (mean leaf+"foo" ~)
    foo
    dojo: hoon expression failed
<


------------------------------------------------------------------------------
ROAD                                                                  *++road*

Evaluate trap

Evaluate a `trap`, producing the result if successful or else crashing with a
trace.

Accepts~

A `trap`.

Produces~

A noun.

Source~
>
    ++  road
      |*  =(trap *)
      ^+  $:trap
      =/  res  (mule trap)
      ?-  -.res
        %&  p.res
        %|  (mean p.res)
      ==
<

Examples~
>
    > (road |.("foo"))
    "foo"
    
    > (road |.(~|('crash!' !!)))
    'crash!'
    dojo: hoon expression failed
<


------------------------------------------------------------------------------
SLEW                                                                  *++slew*

Get axis in vase

Get axis `axe` in vase `vax`, producing the resulting `vase` in a `unit` which
is null if the axis cannot be retrieved.

Accepts~

`axe` is an atom.

`vax` is a `vase`.

Produces~

A `(unit vase)`.

Source~
>
    ++  slew
      |=  [axe=@ vax=vase]  ^-  (unit vase)
      ?.  |-  ^-  ?
          ?:  =(1 axe)  &
          ?.  ?=(^ q.vax)  |
          $(axe (mas axe), q.vax .*(q.vax [0 (cap axe)]))
        ~
      `[(~(peek ut p.vax) %free axe) .*(q.vax [0 axe])]
<

Examples~
>
    > (slew 3 !>(['foo' 'bar']))
    [~ [#t/@t q=7.496.034]]
    
    > !<(@t (need (slew 3 !>(['foo' 'bar']))))
    'bar'
    
    > (slew 7 !>(['foo' 'bar']))
    ~
<


------------------------------------------------------------------------------
SLIM                                                                  *++slim*

Identical to `++seer`

Convert a `vise` (old `vase`) to a `vase`. Identical to `++seer`.

Accepts~

`old` is a `vise`.

Produces~

A `vase`.

Source~
>
    ++  slim
      |=  old=vise  ^-  vase
      old
<

Examples~
>
    > (slim !>('foo'))
    [#t/@t q=7.303.014]
<


------------------------------------------------------------------------------
SLIT                                                                  *++slit*

Type of slam

The `type` produced if a gate of type `gat` were slammed with a sample of type
`sam`.

Accepts~

`gat` is a `type`.

`sam` is a `type`.

Produces~

A `type`.

Source~
>
    ++  slit
      |=  [gat=type sam=type]
      ?>  (~(nest ut (~(peek ut gat) %free 6)) & sam)
      (~(play ut [%cell gat sam]) [%cnsg [%$ ~] [%$ 2] [%$ 3] ~])
<

Examples~
>
    > (slit -:!>(|*(a=@ [a a])) -:!>(42))
    #t/[@ud @ud]
    
    > (slit -:!>(|*(a=@ [a a])) -:!>('foo'))
    #t/[@t @t]
<


------------------------------------------------------------------------------
SLOB                                                                  *++slob*

Superficial arm

Source~
>
    ++  slob
      |=  [cog=@tas typ=type]
      ^-  ?
      ?+  typ  |
          [%hold *]  $(typ ~(repo ut typ))
          [%hint *]  $(typ ~(repo ut typ))
          [%core *]
        |-  ^-  ?
        ?~  q.r.q.typ  |
        ?|  (~(has by q.q.n.q.r.q.typ) cog)
            $(q.r.q.typ l.q.r.q.typ)
            $(q.r.q.typ r.q.r.q.typ)
        ==
      ==
<


------------------------------------------------------------------------------
SLOE                                                                  *++sloe*

Get arms in core

Produces a list of the arms in a core of type `typ`.

Accepts~

`typ` is a type.

Produces~

A `(list term)`.

Source~
>
    ++  sloe
      |=  typ=type
      ^-  (list term)
      ?+    typ  ~
          [%hold *]  $(typ ~(repo ut typ))
          [%hint *]  $(typ ~(repo ut typ))
          [%core *]
        %-  zing
        %+  turn  ~(tap by q.r.q.typ)
          |=  [* b=tome]
        %+  turn  ~(tap by q.b)
          |=  [a=term *]
        a
      ==
<

Examples~
>
    > (sloe -:!>(|=(@ 1)))
    ~[%$]
    
    > =cr |%
          ++  foo  1
          ++  bar  2
          ++  baz  3
          --
    
    > (sloe -:!>(cr))
    ~[%foo %baz %bar]
    
    > (sloe -:!>(42))
    ~
<


------------------------------------------------------------------------------
SLOP                                                                  *++slop*

Cons two vases

Produce the vase of a cell of vases `hed` and `tal`.

Accepts~

`hed` is a `vase`.

`tal` is a `vase`.

Produces~

A `vase`.

Source~
>
    ++  slop
      |=  [hed=vase tal=vase]
      ^-  vase
      [[%cell p.hed p.tal] [q.hed q.tal]]
<

Examples~
>
    > (slop !>('foo') !>(42))
    [#t/[@t @ud] q=[7.303.014 42]]
    
    > !<([@t @ud] (slop !>('foo') !>(42)))
    ['foo' 42]
<


------------------------------------------------------------------------------
SLOT                                                                  *++slot*

Got axis in vase

Get axis `axe` in vase `vax`, returning it in a `vase`. Crashes if the axis
cannot be retrieved.

Accepts~

`axe` is an atom.

`vax` is a `vase`.

Produces~

A `vase`.

Source~
>
    ++  slot
      |=  [axe=@ vax=vase]  ^-  vase
      [(~(peek ut p.vax) %free axe) .*(q.vax [0 axe])]
<

Examples~
>
    > (slot 3 !>(['foo' 'bar']))
    [#t/@t q=7.496.034]
    
    > !<(@t (slot 3 !>(['foo' 'bar'])))
    'bar'
    
    > (slot 7 !>(['foo' 'bar']))
    dojo: hoon expression failed
<


------------------------------------------------------------------------------
SLYM                                                                  *++slym*

Slam without sample-type

Slam `gat`, a gate in a `vase`, with `sam`, a `noun`. The type of `sam` is
ignored and the type of the resulting vase is determined by the gate alone.

Accepts~

`gat` is a `vase`.

`sam` is a noun.

Produces~

A `vase`.

Source~
>
    ++  slym
      |=  [gat=vase sam=*]  ^-  vase
      (slap gat(+<.q sam) [%limb %$])
<

Examples~
>
    > (slym !>(|*(a=@ux [a a])) 'foo')
    [#t/[@ux @ux] q=[7.303.014 7.303.014]]
    
    > (slym !>(|*(a=@ux [a a])) "foobar")
    [#t/[@ux @ux] q=[[102 111 111 98 97 114 0] 102 111 111 98 97 114 0]]
<


------------------------------------------------------------------------------
SPED                                                                  *++sped*

Reconstruct type

Source~
>
    ++  sped
      |=  vax=vase
      ^-  vase
      :_  q.vax
      ?@  q.vax  (~(fuse ut p.vax) [%atom %$ ~])
      ?@  -.q.vax
        ^=  typ
        %-  ~(play ut p.vax)
        [%wtgr [%wtts [%leaf %tas -.q.vax] [%& 2]~] [%$ 1]]
      (~(fuse ut p.vax) [%cell %noun %noun])
<


------------------------------------------------------------------------------
SWAT                                                                  *++swat*

Deferred `++slap`

This is the same as `++slap` except `tap` is the subject `vase` encapsulated
in a `trap`, and a `(trap vase)` is produced.

Accepts~

`tap` is a `(trap vase)`.

`gen` is `hoon`.

Produces~

A `(trap vase)`.

Source~
>
    ++  swat
      |=  [tap=(trap vase) gen=hoon]
      ^-  (trap vase)
      =/  gun  (~(mint ut p:$:tap) %noun gen)
      |.  ~+
      [p.gun .*(q:$:tap q.gun)]
<

Examples~
>
    > %.  10
      !<  $-(@ @)
      %-  road
      %+  swat
        |.(!>(add-42=(cury add 42)))
      (ream '|=(a=@ (add-42 a))')
    52
<



==============================================================================
 5d: Parser                                                                         

------------------------------------------------------------------------------
VANG                                                                  *++vang*

Set `++vast` parameters

Source~
>
    ++  vang                                                ::  set ++vast params
      |=  [bug=? wer=path]                                  ::  bug: debug mode
      %*(. vast bug bug, wer wer)                           ::  wer: where we are
<


------------------------------------------------------------------------------
VAST                                                                  *++vast*

Main parsing core

Source~

This core is too large to include here, please refer to `hoon.hoon` for the
source.


`++vest`~

Parse hoon

Parsing `rule`. Parse hoon of any form.

Source~
>
    ++  vest
      ~/  %vest
      |=  tub=nail
      ^-  (like hoon)
      %.  tub
      %-  full
      (ifix [gay gay] tall:vast)
<

Examples~
>
    > (rash '(add 1 1)' vest)
    [%cncl p=[%wing p=~[%add]] q=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]
    
    > (rash '%+  add\0a  1\0a1' vest)
    [%cnls p=[%wing p=~[%add]] q=[%sand p=%ud q=1] r=[%sand p=%ud q=1]]
<


`++vice`~

Parse wide-form hoon

Parse `txt`, a `knot` containing wide-form hoon, to `hoon`.

Accepts~

`txt` is a `@ta`.

Produces~

`hoon`.

Source~
>
    ++  vice
      |=  txt=@ta
      ^-  hoon
      (rash txt wide:vast)
<

Examples~
>
    > (vice '(add 1 1)')
    [%cncl p=[%wing p=~[%add]] q=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]
    
    > (vice '%+  add\0a  1\0a1')
    {1 3}
    syntax error
<


------------------------------------------------------------------------------
MAKE                                                                  *++make*

Compile cord to nock

Compile `txt`, an `atom` containing hoon source code as little-endian UTF-8
text, to `nock`.

Accepts~

`txt` is a `@`.

Produces~

`nock`.

Source~
>
    ++  make
      |=  txt=@
      q:(~(mint ut %noun) %noun (ream txt))
<

Examples~
>
    > (make '[. . .]')
    [p=[%0 p=1] q=[p=[%0 p=1] q=[%0 p=1]]]
    
    > .*(42 (make '[. . .]'))
    [42 42 42]
<


------------------------------------------------------------------------------
RAIN                                                                  *++rain*

Parse with % path

Parse `txt`, an `atom` containing hoon source code as little-endian UTF-8
text, to `hoon`. Any `%` path short-hands are replaced with the path given in
`bon`. If parsing fails, `bon` is also printed to the terminal.

Accepts~

`bon` is a `path`.

`txt` is an atom.

Produces~

`hoon`.

Source~
>
    ++  rain
      |=  [bon=path txt=@]
      ^-  hoon
      =+  vaz=vast
      ~|  bon
      (scan (trip txt) (full (ifix [gay gay] tall:vaz(wer bon))))
<

Examples~
>
    > (rain /a/b/c '%')
    [%clsg p=~[[%sand p=%ta q=97] [%sand p=%ta q=98] [%sand p=%ta q=99]]]
    
    > !<(path (slap !>(~) (rain /a/b/c '%')))
    /a/b/c
    
    > (rain / '(add 1 1)')
    [%cncl p=[%wing p=~[%add]] q=~[[%sand p=%ud q=1] [%sand p=%ud q=1]]]
    
    > !<(@ud (slap !>(add=add) (rain / '(add 1 1)')))
    2
<


------------------------------------------------------------------------------
REAM                                                                  *++ream*

Parse cord to hoon

Parse `txt`, an `atom` containing hoon source code as little-endian UTF-8
text, to `hoon`.

Accepts~

`txt` is an atom.

Produces~

`hoon`.

Source~
>
    ++  ream
      |=  txt=@
      ^-  hoon
      (rash txt vest)
<

Examples~
>
    > !<(tape (slap !>(~) (ream '"foobar"')))
    "foobar"
<


------------------------------------------------------------------------------
RECK                                                                  *++reck*

Parse hoon file

Parse `bon` to `hoon`. `bon` is a `path` to a .hoon file without the mark.

Accepts~

`bon` is a `path`.

Produces~

`hoon`.

Source~
>
    ++  reck
      |=  bon=path
      (rain bon .^(@t %cx (weld bon `path`[%hoon ~])))
<

Examples~
>
    > (reck %/gen/code)
    [ %clhp
      p=[%rock p=%tas q=7.954.803]
        q
      [ %brts
          p
        [ %bccl
            p
          [   i
            [ %bccl
                p
              [   i
                [%bcts p=term=%now q=[%base p=[%atom p=~.da]]]
                  t
    ......(truncated for brevity)..........
<


------------------------------------------------------------------------------
RIDE                                                                  *++ride*

End-to-end compiler

Parse and compile cord `txt`, producing a pair of its `type` and compiled
`nock`. The `typ` argument specifies the `type` of the subject.

Accepts~

`typ` is a `type`

`txt` is an atom.

Produces~

A `(pair type nock)`.

Source~
>
    ++  ride
      |=  [typ=type txt=@]
      ^-  (pair type nock)
      ~>  %slog.[0 leaf/"ride: parsing"]
      =/  gen  (ream txt)
      ~>  %slog.[0 leaf/"ride: compiling"]
      ~<  %slog.[0 leaf/"ride: compiled"]
      (~(mint ut typ) %noun gen)
<

Examples~
>
    ride: parsing
    ride: compiling
    ride: compiled
    > (ride -:!>(.) '(add 2 2)')
    [ #t/@
        q
      [ %8
        p=[%9 p=36 q=[%0 p=1.023]]
          q
        [ %9
          p=2
            q
          [ %10
              p
            [ p=6
                q
              [ p=[%7 p=[%0 p=3] q=[%1 p=2]]
                q=[%7 p=[%0 p=3] q=[%1 p=2]]
              ]
            ]
            q=[%0 p=2]
          ]
        ]
      ]
    ]
    
    ride: parsing
    ride: compiling
    > (ride %noun '(add 2 2)')
    -find.add
    dojo: hoon expression failed
<



==============================================================================
 5e: Molds and mold builders                                                                         

------------------------------------------------------------------------------
+$MANE                                                                  *+$mane*

XML name+space

XML tag name and optional namespace.

Source~
>
    +$  mane  $@(@tas [@tas @tas])
<

Examples~
>
    > (en-xml:html ;foo;)
    "<foo></foo>"
    
    > (en-xml:html ;foo_bar;)
    "<foo:bar></foo:bar>"
    
    > `manx`;foo_bar;
    [g=[n=[%foo %bar] a=~] c=~]
    
    > `mane`n.g:`manx`;foo_bar;
    [%foo %bar]
    
    > `mane`n.g:`manx`;foo;
    %foo
<


------------------------------------------------------------------------------
+$MANX                                                                  *+$manx*

Dynamic XML node

An XML element which may contain text, attributes, and other elements.

`g` is a `$marx` (a tag) and `c` is a `$marl` (its contents).

Source~
>
    +$  manx  $~([[%$ ~] ~] [g=marx c=marl])
<

Examples~
>
    > *manx
    [g=[n=%$ a=~] c=~
    
    > `manx`;foo;
    [g=[n=%foo a=~] c=~]
    
    > (en-xml:html `manx`;foo;)
    "<foo></foo>"
    
    > =a ^-  manx
         ;foo
           ;bar: abc
           ;baz
             ;xxx: hello
           ==
         ==
    
    > a
    [ g=[n=%foo a=~]
        c
      ~[
        [ g=[n=%bar a=~]
          c=~[[g=[n=%$ a=~[[n=%$ v="abc"]]] c=~]]
        ]
        [ g=[n=%baz a=~]
            c
          ~[
            [ g=[n=%xxx a=~]
              c=~[[g=[n=%$ a=~[[n=%$ v="hello"]]] c=~]]
            ]
          ]
        ]
      ]
    ]
    
    > (en-xml:html a)
    "<foo><bar>abc</bar><baz><xxx>hello</xxx></baz></foo>"
<


------------------------------------------------------------------------------
+$MARL                                                                  *+$marl*

XML node list

A list of XML nodes (`$marx`).

Source~
>
    +$  marl  (list manx)
<

Examples~
>
    > *marl
    ~
    
    > ^-  marl
      ;=
        ;foo: abc
        ;bar: def
      ==
    ~[
      [g=[n=%foo a=~] c=~[[g=[n=%$ a=~[[n=%$ v=~['a' 'b' 'c']]]] c=~]]]
      [g=[n=%bar a=~] c=~[[g=[n=%$ a=~[[n=%$ v=~['d' 'e' 'f']]]] c=~]]]
    ]
    
    > %-  en-xml:html
      ;baz
        ;=
          ;foo: abc
          ;bar: def
        ==
      ==
    "<baz><foo>abc</foo><bar>def</bar></baz>"
<


------------------------------------------------------------------------------
+$MARS                                                                  *+$mars*

XML cdata

Source~
>
    +$  mars  [t=[n=%$ a=[i=[n=%$ v=tape] t=~]] c=~]
<


------------------------------------------------------------------------------
+$MART                                                                  *+$mart*

XML attributes

A list of atributes for an XML tag. For each list item, `n` is a `$mane` (an
attribute name with optional namespace) and `v` is a `tape` (the attribute
itself).

Source~
>
    +$  mart  (list [n=mane v=tape])
<

Examples~
>
    > *mart
    ~
    
    > `manx`;foo.bar;
    [g=[n=%foo a=~[[n=%class v="bar"]]] c=~]
    
    > `mart`a.g:`manx`;foo.bar;
    ~[[n=%class v="bar"]]
    
    > (en-xml:html ;foo.bar;)
    "<foo class=\"bar\"></foo>"
<


------------------------------------------------------------------------------
+$MARX                                                                  *+$marx*

Dynamic XML tag

An XML tag with optional attributes. `n` is a `$mane` (the tag name with
optional namespace) and `a` is a `$mart` (any XML attributes).

Source~
>
    +$  marx  $~([%$ ~] [n=mane a=mart])
<

Examples~
>
    > `manx`;foo.bar;
    [g=[n=%foo a=~[[n=%class v="bar"]]] c=~]
    
    > `marx`g:`manx`;foo.bar;
    [n=%foo a=~[[n=%class v="bar"]]]
    
    > (en-xml:html ;foo.bar;)
    "<foo class=\"bar\"></foo>"
<


------------------------------------------------------------------------------
+$MITE                                                                  *+$mite*

MIME type

This type represents a MIME type like `text/plain` as a `path`.

Source~
>
    +$  mite  (list @ta)
<

Examples~
>
    > `mite`/text/plain
    /text/plain
<


------------------------------------------------------------------------------
+$PASS                                                                  *+$pass*

Public key

This type is used for a ship's public key, as an atom.

Source~
>
    +$  pass  @
<


------------------------------------------------------------------------------
+$RING                                                                  *+$ring*

Private key

This type is used for a ship's private key, as an atom.

Source~
>
    +$  ring  @
<


------------------------------------------------------------------------------
+$SHIP                                                                  *+$ship*

Network identity

Just an `@p`

Source~
>
    +$  ship  @p
<

Examples~
>
    > *ship
    ~zod
    
    > `ship`~sampel-palnet
    ~sampel-palnet
<


------------------------------------------------------------------------------
+$SHOP                                                                  *+$shop*

Urbit/DNS identity

Either a `$ship` or a domain name as a `path`.

Source~
>
    +$  shop  (each ship (list @ta))
<


------------------------------------------------------------------------------
+$SPUR                                                                  *+$spur*

ship desk case spur

The part of a Clay `path` after the `%`.

Source~
>
    +$  spur  path
<


------------------------------------------------------------------------------
+$TIME                                                                  *+$time*

Galactic time

Just a `@da`

Source~
>
    +$  time  @da
<

Examples~
>
    > *time
    ~2000.1.1
<



==============================================================================
 5f: Profiling support                                                                         

------------------------------------------------------------------------------
PI-HECK                                                                  *++pi-heck*

Profiling utility

Source~
>
    ++  pi-heck
        |=  [nam=@tas day=doss]
        ^-  doss
        =+  lam=(~(get by hit.day) nam)
        day(hit (~(put by hit.day) nam ?~(lam 1 +(u.lam))))
<


------------------------------------------------------------------------------
PI-NOON                                                                  *++pi-noon*

Sample trace

Source~
>
    ++  pi-noon
      |=  [mot=term paz=(list path) day=doss]
      =|  lax=(unit path)
      |-  ^-  doss
      ?~  paz  day(mon (pi-mope mot mon.day))
      %=    $
          paz  t.paz
          lax  `i.paz
          cut.day
        %+  ~(put by cut.day)  i.paz
        ^-  hump
        =+  nax=`(unit path)`?~(t.paz ~ `i.t.paz)
        =+  hup=`hump`=+(hup=(~(get by cut.day) i.paz) ?^(hup u.hup [*moan ~ ~]))
        :+  (pi-mope mot mon.hup)
          ?~  lax  out.hup
          =+  hag=(~(get by out.hup) u.lax)
          (~(put by out.hup) u.lax ?~(hag 1 +(u.hag)))
        ?~  nax  inn.hup
        =+  hag=(~(get by inn.hup) u.nax)
        (~(put by inn.hup) u.nax ?~(hag 1 +(u.hag)))
      ==
<


------------------------------------------------------------------------------
PI-MOPE                                                                  *++pi-mope*

Add sample

Source~
>
    ++  pi-mope
      |=  [mot=term mon=moan]
      ?+  mot  mon
        %fun  mon(fun +(fun.mon))
        %noc  mon(noc +(noc.mon))
        %glu  mon(glu +(glu.mon))
        %mal  mon(mal +(mal.mon))
        %far  mon(far +(far.mon))
        %coy  mon(coy +(coy.mon))
        %euq  mon(euq +(euq.mon))
      ==
<


------------------------------------------------------------------------------
PI-MOTH                                                                  *++pi-moth*

Count sample

Source~
>
    ++  pi-moth
      |=  mon=moan  ^-  @ud
      :(add fun.mon noc.mon glu.mon mal.mon far.mon coy.mon euq.mon)
<


------------------------------------------------------------------------------
PI-MUMM                                                                  *++pi-mumm*

Print sample

Source~
>
    ++  pi-mumm
      |=  mon=moan  ^-  tape
      =+  tot=(pi-moth mon)
      ;:  welp
        ^-  tape
        ?:  =(0 noc.mon)  ~
        (welp (scow %ud (div (mul 100 noc.mon) tot)) "n ")
      ::
        ^-  tape
        ?:  =(0 fun.mon)  ~
        (welp (scow %ud (div (mul 100 fun.mon) tot)) "c ")
      ::
        ^-  tape
        ?:  =(0 glu.mon)  ~
        (welp (scow %ud (div (mul 100 glu.mon) tot)) "g ")
      ::
        ^-  tape
        ?:  =(0 mal.mon)  ~
        (welp (scow %ud (div (mul 100 mal.mon) tot)) "m ")
      ::
        ^-  tape
        ?:  =(0 far.mon)  ~
        (welp (scow %ud (div (mul 100 far.mon) tot)) "f ")
      ::
        ^-  tape
        ?:  =(0 coy.mon)  ~
        (welp (scow %ud (div (mul 100 coy.mon) tot)) "y ")
      ::
        ^-  tape
        ?:  =(0 euq.mon)  ~
        (welp (scow %ud (div (mul 100 euq.mon) tot)) "e ")
      ==
<


------------------------------------------------------------------------------
PI-TELL                                                                  *++pi-tell*

Produce dump

Source~
>
    ++  pi-tell
      |=  day=doss
      ^-  (list tape)
      ?:  =(day *doss)  ~
      =+  tot=(pi-moth mon.day)
      ;:  welp
        [(welp "events: " (pi-mumm mon.day)) ~]
      ::
        %+  turn
          %+  sort  ~(tap by hit.day)
          |=  [a=[* @] b=[* @]]
          (lth +.a +.b)
        |=  [nam=term num=@ud]
        :(welp (trip nam) ": " (scow %ud num))
        ["" ~]
      ::
        %-  zing
        ^-  (list (list tape))
        %+  turn
          %+  sort  ~(tap by cut.day)
          |=  [one=(pair path hump) two=(pair path hump)]
          (gth (pi-moth mon.q.one) (pi-moth mon.q.two))
        |=  [pax=path hup=hump]
        =+  ott=(pi-moth mon.hup)
        ;:  welp
          [(welp "label: " (spud pax)) ~]
          [(welp "price: " (scow %ud (div (mul 100 ott) tot))) ~]
          [(welp "shape: " (pi-mumm mon.hup)) ~]
        ::
          ?:  =(~ out.hup)  ~
          :-  "into:"
          %+  turn
            %+  sort  ~(tap by out.hup)
            |=([[* a=@ud] [* b=@ud]] (gth a b))
          |=  [pax=path num=@ud]
          ^-  tape
          :(welp "  " (spud pax) ": " (scow %ud num))
        ::
          ?:  =(~ inn.hup)  ~
          :-  "from:"
          %+  turn
            %+  sort  ~(tap by inn.hup)
            |=([[* a=@ud] [* b=@ud]] (gth a b))
          |=  [pax=path num=@ud]
          ^-  tape
          :(welp "  " (spud pax) ": " (scow %ud num))
        ::
          ["" ~]
          ~
        ==
      ==
<

